; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3BitsetNew
PUBLIC	antlr3BitsetOf
PUBLIC	antlr3BitsetList
PUBLIC	antlr3BitsetCopy
PUBLIC	antlr3BitsetLoad
PUBLIC	antlr3BitsetSetAPI
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3EnumNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetNew DD imagerel $LN6
	DD	imagerel $LN6+183
	DD	imagerel $unwind$antlr3BitsetNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetOf DD imagerel $LN6
	DD	imagerel $LN6+169
	DD	imagerel $unwind$antlr3BitsetOf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetList DD imagerel $LN5
	DD	imagerel $LN5+151
	DD	imagerel $unwind$antlr3BitsetList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetCopy DD imagerel $LN6
	DD	imagerel $LN6+176
	DD	imagerel $unwind$antlr3BitsetCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetLoad DD imagerel $LN8
	DD	imagerel $LN8+154
	DD	imagerel $unwind$antlr3BitsetLoad
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetSetAPI DD imagerel $LN3
	DD	imagerel $LN3+216
	DD	imagerel $unwind$antlr3BitsetSetAPI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetClone DD imagerel antlr3BitsetClone
	DD	imagerel antlr3BitsetClone+90
	DD	imagerel $unwind$antlr3BitsetClone
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetOR DD imagerel antlr3BitsetOR
	DD	imagerel antlr3BitsetOR+96
	DD	imagerel $unwind$antlr3BitsetOR
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetORInPlace DD imagerel antlr3BitsetORInPlace
	DD	imagerel antlr3BitsetORInPlace+212
	DD	imagerel $unwind$antlr3BitsetORInPlace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetSize DD imagerel antlr3BitsetSize
	DD	imagerel antlr3BitsetSize+179
	DD	imagerel $unwind$antlr3BitsetSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetAdd DD imagerel antlr3BitsetAdd
	DD	imagerel antlr3BitsetAdd+128
	DD	imagerel $unwind$antlr3BitsetAdd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetEquals DD imagerel antlr3BitsetEquals
	DD	imagerel antlr3BitsetEquals+307
	DD	imagerel $unwind$antlr3BitsetEquals
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetMember DD imagerel antlr3BitsetMember
	DD	imagerel antlr3BitsetMember+115
	DD	imagerel $unwind$antlr3BitsetMember
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetNumBits DD imagerel antlr3BitsetNumBits
	DD	imagerel antlr3BitsetNumBits+19
	DD	imagerel $unwind$antlr3BitsetNumBits
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetRemove DD imagerel antlr3BitsetRemove
	DD	imagerel antlr3BitsetRemove+117
	DD	imagerel $unwind$antlr3BitsetRemove
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetIsNil DD imagerel antlr3BitsetIsNil
	DD	imagerel antlr3BitsetIsNil+72
	DD	imagerel $unwind$antlr3BitsetIsNil
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetToIntList DD imagerel antlr3BitsetToIntList
	DD	imagerel antlr3BitsetToIntList+203
	DD	imagerel $unwind$antlr3BitsetToIntList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$growToInclude DD imagerel growToInclude
	DD	imagerel growToInclude+93
	DD	imagerel $unwind$growToInclude
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$grow DD	imagerel grow
	DD	imagerel grow+131
	DD	imagerel $unwind$grow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$bitMask DD imagerel bitMask
	DD	imagerel bitMask+41
	DD	imagerel $unwind$bitMask
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$numWordsToHold DD imagerel numWordsToHold
	DD	imagerel numWordsToHold+16
	DD	imagerel $unwind$numWordsToHold
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wordNumber DD imagerel wordNumber
	DD	imagerel wordNumber+14
	DD	imagerel $unwind$wordNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3BitsetFree DD imagerel antlr3BitsetFree
	DD	imagerel antlr3BitsetFree+64
	DD	imagerel $unwind$antlr3BitsetFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetFree DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wordNumber DD 010501H
	DD	07005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$numWordsToHold DD 010501H
	DD	07005H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$bitMask DD 020901H
	DD	070051209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$grow DD	020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$growToInclude DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetToIntList DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetIsNil DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetRemove DD 020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetNumBits DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetMember DD 020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetEquals DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetAdd DD 020e01H
	DD	0700a720eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetSize DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetORInPlace DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetOR DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetClone DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetSetAPI DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetLoad DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetCopy DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetList DD 022301H
	DD	07006d20aH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3BitsetList$rtcName$0 DB 06bH
	DB	065H
	DB	079H
	DB	00H
antlr3BitsetList$rtcName$1 DB 062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+8
antlr3BitsetList$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:antlr3BitsetList$rtcName$1
	DD	038H
	DD	08H
	DQ	FLAT:antlr3BitsetList$rtcName$0
	ORG $+96
antlr3BitsetList$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:antlr3BitsetList$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetOf DD 022d01H
	DD	070149218H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
antlr3BitsetOf$rtcName$0 DB 061H
	DB	070H
	DB	00H
	ORG $+13
antlr3BitsetOf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:antlr3BitsetOf$rtcName$0
	ORG $+48
antlr3BitsetOf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:antlr3BitsetOf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3BitsetNew DD 020901H
	DD	070055209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetFree
_TEXT	SEGMENT
bitset$ = 48
antlr3BitsetFree PROC					; COMDAT

; 64   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 65   :     if	(bitset->blist.bits != NULL)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  0000f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00013	74 1a		 je	 SHORT $LN2@antlr3Bits

; 66   :     {
; 67   : 		ANTLR3_FREE(bitset->blist.bits);

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  0001a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 68   : 		bitset->blist.bits = NULL;

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  00028	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@antlr3Bits:

; 69   :     }
; 70   :     ANTLR3_FREE(bitset);

  0002f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitset$[rsp]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 71   : 
; 72   :     return;
; 73   : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
antlr3BitsetFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT wordNumber
_TEXT	SEGMENT
bit$ = 16
wordNumber PROC						; COMDAT

; 627  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi

; 628  :     return  bit >> ANTLR3_BITSET_LOG_BITS;

  00005	8b 44 24 10	 mov	 eax, DWORD PTR bit$[rsp]
  00009	c1 e8 06	 shr	 eax, 6

; 629  : }

  0000c	5f		 pop	 rdi
  0000d	c3		 ret	 0
wordNumber ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT numWordsToHold
_TEXT	SEGMENT
bit$ = 16
numWordsToHold PROC					; COMDAT

; 621  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi

; 622  :     return  (bit >> ANTLR3_BITSET_LOG_BITS) + 1;

  00005	8b 44 24 10	 mov	 eax, DWORD PTR bit$[rsp]
  00009	c1 e8 06	 shr	 eax, 6
  0000c	ff c0		 inc	 eax

; 623  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
numWordsToHold ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT bitMask
_TEXT	SEGMENT
tv69 = 0
bitNumber$ = 32
bitMask	PROC						; COMDAT

; 477  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 10	 sub	 rsp, 16

; 478  :     return  ((ANTLR3_UINT64)1) << (bitNumber & (ANTLR3_BITSET_MOD_MASK));

  00009	8b 44 24 20	 mov	 eax, DWORD PTR bitNumber$[rsp]
  0000d	83 e0 3f	 and	 eax, 63			; 0000003fH
  00010	b9 01 00 00 00	 mov	 ecx, 1
  00015	48 89 0c 24	 mov	 QWORD PTR tv69[rsp], rcx
  00019	0f b6 c8	 movzx	 ecx, al
  0001c	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]
  00020	48 d3 e0	 shl	 rax, cl

; 479  : }

  00023	48 83 c4 10	 add	 rsp, 16
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
bitMask	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT grow
_TEXT	SEGMENT
newBits$ = 32
bitset$ = 64
newSize$ = 72
grow	PROC						; COMDAT

; 395  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 396  :     pANTLR3_BITWORD   newBits;
; 397  : 
; 398  :     // Space for newly sized bitset - TODO: come back to this and use realloc?, it may
; 399  :     // be more efficient...
; 400  :     //
; 401  :     newBits = (pANTLR3_BITWORD) ANTLR3_CALLOC(1, (size_t)(newSize * sizeof(ANTLR3_BITWORD)));

  0000e	48 63 44 24 48	 movsxd	 rax, DWORD PTR newSize$[rsp]
  00013	48 c1 e0 03	 shl	 rax, 3
  00017	48 8b d0	 mov	 rdx, rax
  0001a	b9 01 00 00 00	 mov	 ecx, 1
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00025	48 89 44 24 20	 mov	 QWORD PTR newBits$[rsp], rax

; 402  :     if	(bitset->blist.bits != NULL)

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0002f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00033	74 2f		 je	 SHORT $LN2@grow

; 403  :     {
; 404  : 		// Copy existing bits
; 405  : 		//
; 406  : 		ANTLR3_MEMCPY((void *)newBits, (const void *)bitset->blist.bits, (size_t)(bitset->blist.length * sizeof(ANTLR3_BITWORD)));

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	48 c1 e0 03	 shl	 rax, 3
  00041	4c 8b c0	 mov	 r8, rax
  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00049	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newBits$[rsp]
  00051	e8 00 00 00 00	 call	 memcpy

; 407  : 
; 408  : 		// Out with the old bits... de de de derrr
; 409  : 		//
; 410  : 		ANTLR3_FREE(bitset->blist.bits);

  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0005b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@grow:

; 411  :     }
; 412  : 
; 413  :     // In with the new bits... keerrrang.
; 414  :     //
; 415  :     bitset->blist.bits      = newBits;

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newBits$[rsp]
  0006e	48 89 08	 mov	 QWORD PTR [rax], rcx

; 416  :     bitset->blist.length    = newSize;

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00076	8b 4c 24 48	 mov	 ecx, DWORD PTR newSize$[rsp]
  0007a	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 417  : }

  0007d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
grow	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT growToInclude
_TEXT	SEGMENT
bl$ = 32
nw$ = 36
bitset$ = 64
bit$ = 72
growToInclude PROC					; COMDAT

; 421  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 422  : 	ANTLR3_UINT32	bl;
; 423  : 	ANTLR3_UINT32	nw;
; 424  : 
; 425  : 	bl = (bitset->blist.length << 1);

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00013	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00016	d1 e0		 shl	 eax, 1
  00018	89 44 24 20	 mov	 DWORD PTR bl$[rsp], eax

; 426  : 	nw = numWordsToHold(bit);

  0001c	8b 4c 24 48	 mov	 ecx, DWORD PTR bit$[rsp]
  00020	e8 00 00 00 00	 call	 numWordsToHold
  00025	89 44 24 24	 mov	 DWORD PTR nw$[rsp], eax

; 427  : 
; 428  : 	if	(bl > nw)

  00029	8b 44 24 24	 mov	 eax, DWORD PTR nw$[rsp]
  0002d	39 44 24 20	 cmp	 DWORD PTR bl$[rsp], eax
  00031	76 13		 jbe	 SHORT $LN2@growToIncl

; 429  : 	{
; 430  : 		bitset->grow(bitset, bl);

  00033	8b 54 24 20	 mov	 edx, DWORD PTR bl$[rsp]
  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00041	ff 50 38	 call	 QWORD PTR [rax+56]

; 431  : 	}

  00044	eb 11		 jmp	 SHORT $LN3@growToIncl
$LN2@growToIncl:

; 432  : 	else
; 433  : 	{
; 434  : 		bitset->grow(bitset, nw);

  00046	8b 54 24 24	 mov	 edx, DWORD PTR nw$[rsp]
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  0004f	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00054	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@growToIncl:

; 435  : 	}
; 436  : }

  00057	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005b	5f		 pop	 rdi
  0005c	c3		 ret	 0
growToInclude ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetToIntList
_TEXT	SEGMENT
numInts$ = 32
numBits$ = 36
i$ = 40
index$ = 44
intList$ = 48
bitset$ = 80
antlr3BitsetToIntList PROC				; COMDAT

; 646  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 647  :     ANTLR3_UINT32   numInts;	    // How many integers we will need
; 648  :     ANTLR3_UINT32   numBits;	    // How many bits are in the set
; 649  :     ANTLR3_UINT32   i;
; 650  :     ANTLR3_UINT32   index;
; 651  : 
; 652  :     pANTLR3_INT32  intList;
; 653  : 
; 654  :     numInts = bitset->size(bitset) + 1;

  0000a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00014	ff 50 28	 call	 QWORD PTR [rax+40]
  00017	ff c0		 inc	 eax
  00019	89 44 24 20	 mov	 DWORD PTR numInts$[rsp], eax

; 655  :     numBits = bitset->numBits(bitset);

  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00027	ff 50 50	 call	 QWORD PTR [rax+80]
  0002a	89 44 24 24	 mov	 DWORD PTR numBits$[rsp], eax

; 656  :  
; 657  :     intList = (pANTLR3_INT32)ANTLR3_MALLOC(numInts * sizeof(ANTLR3_INT32));

  0002e	8b 44 24 20	 mov	 eax, DWORD PTR numInts$[rsp]
  00032	48 c1 e0 02	 shl	 rax, 2
  00036	48 8b c8	 mov	 rcx, rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 89 44 24 30	 mov	 QWORD PTR intList$[rsp], rax

; 658  : 
; 659  :     if	(intList == NULL)

  00044	48 83 7c 24 30
	00		 cmp	 QWORD PTR intList$[rsp], 0
  0004a	75 04		 jne	 SHORT $LN5@antlr3Bits

; 660  :     {
; 661  : 		return NULL;	// Out of memory

  0004c	33 c0		 xor	 eax, eax
  0004e	eb 75		 jmp	 SHORT $LN1@antlr3Bits
$LN5@antlr3Bits:

; 662  :     }
; 663  : 
; 664  :     intList[0] = numInts;

  00050	b8 04 00 00 00	 mov	 eax, 4
  00055	48 6b c0 00	 imul	 rax, rax, 0
  00059	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intList$[rsp]
  0005e	8b 54 24 20	 mov	 edx, DWORD PTR numInts$[rsp]
  00062	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 665  : 
; 666  :     // Enumerate the bits that are turned on
; 667  :     //
; 668  :     for	(i = 0, index = 1; i<numBits; i++)

  00065	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006d	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR index$[rsp], 1
  00075	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  00077	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  0007b	ff c0		 inc	 eax
  0007d	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00081	8b 44 24 24	 mov	 eax, DWORD PTR numBits$[rsp]
  00085	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00089	73 35		 jae	 SHORT $LN3@antlr3Bits

; 669  :     {
; 670  : 		if  (bitset->isMember(bitset, i) == ANTLR3_TRUE)

  0008b	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00099	ff 50 48	 call	 QWORD PTR [rax+72]
  0009c	0f b6 c0	 movzx	 eax, al
  0009f	83 f8 01	 cmp	 eax, 1
  000a2	75 1a		 jne	 SHORT $LN6@antlr3Bits

; 671  : 		{
; 672  : 			intList[index++]    = i;

  000a4	8b 44 24 2c	 mov	 eax, DWORD PTR index$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR intList$[rsp]
  000ad	8b 54 24 28	 mov	 edx, DWORD PTR i$[rsp]
  000b1	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
  000b4	8b 44 24 2c	 mov	 eax, DWORD PTR index$[rsp]
  000b8	ff c0		 inc	 eax
  000ba	89 44 24 2c	 mov	 DWORD PTR index$[rsp], eax
$LN6@antlr3Bits:

; 673  : 		}
; 674  :     }

  000be	eb b7		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 675  : 
; 676  :     // Result set
; 677  :     //
; 678  :     return  intList;

  000c0	48 8b 44 24 30	 mov	 rax, QWORD PTR intList$[rsp]
$LN1@antlr3Bits:

; 679  : }

  000c5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
antlr3BitsetToIntList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetIsNil
_TEXT	SEGMENT
i$ = 0
bitset$ = 32
antlr3BitsetIsNil PROC					; COMDAT

; 605  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 606  :    ANTLR3_INT32    i;
; 607  : 
; 608  :    for	(i = bitset->blist.length -1; i>= 0; i--)

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	ff c8		 dec	 eax
  00014	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  00017	eb 08		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  00019	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001c	ff c8		 dec	 eax
  0001e	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00021	83 3c 24 00	 cmp	 DWORD PTR i$[rsp], 0
  00025	7c 19		 jl	 SHORT $LN3@antlr3Bits

; 609  :    {
; 610  :        if   (bitset->blist.bits[i] != 0)

  00027	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0002b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00030	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00033	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00038	74 04		 je	 SHORT $LN5@antlr3Bits

; 611  :        {
; 612  : 			return ANTLR3_FALSE;

  0003a	32 c0		 xor	 al, al
  0003c	eb 04		 jmp	 SHORT $LN1@antlr3Bits
$LN5@antlr3Bits:

; 613  :        }
; 614  :    }

  0003e	eb d9		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 615  :    
; 616  :    return   ANTLR3_TRUE;

  00040	b0 01		 mov	 al, 1
$LN1@antlr3Bits:

; 617  : }

  00042	48 83 c4 10	 add	 rsp, 16
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
antlr3BitsetIsNil ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetRemove
_TEXT	SEGMENT
wordNo$ = 32
tv69 = 40
tv81 = 48
bitset$ = 80
bit$ = 88
antlr3BitsetRemove PROC					; COMDAT

; 593  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 594  :     ANTLR3_UINT32    wordNo;
; 595  : 
; 596  :     wordNo  = wordNumber(bit);

  0000e	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00012	e8 00 00 00 00	 call	 wordNumber
  00017	89 44 24 20	 mov	 DWORD PTR wordNo$[rsp], eax

; 597  : 
; 598  :     if	(wordNo < bitset->blist.length)

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00020	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00023	39 44 24 20	 cmp	 DWORD PTR wordNo$[rsp], eax
  00027	73 46		 jae	 SHORT $LN2@antlr3Bits

; 599  :     {
; 600  : 		bitset->blist.bits[wordNo] &= ~(bitMask(bit));

  00029	8b 44 24 20	 mov	 eax, DWORD PTR wordNo$[rsp]
  0002d	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00032	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00037	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003a	48 89 4c 24 30	 mov	 QWORD PTR tv81[rsp], rcx
  0003f	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00043	e8 00 00 00 00	 call	 bitMask
  00048	48 f7 d0	 not	 rax
  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00050	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv69[rsp]
  00055	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00059	48 23 c8	 and	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	8b 4c 24 20	 mov	 ecx, DWORD PTR wordNo$[rsp]
  00063	48 8b 54 24 50	 mov	 rdx, QWORD PTR bitset$[rsp]
  00068	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0006b	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN2@antlr3Bits:

; 601  :     }
; 602  : }

  0006f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
antlr3BitsetRemove ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetNumBits
_TEXT	SEGMENT
bitset$ = 16
antlr3BitsetNumBits PROC				; COMDAT

; 633  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 634  :     return  bitset->blist.length << ANTLR3_BITSET_LOG_BITS;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0000e	c1 e0 06	 shl	 eax, 6

; 635  : }

  00011	5f		 pop	 rdi
  00012	c3		 ret	 0
antlr3BitsetNumBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetMember
_TEXT	SEGMENT
wordNo$ = 32
tv69 = 40
tv76 = 48
bitset$ = 80
bit$ = 88
antlr3BitsetMember PROC					; COMDAT

; 571  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 572  :     ANTLR3_UINT32    wordNo;
; 573  : 
; 574  :     wordNo  = wordNumber(bit);

  0000e	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00012	e8 00 00 00 00	 call	 wordNumber
  00017	89 44 24 20	 mov	 DWORD PTR wordNo$[rsp], eax

; 575  : 
; 576  :     if	(wordNo >= bitset->blist.length)

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00020	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00023	39 44 24 20	 cmp	 DWORD PTR wordNo$[rsp], eax
  00027	72 04		 jb	 SHORT $LN2@antlr3Bits

; 577  :     {
; 578  : 		return	ANTLR3_FALSE;

  00029	32 c0		 xor	 al, al
  0002b	eb 40		 jmp	 SHORT $LN1@antlr3Bits
$LN2@antlr3Bits:

; 579  :     }
; 580  :     
; 581  :     if	((bitset->blist.bits[wordNo] & bitMask(bit)) == 0)

  0002d	8b 44 24 20	 mov	 eax, DWORD PTR wordNo$[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR tv69[rsp], rax
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  0003b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003e	48 89 4c 24 30	 mov	 QWORD PTR tv76[rsp], rcx
  00043	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00047	e8 00 00 00 00	 call	 bitMask
  0004c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv76[rsp]
  00051	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv69[rsp]
  00056	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0005a	48 23 c8	 and	 rcx, rax
  0005d	48 8b c1	 mov	 rax, rcx
  00060	48 85 c0	 test	 rax, rax
  00063	75 06		 jne	 SHORT $LN3@antlr3Bits

; 582  :     {
; 583  : 		return	ANTLR3_FALSE;

  00065	32 c0		 xor	 al, al
  00067	eb 04		 jmp	 SHORT $LN1@antlr3Bits

; 584  :     }

  00069	eb 02		 jmp	 SHORT $LN4@antlr3Bits
$LN3@antlr3Bits:

; 585  :     else
; 586  :     {
; 587  : 		return	ANTLR3_TRUE;

  0006b	b0 01		 mov	 al, 1
$LN4@antlr3Bits:
$LN1@antlr3Bits:

; 588  :     }
; 589  : }

  0006d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
antlr3BitsetMember ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetEquals
_TEXT	SEGMENT
minimum$ = 0
i$ = 4
bitset1$ = 32
bitset2$ = 40
antlr3BitsetEquals PROC					; COMDAT

; 512  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 513  :     ANTLR3_INT32   minimum;
; 514  :     ANTLR3_INT32   i;
; 515  : 
; 516  :     if	(bitset1 == NULL || bitset2 == NULL)

  0000f	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset1$[rsp], 0
  00015	74 08		 je	 SHORT $LN12@antlr3Bits
  00017	48 83 7c 24 28
	00		 cmp	 QWORD PTR bitset2$[rsp], 0
  0001d	75 07		 jne	 SHORT $LN11@antlr3Bits
$LN12@antlr3Bits:

; 517  :     {
; 518  : 	return	ANTLR3_FALSE;

  0001f	32 c0		 xor	 al, al
  00021	e9 07 01 00 00	 jmp	 $LN1@antlr3Bits
$LN11@antlr3Bits:

; 519  :     }
; 520  : 
; 521  :     // Work out the minimum comparison set
; 522  :     //
; 523  :     if	(bitset1->blist.length < bitset2->blist.length)

  00026	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  0002b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bitset2$[rsp]
  00030	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00033	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00036	73 0d		 jae	 SHORT $LN13@antlr3Bits

; 524  :     {
; 525  : 		minimum = bitset1->blist.length;

  00038	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  0003d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00040	89 04 24	 mov	 DWORD PTR minimum$[rsp], eax

; 526  :     }

  00043	eb 0b		 jmp	 SHORT $LN14@antlr3Bits
$LN13@antlr3Bits:

; 527  :     else
; 528  :     {
; 529  : 		minimum = bitset2->blist.length;

  00045	48 8b 44 24 28	 mov	 rax, QWORD PTR bitset2$[rsp]
  0004a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004d	89 04 24	 mov	 DWORD PTR minimum$[rsp], eax
$LN14@antlr3Bits:

; 530  :     }
; 531  : 
; 532  :     // Make sure explict in common bits are equal
; 533  :     //
; 534  :     for	(i = minimum - 1; i >=0 ; i--)

  00050	8b 04 24	 mov	 eax, DWORD PTR minimum$[rsp]
  00053	ff c8		 dec	 eax
  00055	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  00059	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  0005b	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  0005f	ff c8		 dec	 eax
  00061	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00065	83 7c 24 04 00	 cmp	 DWORD PTR i$[rsp], 0
  0006a	7c 2d		 jl	 SHORT $LN3@antlr3Bits

; 535  :     {
; 536  : 		if  (bitset1->blist.bits[i] != bitset2->blist.bits[i])

  0006c	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00071	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset1$[rsp]
  00076	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00079	48 63 54 24 04	 movsxd	 rdx, DWORD PTR i$[rsp]
  0007e	4c 8b 44 24 28	 mov	 r8, QWORD PTR bitset2$[rsp]
  00083	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00086	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  0008a	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  0008e	74 07		 je	 SHORT $LN15@antlr3Bits

; 537  : 		{
; 538  : 			return  ANTLR3_FALSE;

  00090	32 c0		 xor	 al, al
  00092	e9 96 00 00 00	 jmp	 $LN1@antlr3Bits
$LN15@antlr3Bits:

; 539  : 		}
; 540  :     }

  00097	eb c2		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 541  : 
; 542  :     // Now make sure the bits of the larger set are all turned
; 543  :     // off.
; 544  :     //
; 545  :     if	(bitset1->blist.length > (ANTLR3_UINT32)minimum)

  00099	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  0009e	8b 0c 24	 mov	 ecx, DWORD PTR minimum$[rsp]
  000a1	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  000a4	76 3d		 jbe	 SHORT $LN16@antlr3Bits

; 546  :     {
; 547  : 		for (i = minimum ; (ANTLR3_UINT32)i < bitset1->blist.length; i++)

  000a6	8b 04 24	 mov	 eax, DWORD PTR minimum$[rsp]
  000a9	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  000ad	eb 0a		 jmp	 SHORT $LN7@antlr3Bits
$LN5@antlr3Bits:
  000af	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  000b3	ff c0		 inc	 eax
  000b5	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN7@antlr3Bits:
  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset1$[rsp]
  000be	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c1	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  000c5	73 1a		 jae	 SHORT $LN6@antlr3Bits

; 548  : 		{
; 549  : 			if	(bitset1->blist.bits[i] != 0)

  000c7	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset1$[rsp]
  000d1	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000d4	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000d9	74 04		 je	 SHORT $LN18@antlr3Bits

; 550  : 			{
; 551  : 				return	ANTLR3_FALSE;

  000db	32 c0		 xor	 al, al
  000dd	eb 4e		 jmp	 SHORT $LN1@antlr3Bits
$LN18@antlr3Bits:

; 552  : 			}
; 553  : 		}

  000df	eb ce		 jmp	 SHORT $LN5@antlr3Bits
$LN6@antlr3Bits:

; 554  :     }

  000e1	eb 48		 jmp	 SHORT $LN17@antlr3Bits
$LN16@antlr3Bits:

; 555  :     else if (bitset2->blist.length > (ANTLR3_UINT32)minimum)

  000e3	48 8b 44 24 28	 mov	 rax, QWORD PTR bitset2$[rsp]
  000e8	8b 0c 24	 mov	 ecx, DWORD PTR minimum$[rsp]
  000eb	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  000ee	76 3b		 jbe	 SHORT $LN19@antlr3Bits

; 556  :     {
; 557  : 		for (i = minimum; (ANTLR3_UINT32)i < bitset2->blist.length; i++)

  000f0	8b 04 24	 mov	 eax, DWORD PTR minimum$[rsp]
  000f3	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  000f7	eb 0a		 jmp	 SHORT $LN10@antlr3Bits
$LN8@antlr3Bits:
  000f9	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  000fd	ff c0		 inc	 eax
  000ff	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN10@antlr3Bits:
  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR bitset2$[rsp]
  00108	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0010b	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  0010f	73 1a		 jae	 SHORT $LN9@antlr3Bits

; 558  : 		{
; 559  : 			if	(bitset2->blist.bits[i] != 0)

  00111	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00116	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bitset2$[rsp]
  0011b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0011e	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00123	74 04		 je	 SHORT $LN20@antlr3Bits

; 560  : 			{
; 561  : 				return	ANTLR3_FALSE;

  00125	32 c0		 xor	 al, al
  00127	eb 04		 jmp	 SHORT $LN1@antlr3Bits
$LN20@antlr3Bits:

; 562  : 			}
; 563  : 		}

  00129	eb ce		 jmp	 SHORT $LN8@antlr3Bits
$LN9@antlr3Bits:
$LN19@antlr3Bits:
$LN17@antlr3Bits:

; 564  :     }
; 565  : 
; 566  :     return  ANTLR3_TRUE;

  0012b	b0 01		 mov	 al, 1
$LN1@antlr3Bits:

; 567  : }

  0012d	48 83 c4 10	 add	 rsp, 16
  00131	5f		 pop	 rdi
  00132	c3		 ret	 0
antlr3BitsetEquals ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetAdd
_TEXT	SEGMENT
word$ = 32
tv71 = 40
tv82 = 48
bitset$ = 80
bit$ = 88
antlr3BitsetAdd PROC					; COMDAT

; 379  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 380  :     ANTLR3_UINT32   word;
; 381  : 
; 382  :     word    = wordNumber(bit);

  0000e	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00012	e8 00 00 00 00	 call	 wordNumber
  00017	89 44 24 20	 mov	 DWORD PTR word$[rsp], eax

; 383  : 
; 384  :     if	(word	>= bitset->blist.length)

  0001b	48 8b 44 24 50	 mov	 rax, QWORD PTR bitset$[rsp]
  00020	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00023	39 44 24 20	 cmp	 DWORD PTR word$[rsp], eax
  00027	72 0e		 jb	 SHORT $LN2@antlr3Bits

; 385  :     {
; 386  : 		growToInclude(bitset, bit);

  00029	8b 54 24 58	 mov	 edx, DWORD PTR bit$[rsp]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00032	e8 00 00 00 00	 call	 growToInclude
$LN2@antlr3Bits:

; 387  :     }
; 388  : 
; 389  :     bitset->blist.bits[word] |= bitMask(bit);

  00037	8b 44 24 20	 mov	 eax, DWORD PTR word$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR tv71[rsp], rax
  00040	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bitset$[rsp]
  00045	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00048	48 89 4c 24 30	 mov	 QWORD PTR tv82[rsp], rcx
  0004d	8b 4c 24 58	 mov	 ecx, DWORD PTR bit$[rsp]
  00051	e8 00 00 00 00	 call	 bitMask
  00056	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv82[rsp]
  0005b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv71[rsp]
  00060	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00064	48 0b c8	 or	 rcx, rax
  00067	48 8b c1	 mov	 rax, rcx
  0006a	8b 4c 24 20	 mov	 ecx, DWORD PTR word$[rsp]
  0006e	48 8b 54 24 50	 mov	 rdx, QWORD PTR bitset$[rsp]
  00073	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00076	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 390  : 
; 391  : }

  0007a	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0007e	5f		 pop	 rdi
  0007f	c3		 ret	 0
antlr3BitsetAdd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetSize
_TEXT	SEGMENT
degree$ = 0
i$ = 4
bit$ = 8
tv85 = 16
bitset$ = 48
antlr3BitsetSize PROC					; COMDAT

; 483  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 484  :     ANTLR3_UINT32   degree;
; 485  :     ANTLR3_INT32   i;
; 486  :     ANTLR3_INT8    bit;
; 487  :     
; 488  :     // TODO: Come back to this, it may be faster to & with 0x01
; 489  :     // then shift right a copy of the 4 bits, than shift left a constant of 1.
; 490  :     // But then again, the optimizer might just work this out
; 491  :     // anyway.
; 492  :     //
; 493  :     degree  = 0;

  0000a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR degree$[rsp], 0

; 494  :     for	(i = bitset->blist.length - 1; i>= 0; i--)

  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR bitset$[rsp]
  00016	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00019	ff c8		 dec	 eax
  0001b	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
  0001f	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  00021	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00025	ff c8		 dec	 eax
  00027	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  0002b	83 7c 24 04 00	 cmp	 DWORD PTR i$[rsp], 0
  00030	7c 78		 jl	 SHORT $LN3@antlr3Bits

; 495  :     {
; 496  : 		if  (bitset->blist.bits[i] != 0)

  00032	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitset$[rsp]
  0003c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003f	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00044	74 5f		 je	 SHORT $LN8@antlr3Bits

; 497  : 		{
; 498  : 			for	(bit = ANTLR3_BITSET_BITS - 1; bit >= 0; bit--)

  00046	c6 44 24 08 3f	 mov	 BYTE PTR bit$[rsp], 63	; 0000003fH
  0004b	eb 0b		 jmp	 SHORT $LN7@antlr3Bits
$LN5@antlr3Bits:
  0004d	0f b6 44 24 08	 movzx	 eax, BYTE PTR bit$[rsp]
  00052	fe c8		 dec	 al
  00054	88 44 24 08	 mov	 BYTE PTR bit$[rsp], al
$LN7@antlr3Bits:
  00058	0f be 44 24 08	 movsx	 eax, BYTE PTR bit$[rsp]
  0005d	85 c0		 test	 eax, eax
  0005f	7c 44		 jl	 SHORT $LN6@antlr3Bits

; 499  : 			{
; 500  : 				if  ((bitset->blist.bits[i] & (((ANTLR3_BITWORD)1) << bit)) != 0)

  00061	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitset$[rsp]
  0006b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006e	48 89 4c 24 10	 mov	 QWORD PTR tv85[rsp], rcx
  00073	0f be 54 24 08	 movsx	 edx, BYTE PTR bit$[rsp]
  00078	41 b8 01 00 00
	00		 mov	 r8d, 1
  0007e	0f b6 ca	 movzx	 ecx, dl
  00081	41 8b d0	 mov	 edx, r8d
  00084	48 d3 e2	 shl	 rdx, cl
  00087	48 8b ca	 mov	 rcx, rdx
  0008a	48 8b 54 24 10	 mov	 rdx, QWORD PTR tv85[rsp]
  0008f	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00093	48 23 c1	 and	 rax, rcx
  00096	48 85 c0	 test	 rax, rax
  00099	74 08		 je	 SHORT $LN9@antlr3Bits

; 501  : 				{
; 502  : 					degree++;

  0009b	8b 04 24	 mov	 eax, DWORD PTR degree$[rsp]
  0009e	ff c0		 inc	 eax
  000a0	89 04 24	 mov	 DWORD PTR degree$[rsp], eax
$LN9@antlr3Bits:

; 503  : 				}
; 504  : 			}

  000a3	eb a8		 jmp	 SHORT $LN5@antlr3Bits
$LN6@antlr3Bits:
$LN8@antlr3Bits:

; 505  : 		}
; 506  :     }

  000a5	e9 77 ff ff ff	 jmp	 $LN2@antlr3Bits
$LN3@antlr3Bits:

; 507  :     return degree;

  000aa	8b 04 24	 mov	 eax, DWORD PTR degree$[rsp]

; 508  : }

  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
antlr3BitsetSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetORInPlace
_TEXT	SEGMENT
minimum$ = 32
i$ = 36
bitset$ = 64
bitset2$ = 72
antlr3BitsetORInPlace PROC				; COMDAT

; 440  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 441  :     ANTLR3_UINT32   minimum;
; 442  :     ANTLR3_UINT32   i;
; 443  : 
; 444  :     if	(bitset2 == NULL)

  0000f	48 83 7c 24 48
	00		 cmp	 QWORD PTR bitset2$[rsp], 0
  00015	75 05		 jne	 SHORT $LN5@antlr3Bits

; 445  :     {
; 446  : 		return;

  00017	e9 b2 00 00 00	 jmp	 $LN1@antlr3Bits
$LN5@antlr3Bits:

; 447  :     }
; 448  : 
; 449  : 
; 450  :     // First make sure that the target bitset is big enough
; 451  :     // for the new bits to be ored in.
; 452  :     //
; 453  :     if	(bitset->blist.length < bitset2->blist.length)

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  00021	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bitset2$[rsp]
  00026	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00029	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0002c	73 18		 jae	 SHORT $LN6@antlr3Bits

; 454  :     {
; 455  : 		growToInclude(bitset, (bitset2->blist.length * sizeof(ANTLR3_BITWORD)));

  0002e	48 8b 44 24 48	 mov	 rax, QWORD PTR bitset2$[rsp]
  00033	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00036	48 c1 e0 03	 shl	 rax, 3
  0003a	8b d0		 mov	 edx, eax
  0003c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  00041	e8 00 00 00 00	 call	 growToInclude
$LN6@antlr3Bits:

; 456  :     }
; 457  :     
; 458  :     // Or the miniimum number of bits after any resizing went on
; 459  :     //
; 460  :     if	(bitset->blist.length < bitset2->blist.length)

  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0004b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bitset2$[rsp]
  00050	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00053	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00056	73 0e		 jae	 SHORT $LN7@antlr3Bits

; 461  : 	{
; 462  : 		minimum = bitset->blist.length;

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR bitset$[rsp]
  0005d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00060	89 44 24 20	 mov	 DWORD PTR minimum$[rsp], eax

; 463  : 	}

  00064	eb 0c		 jmp	 SHORT $LN8@antlr3Bits
$LN7@antlr3Bits:

; 464  : 	else
; 465  : 	{
; 466  : 		minimum = bitset2->blist.length;

  00066	48 8b 44 24 48	 mov	 rax, QWORD PTR bitset2$[rsp]
  0006b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0006e	89 44 24 20	 mov	 DWORD PTR minimum$[rsp], eax
$LN8@antlr3Bits:

; 467  : 	}
; 468  : 
; 469  :     for	(i = minimum; i > 0; i--)

  00072	8b 44 24 20	 mov	 eax, DWORD PTR minimum$[rsp]
  00076	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  0007a	eb 0a		 jmp	 SHORT $LN4@antlr3Bits
$LN2@antlr3Bits:
  0007c	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00080	ff c8		 dec	 eax
  00082	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@antlr3Bits:
  00086	83 7c 24 24 00	 cmp	 DWORD PTR i$[rsp], 0
  0008b	76 41		 jbe	 SHORT $LN3@antlr3Bits

; 470  :     {
; 471  : 		bitset->blist.bits[i-1] |= bitset2->blist.bits[i-1];

  0008d	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00091	ff c8		 dec	 eax
  00093	8b c0		 mov	 eax, eax
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset$[rsp]
  0009a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009d	8b 54 24 24	 mov	 edx, DWORD PTR i$[rsp]
  000a1	ff ca		 dec	 edx
  000a3	8b d2		 mov	 edx, edx
  000a5	4c 8b 44 24 48	 mov	 r8, QWORD PTR bitset2$[rsp]
  000aa	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  000ad	49 8b 14 d0	 mov	 rdx, QWORD PTR [r8+rdx*8]
  000b1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000b5	48 0b c2	 or	 rax, rdx
  000b8	8b 4c 24 24	 mov	 ecx, DWORD PTR i$[rsp]
  000bc	ff c9		 dec	 ecx
  000be	8b c9		 mov	 ecx, ecx
  000c0	48 8b 54 24 40	 mov	 rdx, QWORD PTR bitset$[rsp]
  000c5	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000c8	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 472  :     }

  000cc	eb ae		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:
$LN1@antlr3Bits:

; 473  : }

  000ce	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
antlr3BitsetORInPlace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetOR
_TEXT	SEGMENT
bitset$ = 32
bitset1$ = 64
bitset2$ = 72
antlr3BitsetOR PROC					; COMDAT

; 354  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 355  :     pANTLR3_BITSET  bitset;
; 356  : 
; 357  :     if	(bitset1 == NULL)

  0000f	48 83 7c 24 40
	00		 cmp	 QWORD PTR bitset1$[rsp], 0
  00015	75 0c		 jne	 SHORT $LN2@antlr3Bits

; 358  :     {
; 359  : 		return antlr3BitsetClone(bitset2);

  00017	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bitset2$[rsp]
  0001c	e8 00 00 00 00	 call	 antlr3BitsetClone
  00021	eb 37		 jmp	 SHORT $LN1@antlr3Bits
$LN2@antlr3Bits:

; 360  :     }
; 361  : 
; 362  :     if	(bitset2 == NULL)

  00023	48 83 7c 24 48
	00		 cmp	 QWORD PTR bitset2$[rsp], 0
  00029	75 0c		 jne	 SHORT $LN3@antlr3Bits

; 363  :     {
; 364  : 		return	antlr3BitsetClone(bitset1);

  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset1$[rsp]
  00030	e8 00 00 00 00	 call	 antlr3BitsetClone
  00035	eb 23		 jmp	 SHORT $LN1@antlr3Bits
$LN3@antlr3Bits:

; 365  :     }
; 366  : 
; 367  :     // Allocate memory for the newly ordered bitset structure itself.
; 368  :     //
; 369  :     bitset  = antlr3BitsetClone(bitset1);

  00037	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bitset1$[rsp]
  0003c	e8 00 00 00 00	 call	 antlr3BitsetClone
  00041	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 370  :     
; 371  :     antlr3BitsetORInPlace(bitset, bitset2);

  00046	48 8b 54 24 48	 mov	 rdx, QWORD PTR bitset2$[rsp]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00050	e8 00 00 00 00	 call	 antlr3BitsetORInPlace

; 372  : 
; 373  :     return  bitset;

  00055	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 374  : 
; 375  : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
antlr3BitsetOR ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetClone
_TEXT	SEGMENT
bitset$ = 32
inSet$ = 64
antlr3BitsetClone PROC					; COMDAT

; 184  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 185  :     pANTLR3_BITSET  bitset;
; 186  : 
; 187  :     // Allocate memory for the bitset structure itself
; 188  :     //
; 189  :     bitset  = antlr3BitsetNew(ANTLR3_BITSET_BITS * inSet->blist.length);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR inSet$[rsp]
  0000f	6b 40 08 40	 imul	 eax, DWORD PTR [rax+8], 64 ; 00000040H
  00013	8b c8		 mov	 ecx, eax
  00015	e8 00 00 00 00	 call	 antlr3BitsetNew
  0001a	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 190  : 
; 191  :     if	(bitset == NULL)

  0001f	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  00025	75 04		 jne	 SHORT $LN2@antlr3Bits

; 192  :     {
; 193  : 		return	NULL;

  00027	33 c0		 xor	 eax, eax
  00029	eb 29		 jmp	 SHORT $LN1@antlr3Bits
$LN2@antlr3Bits:

; 194  :     }
; 195  : 
; 196  :     // Install the actual bits in the source set
; 197  :     //
; 198  :     ANTLR3_MEMCPY(bitset->blist.bits, inSet->blist.bits, (ANTLR3_UINT64)(inSet->blist.length * sizeof(ANTLR3_BITWORD)));

  0002b	48 8b 44 24 40	 mov	 rax, QWORD PTR inSet$[rsp]
  00030	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00033	48 c1 e0 03	 shl	 rax, 3
  00037	4c 8b c0	 mov	 r8, rax
  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR inSet$[rsp]
  0003f	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00047	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004a	e8 00 00 00 00	 call	 memcpy

; 199  : 
; 200  :     // All seems good
; 201  :     //
; 202  :     return  bitset;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 203  : }

  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5f		 pop	 rdi
  00059	c3		 ret	 0
antlr3BitsetClone ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetSetAPI
_TEXT	SEGMENT
bitset$ = 16
antlr3BitsetSetAPI PROC					; COMDAT

; 122  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 123  :     bitset->clone		=    antlr3BitsetClone;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetClone
  00012	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 124  :     bitset->bor			=    antlr3BitsetOR;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetOR
  00022	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 125  :     bitset->borInPlace	=    antlr3BitsetORInPlace;

  00026	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetORInPlace
  00032	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 126  :     bitset->size		=    antlr3BitsetSize;

  00036	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetSize
  00042	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 127  :     bitset->add			=    antlr3BitsetAdd;

  00046	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetAdd
  00052	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 128  :     bitset->grow		=    grow;

  00056	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0005b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:grow
  00062	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 129  :     bitset->equals		=    antlr3BitsetEquals;

  00066	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetEquals
  00072	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 130  :     bitset->isMember	=    antlr3BitsetMember;

  00076	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetMember
  00082	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 131  :     bitset->numBits		=    antlr3BitsetNumBits;

  00086	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetNumBits
  00092	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 132  :     bitset->remove		=    antlr3BitsetRemove;

  00096	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetRemove
  000a2	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 133  :     bitset->isNilNode		=    antlr3BitsetIsNil;

  000a6	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetIsNil
  000b2	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 134  :     bitset->toIntList	=    antlr3BitsetToIntList;

  000b6	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetToIntList
  000c2	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 135  : 
; 136  :     bitset->free		=    antlr3BitsetFree;

  000c6	48 8b 44 24 10	 mov	 rax, QWORD PTR bitset$[rsp]
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3BitsetFree
  000d2	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 137  : }

  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
antlr3BitsetSetAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetLoad
_TEXT	SEGMENT
bitset$ = 32
count$ = 40
inBits$ = 64
antlr3BitsetLoad PROC					; COMDAT

; 254  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 255  : 	pANTLR3_BITSET  bitset;
; 256  : 	ANTLR3_UINT32  count;
; 257  : 
; 258  : 	// Allocate memory for the bitset structure itself
; 259  : 	// the input parameter is the bit number (0 based)
; 260  : 	// to include in the bitset, so we need at at least
; 261  : 	// bit + 1 bits. If any arguments indicate a 
; 262  : 	// a bit higher than the default number of bits (0 means default size)
; 263  : 	// then Add() will take care
; 264  : 	// of it.
; 265  : 	//
; 266  : 	bitset  = antlr3BitsetNew(0);

  0000a	33 c9		 xor	 ecx, ecx
  0000c	e8 00 00 00 00	 call	 antlr3BitsetNew
  00011	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 267  : 
; 268  : 	if	(bitset == NULL)

  00016	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  0001c	75 04		 jne	 SHORT $LN4@antlr3Bits

; 269  : 	{
; 270  : 		return	NULL;

  0001e	33 c0		 xor	 eax, eax
  00020	eb 72		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 271  : 	}
; 272  : 
; 273  : 	if	(inBits != NULL)

  00022	48 83 7c 24 40
	00		 cmp	 QWORD PTR inBits$[rsp], 0
  00028	74 65		 je	 SHORT $LN5@antlr3Bits

; 274  : 	{
; 275  : 		// Now we can add the element bits into the set
; 276  : 		//
; 277  : 		count=0;

  0002a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@antlr3Bits:

; 278  : 		while (count < inBits->length)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR inBits$[rsp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	39 44 24 28	 cmp	 DWORD PTR count$[rsp], eax
  0003e	73 4f		 jae	 SHORT $LN3@antlr3Bits

; 279  : 		{
; 280  : 			if  (bitset->blist.length <= count)

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00045	8b 4c 24 28	 mov	 ecx, DWORD PTR count$[rsp]
  00049	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0004c	77 15		 ja	 SHORT $LN6@antlr3Bits

; 281  : 			{
; 282  : 				bitset->grow(bitset, count+1);

  0004e	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  00052	ff c0		 inc	 eax
  00054	8b d0		 mov	 edx, eax
  00056	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00060	ff 50 38	 call	 QWORD PTR [rax+56]
$LN6@antlr3Bits:

; 283  : 			}
; 284  : 
; 285  : 			bitset->blist.bits[count] = *((inBits->bits)+count);

  00063	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inBits$[rsp]
  0006c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0006f	8b 54 24 28	 mov	 edx, DWORD PTR count$[rsp]
  00073	4c 8b 44 24 20	 mov	 r8, QWORD PTR bitset$[rsp]
  00078	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0007b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007f	49 89 04 d0	 mov	 QWORD PTR [r8+rdx*8], rax

; 286  : 			count++;

  00083	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  00087	ff c0		 inc	 eax
  00089	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax

; 287  : 		}

  0008d	eb a3		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:
$LN5@antlr3Bits:

; 288  : 	}
; 289  : 
; 290  : 	// return the new bitset
; 291  : 	//
; 292  : 	return  bitset;

  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 293  : }

  00094	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00098	5f		 pop	 rdi
  00099	c3		 ret	 0
antlr3BitsetLoad ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetCopy
_TEXT	SEGMENT
bitset$ = 32
numElements$ = 40
blist$ = 64
antlr3BitsetCopy PROC					; COMDAT

; 141  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 142  :     pANTLR3_BITSET  bitset;
; 143  : 	int				numElements;
; 144  : 
; 145  :     // Allocate memory for the bitset structure itself
; 146  :     //
; 147  :     bitset  = (pANTLR3_BITSET) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BITSET));

  0000a	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 148  : 
; 149  :     if	(bitset == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@antlr3Bits

; 150  :     {
; 151  : 		return	NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 81 00 00 00	 jmp	 $LN1@antlr3Bits
$LN2@antlr3Bits:

; 152  :     }
; 153  : 
; 154  : 	numElements = blist->length;

  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR blist$[rsp]
  0002e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00031	89 44 24 28	 mov	 DWORD PTR numElements$[rsp], eax

; 155  : 
; 156  :     // Avoid memory thrashing at the expense of a few more bytes
; 157  :     //
; 158  :     if	(numElements < 8)

  00035	83 7c 24 28 08	 cmp	 DWORD PTR numElements$[rsp], 8
  0003a	7d 08		 jge	 SHORT $LN3@antlr3Bits

; 159  :     {
; 160  : 		numElements = 8;

  0003c	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR numElements$[rsp], 8
$LN3@antlr3Bits:

; 161  :     }
; 162  : 
; 163  :     // Install the length in ANTLR3_UINT64 units
; 164  :     //
; 165  :     bitset->blist.length  = numElements;

  00044	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00049	8b 4c 24 28	 mov	 ecx, DWORD PTR numElements$[rsp]
  0004d	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 166  : 
; 167  :     bitset->blist.bits    = (pANTLR3_BITWORD)ANTLR3_MALLOC((size_t)(numElements * sizeof(ANTLR3_BITWORD)));

  00050	48 63 44 24 28	 movsxd	 rax, DWORD PTR numElements$[rsp]
  00055	48 c1 e0 03	 shl	 rax, 3
  00059	48 8b c8	 mov	 rcx, rax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00067	48 89 01	 mov	 QWORD PTR [rcx], rax

; 168  : 
; 169  :     if	(bitset->blist.bits == NULL)

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0006f	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00073	75 0f		 jne	 SHORT $LN4@antlr3Bits

; 170  :     {
; 171  : 		ANTLR3_FREE(bitset);

  00075	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 172  : 		return	NULL;

  00080	33 c0		 xor	 eax, eax
  00082	eb 26		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 173  :     }
; 174  : 
; 175  : 	ANTLR3_MEMCPY(bitset->blist.bits, blist->bits, (ANTLR3_UINT64)(numElements * sizeof(ANTLR3_BITWORD)));

  00084	48 63 44 24 28	 movsxd	 rax, DWORD PTR numElements$[rsp]
  00089	48 c1 e0 03	 shl	 rax, 3
  0008d	4c 8b c0	 mov	 r8, rax
  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR blist$[rsp]
  00095	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00098	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0009d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000a0	e8 00 00 00 00	 call	 memcpy

; 176  : 
; 177  :     // All seems good
; 178  :     //
; 179  :     return  bitset;

  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 180  : }

  000aa	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ae	5f		 pop	 rdi
  000af	c3		 ret	 0
antlr3BitsetCopy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetList
_TEXT	SEGMENT
bitSet$ = 32
en$ = 40
key$ = 56
bit$ = 88
list$ = 128
antlr3BitsetList PROC					; COMDAT

; 208  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0000f	b9 14 00 00 00	 mov	 ecx, 20
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]

; 209  :     pANTLR3_BITSET		bitSet;
; 210  :     pANTLR3_HASH_ENUM	en;
; 211  :     pANTLR3_HASH_KEY	key;
; 212  :     ANTLR3_UINT64		bit;
; 213  : 
; 214  :     // We have no idea what exactly is in the list
; 215  :     // so create a default bitset and then just add stuff
; 216  :     // as we enumerate.
; 217  :     //
; 218  :     bitSet  = antlr3BitsetNew(0);

  00023	33 c9		 xor	 ecx, ecx
  00025	e8 00 00 00 00	 call	 antlr3BitsetNew
  0002a	48 89 44 24 20	 mov	 QWORD PTR bitSet$[rsp], rax

; 219  : 
; 220  :     en		= antlr3EnumNew(list);

  0002f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR list$[rsp]
  00037	e8 00 00 00 00	 call	 antlr3EnumNew
  0003c	48 89 44 24 28	 mov	 QWORD PTR en$[rsp], rax
$LN2@antlr3Bits:

; 221  : 
; 222  :     while   (en->next(en, &key, (void **)(&bit)) == ANTLR3_SUCCESS)

  00041	4c 8d 44 24 58	 lea	 r8, QWORD PTR bit$[rsp]
  00046	48 8d 54 24 38	 lea	 rdx, QWORD PTR key$[rsp]
  0004b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR en$[rsp]
  00050	48 8b 44 24 28	 mov	 rax, QWORD PTR en$[rsp]
  00055	ff 50 18	 call	 QWORD PTR [rax+24]
  00058	85 c0		 test	 eax, eax
  0005a	75 13		 jne	 SHORT $LN3@antlr3Bits

; 223  :     {
; 224  : 		bitSet->add(bitSet, (ANTLR3_UINT32)bit);

  0005c	8b 54 24 58	 mov	 edx, DWORD PTR bit$[rsp]
  00060	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitSet$[rsp]
  00065	48 8b 44 24 20	 mov	 rax, QWORD PTR bitSet$[rsp]
  0006a	ff 50 30	 call	 QWORD PTR [rax+48]

; 225  :     }

  0006d	eb d2		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 226  :     en->free(en);

  0006f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR en$[rsp]
  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR en$[rsp]
  00079	ff 50 20	 call	 QWORD PTR [rax+32]

; 227  : 
; 228  :     return NULL;

  0007c	33 c0		 xor	 eax, eax

; 229  : }

  0007e	8b f8		 mov	 edi, eax
  00080	48 8b cc	 mov	 rcx, rsp
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3BitsetList$rtcFrameData
  0008a	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  0008f	8b c7		 mov	 eax, edi
  00091	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00095	5f		 pop	 rdi
  00096	c3		 ret	 0
antlr3BitsetList ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetOf
_TEXT	SEGMENT
bitset$ = 32
ap$ = 56
bit$ = 96
antlr3BitsetOf PROC					; COMDAT

; 317  : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	57		 push	 rdi
  00014	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00018	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001d	b9 0c 00 00 00	 mov	 ecx, 12
  00022	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00027	f3 ab		 rep stosd
  00029	8b 4c 24 60	 mov	 ecx, DWORD PTR [rsp+96]

; 318  :     pANTLR3_BITSET  bitset;
; 319  : 
; 320  :     va_list ap;
; 321  : 
; 322  :     // Allocate memory for the bitset structure itself
; 323  :     // the input parameter is the bit number (0 based)
; 324  :     // to include in the bitset, so we need at at least
; 325  :     // bit + 1 bits. If any arguments indicate a 
; 326  :     // a bit higher than the default number of bits (0 menas default size)
; 327  :     // then Add() will take care
; 328  :     // of it.
; 329  :     //
; 330  :     bitset  = antlr3BitsetNew(0);

  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 antlr3BitsetNew
  00034	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 331  : 
; 332  :     if	(bitset == NULL)

  00039	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  0003f	75 04		 jne	 SHORT $LN4@antlr3Bits

; 333  :     {
; 334  : 		return	NULL;

  00041	33 c0		 xor	 eax, eax
  00043	eb 49		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 335  :     }
; 336  : 
; 337  :     // Now we can add the element bits into the set
; 338  :     //
; 339  :     va_start(ap, bit);

  00045	48 8d 44 24 68	 lea	 rax, QWORD PTR bit$[rsp+8]
  0004a	48 89 44 24 38	 mov	 QWORD PTR ap$[rsp], rax
$LN2@antlr3Bits:

; 340  :     while   (bit != -1)

  0004f	83 7c 24 60 ff	 cmp	 DWORD PTR bit$[rsp], -1
  00054	74 2a		 je	 SHORT $LN3@antlr3Bits

; 341  :     {
; 342  : 		antlr3BitsetAdd(bitset, bit);

  00056	8b 54 24 60	 mov	 edx, DWORD PTR bit$[rsp]
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0005f	e8 00 00 00 00	 call	 antlr3BitsetAdd

; 343  : 		bit = va_arg(ap, ANTLR3_UINT32);

  00064	48 8b 44 24 38	 mov	 rax, QWORD PTR ap$[rsp]
  00069	48 83 c0 08	 add	 rax, 8
  0006d	48 89 44 24 38	 mov	 QWORD PTR ap$[rsp], rax
  00072	48 8b 44 24 38	 mov	 rax, QWORD PTR ap$[rsp]
  00077	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  0007a	89 44 24 60	 mov	 DWORD PTR bit$[rsp], eax

; 344  :     }

  0007e	eb cf		 jmp	 SHORT $LN2@antlr3Bits
$LN3@antlr3Bits:

; 345  :     va_end(ap);

  00080	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ap$[rsp], 0

; 346  : 
; 347  :     // return the new bitset
; 348  :     //
; 349  :     return  bitset;

  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 350  : }

  0008e	48 8b f8	 mov	 rdi, rax
  00091	48 8b cc	 mov	 rcx, rsp
  00094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:antlr3BitsetOf$rtcFrameData
  0009b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  000a0	48 8b c7	 mov	 rax, rdi
  000a3	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
antlr3BitsetOf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3bitset.c
;	COMDAT antlr3BitsetNew
_TEXT	SEGMENT
bitset$ = 32
numelements$ = 40
numBits$ = 64
antlr3BitsetNew PROC					; COMDAT

; 77   : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 78   : 	pANTLR3_BITSET  bitset;
; 79   : 
; 80   : 	ANTLR3_UINT32   numelements;
; 81   : 
; 82   : 	// Allocate memory for the bitset structure itself
; 83   : 	//
; 84   : 	bitset  = (pANTLR3_BITSET) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_BITSET));

  00009	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR bitset$[rsp], rax

; 85   : 
; 86   : 	if	(bitset == NULL)

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR bitset$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@antlr3Bits

; 87   : 	{
; 88   : 		return	NULL;

  00021	33 c0		 xor	 eax, eax
  00023	e9 89 00 00 00	 jmp	 $LN1@antlr3Bits
$LN2@antlr3Bits:

; 89   : 	}
; 90   : 
; 91   : 	// Avoid memory thrashing at the up front expense of a few bytes
; 92   : 	//
; 93   : 	if	(numBits < (8 * ANTLR3_BITSET_BITS))

  00028	81 7c 24 40 00
	02 00 00	 cmp	 DWORD PTR numBits$[rsp], 512 ; 00000200H
  00030	73 08		 jae	 SHORT $LN3@antlr3Bits

; 94   : 	{
; 95   : 		numBits = 8 * ANTLR3_BITSET_BITS;

  00032	c7 44 24 40 00
	02 00 00	 mov	 DWORD PTR numBits$[rsp], 512 ; 00000200H
$LN3@antlr3Bits:

; 96   : 	}
; 97   : 
; 98   : 	// No we need to allocate the memory for the number of bits asked for
; 99   : 	// in multiples of ANTLR3_UINT64. 
; 100  : 	//
; 101  : 	numelements	= ((numBits -1) >> ANTLR3_BITSET_LOG_BITS) + 1;

  0003a	8b 44 24 40	 mov	 eax, DWORD PTR numBits$[rsp]
  0003e	ff c8		 dec	 eax
  00040	c1 e8 06	 shr	 eax, 6
  00043	ff c0		 inc	 eax
  00045	89 44 24 28	 mov	 DWORD PTR numelements$[rsp], eax

; 102  : 
; 103  : 	bitset->blist.bits    = (pANTLR3_BITWORD) ANTLR3_MALLOC((size_t)(numelements * sizeof(ANTLR3_BITWORD)));

  00049	8b 44 24 28	 mov	 eax, DWORD PTR numelements$[rsp]
  0004d	48 c1 e0 03	 shl	 rax, 3
  00051	48 8b c8	 mov	 rcx, rax
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  0005f	48 89 01	 mov	 QWORD PTR [rcx], rax

; 104  : 	if	(bitset->blist.bits == NULL)

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  00067	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0006b	75 0f		 jne	 SHORT $LN4@antlr3Bits

; 105  : 	{
; 106  : 		ANTLR3_FREE(bitset);

  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 107  : 		return	NULL;

  00078	33 c0		 xor	 eax, eax
  0007a	eb 35		 jmp	 SHORT $LN1@antlr3Bits
$LN4@antlr3Bits:

; 108  : 	}
; 109  : 	memset(bitset->blist.bits, 0, (size_t)(numelements * sizeof(ANTLR3_BITWORD)));

  0007c	8b 44 24 28	 mov	 eax, DWORD PTR numelements$[rsp]
  00080	48 c1 e0 03	 shl	 rax, 3
  00084	4c 8b c0	 mov	 r8, rax
  00087	33 d2		 xor	 edx, edx
  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0008e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00091	e8 00 00 00 00	 call	 memset

; 110  : 	bitset->blist.length  = numelements;

  00096	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
  0009b	8b 4c 24 28	 mov	 ecx, DWORD PTR numelements$[rsp]
  0009f	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 111  : 
; 112  : 	antlr3BitsetSetAPI(bitset);

  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bitset$[rsp]
  000a7	e8 00 00 00 00	 call	 antlr3BitsetSetAPI

; 113  : 
; 114  : 
; 115  : 	// All seems good
; 116  : 	//
; 117  : 	return  bitset;

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR bitset$[rsp]
$LN1@antlr3Bits:

; 118  : }

  000b1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000b5	5f		 pop	 rdi
  000b6	c3		 ret	 0
antlr3BitsetNew ENDP
_TEXT	ENDS
END
