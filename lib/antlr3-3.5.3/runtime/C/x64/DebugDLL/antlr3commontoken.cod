; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	antlr3CommonTokenNew
PUBLIC	antlr3TokenFactoryNew
PUBLIC	antlr3SetTokenAPI
PUBLIC	??_C@_05FLDDOMNH@?$DMEOF?$DO@			; `string'
PUBLIC	??_C@_08NEOOKDGC@?$FLIndex?3?5@			; `string'
PUBLIC	??_C@_09LBBAKIIA@?5?$CIStart?3?5@		; `string'
PUBLIC	??_C@_07LGAFOPAI@?9Stop?3?5@			; `string'
PUBLIC	??_C@_04KDEICOAP@?$CJ?5?$DN?8@			; `string'
PUBLIC	??_C@_08KMKDFHHP@?8?0?5type?$DM@		; `string'
PUBLIC	??_C@_02LLMPMKNF@?$DO?5@			; `string'
PUBLIC	??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@		; `string'
PUBLIC	??_C@_02KCKGHPCA@?$CJ?5@			; `string'
PUBLIC	??_C@_06FIEBOLOH@Line?3?5@			; `string'
PUBLIC	??_C@_09PNCFGGF@?5LinePos?3@			; `string'
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3CommonTokenNew DD imagerel $LN4
	DD	imagerel $LN4+58
	DD	imagerel $unwind$antlr3CommonTokenNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3TokenFactoryNew DD imagerel $LN4
	DD	imagerel $LN4+215
	DD	imagerel $unwind$antlr3TokenFactoryNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3SetTokenAPI DD imagerel $LN3
	DD	imagerel $LN3+366
	DD	imagerel $unwind$antlr3SetTokenAPI
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getText DD imagerel getText
	DD	imagerel getText+343
	DD	imagerel $unwind$getText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText DD imagerel setText
	DD	imagerel setText+39
	DD	imagerel $unwind$setText
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setText8 DD imagerel setText8
	DD	imagerel setText8+113
	DD	imagerel $unwind$setText8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getType DD imagerel getType
	DD	imagerel getType+15
	DD	imagerel $unwind$getType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setType DD imagerel setType
	DD	imagerel setType+23
	DD	imagerel $unwind$setType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLine DD imagerel getLine
	DD	imagerel getLine+16
	DD	imagerel $unwind$getLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setLine DD imagerel setLine
	DD	imagerel setLine+24
	DD	imagerel $unwind$setLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getCharPositionInLine DD imagerel getCharPositionInLine
	DD	imagerel getCharPositionInLine+16
	DD	imagerel $unwind$getCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setCharPositionInLine DD imagerel setCharPositionInLine
	DD	imagerel setCharPositionInLine+24
	DD	imagerel $unwind$setCharPositionInLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getChannel DD imagerel getChannel
	DD	imagerel getChannel+16
	DD	imagerel $unwind$getChannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setChannel DD imagerel setChannel
	DD	imagerel setChannel+24
	DD	imagerel $unwind$setChannel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTokenIndex DD imagerel getTokenIndex
	DD	imagerel getTokenIndex+17
	DD	imagerel $unwind$getTokenIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setTokenIndex DD imagerel setTokenIndex
	DD	imagerel setTokenIndex+27
	DD	imagerel $unwind$setTokenIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getStartIndex DD imagerel getStartIndex
	DD	imagerel getStartIndex+64
	DD	imagerel $unwind$getStartIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setStartIndex DD imagerel setStartIndex
	DD	imagerel setStartIndex+27
	DD	imagerel $unwind$setStartIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getStopIndex DD imagerel getStopIndex
	DD	imagerel getStopIndex+17
	DD	imagerel $unwind$getStopIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setStopIndex DD imagerel setStopIndex
	DD	imagerel setStopIndex+27
	DD	imagerel $unwind$setStopIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toString DD imagerel toString
	DD	imagerel toString+561
	DD	imagerel $unwind$toString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$factoryClose DD imagerel factoryClose
	DD	imagerel factoryClose+314
	DD	imagerel $unwind$factoryClose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newToken DD imagerel newToken
	DD	imagerel newToken+69
	DD	imagerel $unwind$newToken
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setInputStream DD imagerel setInputStream
	DD	imagerel setInputStream+85
	DD	imagerel $unwind$setInputStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$factoryReset DD imagerel factoryReset
	DD	imagerel factoryReset+38
	DD	imagerel $unwind$factoryReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPool DD imagerel newPool
	DD	imagerel newPool+251
	DD	imagerel $unwind$newPool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPoolToken DD imagerel newPoolToken
	DD	imagerel newPoolToken+301
	DD	imagerel $unwind$newPoolToken
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_09PNCFGGF@?5LinePos?3@
CONST	SEGMENT
??_C@_09PNCFGGF@?5LinePos?3@ DB ' LinePos:', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06FIEBOLOH@Line?3?5@
CONST	SEGMENT
??_C@_06FIEBOLOH@Line?3?5@ DB 'Line: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCKGHPCA@?$CJ?5@
CONST	SEGMENT
??_C@_02KCKGHPCA@?$CJ?5@ DB ') ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@
CONST	SEGMENT
??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@ DB '(channel = ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LLMPMKNF@?$DO?5@
CONST	SEGMENT
??_C@_02LLMPMKNF@?$DO?5@ DB '> ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08KMKDFHHP@?8?0?5type?$DM@
CONST	SEGMENT
??_C@_08KMKDFHHP@?8?0?5type?$DM@ DB ''', type<', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDEICOAP@?$CJ?5?$DN?8@
CONST	SEGMENT
??_C@_04KDEICOAP@?$CJ?5?$DN?8@ DB ') =''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07LGAFOPAI@?9Stop?3?5@
CONST	SEGMENT
??_C@_07LGAFOPAI@?9Stop?3?5@ DB '-Stop: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LBBAKIIA@?5?$CIStart?3?5@
CONST	SEGMENT
??_C@_09LBBAKIIA@?5?$CIStart?3?5@ DB ' (Start: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08NEOOKDGC@?$FLIndex?3?5@
CONST	SEGMENT
??_C@_08NEOOKDGC@?$FLIndex?3?5@ DB '[Index: ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FLDDOMNH@?$DMEOF?$DO@
CONST	SEGMENT
??_C@_05FLDDOMNH@?$DMEOF?$DO@ DB '<EOF>', 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPoolToken DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPool DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factoryReset DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setInputStream DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newToken DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$factoryClose DD 020a01H
	DD	07006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toString DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setStopIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getStopIndex DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setStartIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getStartIndex DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setTokenIndex DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTokenIndex DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setChannel DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getChannel DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setCharPositionInLine DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getCharPositionInLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setLine DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setType DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getType DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText8 DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setText DD 010b01H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getText DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3SetTokenAPI DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3TokenFactoryNew DD 020a01H
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3CommonTokenNew DD 020901H
	DD	070055209H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT newPoolToken
_TEXT	SEGMENT
token$ = 32
tv133 = 40
factory$ = 64
newPoolToken PROC					; COMDAT

; 206  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 207  :     pANTLR3_COMMON_TOKEN token;
; 208  : 
; 209  : 	if (factory == NULL) { return NULL; }

  0000a	48 83 7c 24 40
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00010	75 07		 jne	 SHORT $LN2@newPoolTok
  00012	33 c0		 xor	 eax, eax
  00014	e9 0e 01 00 00	 jmp	 $LN1@newPoolTok
$LN2@newPoolTok:

; 210  : 
; 211  :     /* See if we need a new token pool before allocating a new
; 212  :      * one
; 213  :      */
; 214  :     if (factory->nextToken >= ANTLR3_FACTORY_POOL_SIZE)

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0001e	81 78 10 00 04
	00 00		 cmp	 DWORD PTR [rax+16], 1024 ; 00000400H
  00025	72 18		 jb	 SHORT $LN3@newPoolTok

; 215  :     {
; 216  :         /* We ran out of tokens in the current pool, so we need a new pool
; 217  :          */
; 218  :         if (!newPool(factory))

  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0002c	e8 00 00 00 00	 call	 newPool
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN4@newPoolTok

; 219  : 		{
; 220  : 			return NULL;

  00038	33 c0		 xor	 eax, eax
  0003a	e9 e8 00 00 00	 jmp	 $LN1@newPoolTok
$LN4@newPoolTok:
$LN3@newPoolTok:

; 221  : 		}
; 222  :     }
; 223  : 
; 224  : 	// make sure the factory is sane
; 225  : 	if (factory->pools == NULL) { return NULL; }

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00044	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00048	75 07		 jne	 SHORT $LN5@newPoolTok
  0004a	33 c0		 xor	 eax, eax
  0004c	e9 d6 00 00 00	 jmp	 $LN1@newPoolTok
$LN5@newPoolTok:

; 226  : 	if (factory->pools[factory->thisPool] == NULL) { return NULL; }

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00056	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  0005a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0005f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00062	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00067	75 07		 jne	 SHORT $LN6@newPoolTok
  00069	33 c0		 xor	 eax, eax
  0006b	e9 b7 00 00 00	 jmp	 $LN1@newPoolTok
$LN6@newPoolTok:

; 227  : 
; 228  :     /* Assuming everything went well (we are trying for performance here so doing minimal
; 229  :      * error checking. Then we can work out what the pointer is to the next token.
; 230  :      */
; 231  :     token = factory->pools[factory->thisPool] + factory->nextToken;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00075	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  00079	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0007e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00081	48 8b 54 24 40	 mov	 rdx, QWORD PTR factory$[rsp]
  00086	8b 52 10	 mov	 edx, DWORD PTR [rdx+16]
  00089	48 69 d2 08 01
	00 00		 imul	 rdx, rdx, 264		; 00000108H
  00090	48 03 14 c1	 add	 rdx, QWORD PTR [rcx+rax*8]
  00094	48 8b c2	 mov	 rax, rdx
  00097	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 232  :     factory->nextToken++;

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000a1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a4	ff c0		 inc	 eax
  000a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000ab	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 233  : 
; 234  :     /* We have our token pointer now, so we can initialize it to the predefined model.
; 235  :      * We only need do this though if the token is not already initialized, we just check
; 236  :      * an api function pointer for this as they are allocated via calloc.
; 237  :      */
; 238  :     if  (token->setStartIndex == NULL)

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  000b3	48 83 b8 e8 00
	00 00 00	 cmp	 QWORD PTR [rax+232], 0
  000bb	75 65		 jne	 SHORT $LN7@newPoolTok

; 239  :     {
; 240  :         antlr3SetTokenAPI(token);

  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  000c2	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 241  : 
; 242  :         // It is factory made, and we need to copy the string factory pointer
; 243  :         //
; 244  :         token->factoryMade  = ANTLR3_TRUE;

  000c7	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  000cc	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 245  :         token->strFactory   = factory->input == NULL ? NULL : factory->input->strFactory;

  000d0	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000d5	48 83 b8 20 01
	00 00 00	 cmp	 QWORD PTR [rax+288], 0
  000dd	75 0b		 jne	 SHORT $LN9@newPoolTok
  000df	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv133[rsp], 0
  000e8	eb 15		 jmp	 SHORT $LN10@newPoolTok
$LN9@newPoolTok:
  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000ef	48 8b 80 20 01
	00 00		 mov	 rax, QWORD PTR [rax+288]
  000f6	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  000fa	48 89 44 24 28	 mov	 QWORD PTR tv133[rsp], rax
$LN10@newPoolTok:
  000ff	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00104	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv133[rsp]
  00109	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 246  :         token->input        = factory->input;

  0010d	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00112	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00117	48 8b 89 20 01
	00 00		 mov	 rcx, QWORD PTR [rcx+288]
  0011e	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN7@newPoolTok:

; 247  :     }
; 248  : 
; 249  :     /* And we are done
; 250  :      */
; 251  :     return token;

  00122	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
$LN1@newPoolTok:

; 252  : }

  00127	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012b	5f		 pop	 rdi
  0012c	c3		 ret	 0
newPoolToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT newPool
_TEXT	SEGMENT
newPools$1 = 32
factory$ = 64
newPool	PROC						; COMDAT

; 153  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 154  :     /* Increment factory count
; 155  :      */
; 156  :     ++(factory->thisPool);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00012	ff c0		 inc	 eax
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00019	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 157  : 
; 158  :     // If we were reusing this token factory then we may already have a pool
; 159  :     // allocated. If we exceeded the max available then we must allocate a new
; 160  :     // one.
; 161  :     if  (factory->thisPool > factory->maxPool)

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00026	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00029	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0002c	0f 8e b5 00 00
	00		 jle	 $LN2@newPool

; 162  :     {
; 163  :         /* Ensure we have enough pointers allocated
; 164  :          */
; 165  : 		pANTLR3_COMMON_TOKEN *newPools = (pANTLR3_COMMON_TOKEN *)

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00037	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003a	ff c0		 inc	 eax
  0003c	48 98		 cdqe
  0003e	48 c1 e0 03	 shl	 rax, 3
  00042	8b c0		 mov	 eax, eax
  00044	8b d0		 mov	 edx, eax
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0004b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00054	48 89 44 24 20	 mov	 QWORD PTR newPools$1[rsp], rax

; 166  : 			ANTLR3_REALLOC((void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
; 167  : 		                   (ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TOKEN *))	/* Memory for new pool pointers */
; 168  : 			);
; 169  : 		if (newPools == NULL)

  00059	48 83 7c 24 20
	00		 cmp	 QWORD PTR newPools$1[rsp], 0
  0005f	75 16		 jne	 SHORT $LN3@newPool

; 170  : 		{
; 171  : 			// We are out of memory, but the old allocation is still valid for now
; 172  : 			--(factory->thisPool);

  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00066	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00069	ff c8		 dec	 eax
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00070	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 173  : 			return ANTLR3_FALSE;

  00073	32 c0		 xor	 al, al
  00075	eb 7e		 jmp	 SHORT $LN1@newPool
$LN3@newPool:

; 174  : 		}
; 175  : 
; 176  :         factory->pools = newPools;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newPools$1[rsp]
  00081	48 89 08	 mov	 QWORD PTR [rax], rcx

; 177  : 
; 178  :         /* Allocate a new pool for the factory
; 179  :          */
; 180  :         factory->pools[factory->thisPool]	=

  00084	ba 00 20 04 00	 mov	 edx, 270336		; 00042000H
  00089	b9 01 00 00 00	 mov	 ecx, 1
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00099	48 63 49 08	 movsxd	 rcx, DWORD PTR [rcx+8]
  0009d	48 8b 54 24 40	 mov	 rdx, QWORD PTR factory$[rsp]
  000a2	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000a5	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 181  : 			        (pANTLR3_COMMON_TOKEN) 
; 182  : 				    ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN) * ANTLR3_FACTORY_POOL_SIZE));
; 183  : 		if (factory->pools[factory->thisPool] == NULL)

  000a9	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000ae	48 63 40 08	 movsxd	 rax, DWORD PTR [rax+8]
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000b7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000ba	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000bf	75 16		 jne	 SHORT $LN4@newPool

; 184  : 		{
; 185  : 			// Allocation failed
; 186  : 			--(factory->thisPool);

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c9	ff c8		 dec	 eax
  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000d0	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 187  : 			return ANTLR3_FALSE;

  000d3	32 c0		 xor	 al, al
  000d5	eb 1e		 jmp	 SHORT $LN1@newPool
$LN4@newPool:

; 188  : 		}
; 189  : 
; 190  :         // We now have a new pool and can track it as the maximum we have created so far
; 191  :         //
; 192  :         factory->maxPool = factory->thisPool;

  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000dc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  000e1	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000e4	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN2@newPool:

; 193  :     }
; 194  : 
; 195  :     /* Reset the counters
; 196  :      */
; 197  :     factory->nextToken	= 0;

  000e7	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  000ec	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 198  :   
; 199  :     /* Done
; 200  :      */
; 201  :     return ANTLR3_TRUE;

  000f3	b0 01		 mov	 al, 1
$LN1@newPool:

; 202  : }

  000f5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f9	5f		 pop	 rdi
  000fa	c3		 ret	 0
newPool	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT factoryReset
_TEXT	SEGMENT
factory$ = 48
factoryReset PROC					; COMDAT

; 256  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 257  :     // Just start again with pool #0 when we are
; 258  :     // called.
; 259  :     //
; 260  :     factory->thisPool   = -1;

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 261  :     newPool(factory);

  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  0001b	e8 00 00 00 00	 call	 newPool

; 262  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5f		 pop	 rdi
  00025	c3		 ret	 0
factoryReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setInputStream
_TEXT	SEGMENT
factory$ = 16
input$ = 24
setInputStream PROC					; COMDAT

; 138  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 139  :     factory->input          =  input;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR input$[rsp]
  00015	48 89 88 20 01
	00 00		 mov	 QWORD PTR [rax+288], rcx

; 140  :     factory->unTruc.input   =  input;

  0001c	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  00021	48 8b 4c 24 18	 mov	 rcx, QWORD PTR input$[rsp]
  00026	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 141  : 	if	(input != NULL)

  0002a	48 83 7c 24 18
	00		 cmp	 QWORD PTR input$[rsp], 0
  00030	74 14		 je	 SHORT $LN2@setInputSt

; 142  : 	{
; 143  : 		factory->unTruc.strFactory	= input->strFactory;

  00032	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  00037	48 8b 4c 24 18	 mov	 rcx, QWORD PTR input$[rsp]
  0003c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00040	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 144  : 	}

  00044	eb 0d		 jmp	 SHORT $LN3@setInputSt
$LN2@setInputSt:

; 145  : 	else
; 146  : 	{
; 147  : 		factory->unTruc.strFactory = NULL;

  00046	48 8b 44 24 10	 mov	 rax, QWORD PTR factory$[rsp]
  0004b	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN3@setInputSt:

; 148  :     }
; 149  : }

  00053	5f		 pop	 rdi
  00054	c3		 ret	 0
setInputStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT newToken
_TEXT	SEGMENT
token$ = 32
newToken PROC						; COMDAT

; 328  : {

  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 329  :     pANTLR3_COMMON_TOKEN    token;
; 330  : 
; 331  :     /* Allocate memory for this
; 332  :      */
; 333  :     token   = (pANTLR3_COMMON_TOKEN) ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN)));

  00006	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  0000b	b9 01 00 00 00	 mov	 ecx, 1
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00016	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 334  : 
; 335  :     if	(token == NULL)

  0001b	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  00021	75 04		 jne	 SHORT $LN2@newToken

; 336  :     {
; 337  : 	return	NULL;

  00023	33 c0		 xor	 eax, eax
  00025	eb 18		 jmp	 SHORT $LN1@newToken
$LN2@newToken:

; 338  :     }
; 339  : 
; 340  :     // Install the API
; 341  :     //
; 342  :     antlr3SetTokenAPI(token);

  00027	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  0002c	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 343  :     token->factoryMade = ANTLR3_FALSE;

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00036	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 344  : 
; 345  :     return  token;

  0003a	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
$LN1@newToken:

; 346  : }

  0003f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00043	5f		 pop	 rdi
  00044	c3		 ret	 0
newToken ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT factoryClose
_TEXT	SEGMENT
pool$ = 32
poolCount$ = 40
limit$ = 44
token$ = 48
check$ = 56
tv74 = 64
factory$ = 96
factoryClose PROC					; COMDAT

; 266  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 267  :     pANTLR3_COMMON_TOKEN    pool;
; 268  :     ANTLR3_INT32	    poolCount;
; 269  :     ANTLR3_UINT32	    limit;
; 270  :     ANTLR3_UINT32	    token;
; 271  :     pANTLR3_COMMON_TOKEN    check;
; 272  : 
; 273  :     /* We iterate the token pools one at a time
; 274  :      */
; 275  :     for	(poolCount = 0; poolCount <= factory->thisPool; poolCount++)

  0000a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR poolCount$[rsp], 0
  00012	eb 0a		 jmp	 SHORT $LN4@factoryClo
$LN2@factoryClo:
  00014	8b 44 24 28	 mov	 eax, DWORD PTR poolCount$[rsp]
  00018	ff c0		 inc	 eax
  0001a	89 44 24 28	 mov	 DWORD PTR poolCount$[rsp], eax
$LN4@factoryClo:
  0001e	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00023	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00026	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  0002a	0f 8f eb 00 00
	00		 jg	 $LN3@factoryClo

; 276  :     {
; 277  : 	/* Pointer to current pool
; 278  : 	 */
; 279  : 	pool	= factory->pools[poolCount];

  00030	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00035	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0003a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0003d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00041	48 89 44 24 20	 mov	 QWORD PTR pool$[rsp], rax

; 280  : 
; 281  : 	/* Work out how many tokens we need to check in this pool.
; 282  : 	 */
; 283  : 	limit	= (poolCount == factory->thisPool ? factory->nextToken : ANTLR3_FACTORY_POOL_SIZE);

  00046	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  0004b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004e	39 44 24 28	 cmp	 DWORD PTR poolCount$[rsp], eax
  00052	75 0e		 jne	 SHORT $LN11@factoryClo
  00054	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00059	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0005c	89 44 24 40	 mov	 DWORD PTR tv74[rsp], eax
  00060	eb 08		 jmp	 SHORT $LN12@factoryClo
$LN11@factoryClo:
  00062	c7 44 24 40 00
	04 00 00	 mov	 DWORD PTR tv74[rsp], 1024 ; 00000400H
$LN12@factoryClo:
  0006a	8b 44 24 40	 mov	 eax, DWORD PTR tv74[rsp]
  0006e	89 44 24 2c	 mov	 DWORD PTR limit$[rsp], eax

; 284  : 	
; 285  : 	/* Marginal condition, we might be at the start of a brand new pool
; 286  : 	 * where the nextToken is 0 and nothing has been allocated.
; 287  : 	 */
; 288  : 	if  (limit > 0)

  00072	83 7c 24 2c 00	 cmp	 DWORD PTR limit$[rsp], 0
  00077	76 71		 jbe	 SHORT $LN8@factoryClo

; 289  : 	{
; 290  : 	    /* We have some tokens allocated from this pool
; 291  : 	     */
; 292  : 	    for (token = 0; token < limit; token++)

  00079	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR token$[rsp], 0
  00081	eb 0a		 jmp	 SHORT $LN7@factoryClo
$LN5@factoryClo:
  00083	8b 44 24 30	 mov	 eax, DWORD PTR token$[rsp]
  00087	ff c0		 inc	 eax
  00089	89 44 24 30	 mov	 DWORD PTR token$[rsp], eax
$LN7@factoryClo:
  0008d	8b 44 24 2c	 mov	 eax, DWORD PTR limit$[rsp]
  00091	39 44 24 30	 cmp	 DWORD PTR token$[rsp], eax
  00095	73 53		 jae	 SHORT $LN6@factoryClo

; 293  : 	    {
; 294  : 		/* Next one in the chain
; 295  : 		 */
; 296  : 		check	= pool + token;

  00097	8b 44 24 30	 mov	 eax, DWORD PTR token$[rsp]
  0009b	48 69 c0 08 01
	00 00		 imul	 rax, rax, 264		; 00000108H
  000a2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pool$[rsp]
  000a7	48 03 c8	 add	 rcx, rax
  000aa	48 8b c1	 mov	 rax, rcx
  000ad	48 89 44 24 38	 mov	 QWORD PTR check$[rsp], rax

; 297  : 
; 298  : 		/* If the programmer made this a custom token, then
; 299  : 		 * see if we need to call their free routine.
; 300  : 		 */
; 301  : 		if  (check->custom != NULL && check->freeCustom != NULL)

  000b2	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000b7	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000bc	74 2a		 je	 SHORT $LN9@factoryClo
  000be	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000c3	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000c8	74 1e		 je	 SHORT $LN9@factoryClo

; 302  : 		{
; 303  : 		    check->freeCustom(check->custom);

  000ca	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000cf	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  000d3	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000d8	ff 50 70	 call	 QWORD PTR [rax+112]

; 304  : 		    check->custom = NULL;

  000db	48 8b 44 24 38	 mov	 rax, QWORD PTR check$[rsp]
  000e0	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
$LN9@factoryClo:

; 305  : 		}
; 306  : 	    }

  000e8	eb 99		 jmp	 SHORT $LN5@factoryClo
$LN6@factoryClo:
$LN8@factoryClo:

; 307  : 	}
; 308  : 
; 309  : 	/* We can now free this pool allocation
; 310  : 	 */
; 311  : 	ANTLR3_FREE(factory->pools[poolCount]);

  000ea	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  000ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  000f4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000f7	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 312  : 	factory->pools[poolCount] = NULL;

  00101	48 63 44 24 28	 movsxd	 rax, DWORD PTR poolCount$[rsp]
  00106	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0010b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0010e	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0

; 313  :     }

  00116	e9 f9 fe ff ff	 jmp	 $LN2@factoryClo
$LN3@factoryClo:

; 314  : 
; 315  :     /* All the pools are deallocated we can free the pointers to the pools
; 316  :      * now.
; 317  :      */
; 318  :     ANTLR3_FREE(factory->pools);

  0011b	48 8b 44 24 60	 mov	 rax, QWORD PTR factory$[rsp]
  00120	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 319  : 
; 320  :     /* Finally, we can free the space for the factory itself
; 321  :      */
; 322  :     ANTLR3_FREE(factory);

  00129	48 8b 4c 24 60	 mov	 rcx, QWORD PTR factory$[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 323  : }

  00134	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00138	5f		 pop	 rdi
  00139	c3		 ret	 0
factoryClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT toString
_TEXT	SEGMENT
text$ = 32
outtext$ = 40
token$ = 64
toString PROC						; COMDAT

; 558  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 559  :     pANTLR3_STRING  text;
; 560  :     pANTLR3_STRING  outtext;
; 561  : 
; 562  :     text    =	token->getText(token);

  0000a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00014	ff 50 78	 call	 QWORD PTR [rax+120]
  00017	48 89 44 24 20	 mov	 QWORD PTR text$[rsp], rax

; 563  :     
; 564  :     if	(text == NULL)

  0001c	48 83 7c 24 20
	00		 cmp	 QWORD PTR text$[rsp], 0
  00022	75 07		 jne	 SHORT $LN2@toString

; 565  :     {
; 566  : 		return NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 00 02 00 00	 jmp	 $LN1@toString
$LN2@toString:

; 567  :     }
; 568  : 
; 569  : 	if	(text->factory == NULL)

  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR text$[rsp]
  00030	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00034	75 0a		 jne	 SHORT $LN3@toString

; 570  : 	{
; 571  : 		return text;		// This usally means it is the EOF token

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR text$[rsp]
  0003b	e9 eb 01 00 00	 jmp	 $LN1@toString
$LN3@toString:

; 572  : 	}
; 573  : 
; 574  :     /* A new empty string to assemble all the stuff in
; 575  :      */
; 576  :     outtext = text->factory->newRaw(text->factory);

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR text$[rsp]
  00045	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00048	48 8b 4c 24 20	 mov	 rcx, QWORD PTR text$[rsp]
  0004d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00050	ff 50 10	 call	 QWORD PTR [rax+16]
  00053	48 89 44 24 28	 mov	 QWORD PTR outtext$[rsp], rax

; 577  : 
; 578  :     /* Now we use our handy dandy string utility to assemble the
; 579  :      * the reporting string
; 580  :      * return "[@"+getTokenIndex()+","+start+":"+stop+"='"+txt+"',<"+type+">"+channelStr+","+line+":"+getCharPositionInLine()+"]";
; 581  :      */
; 582  :     outtext->append8(outtext, "[Index: ");

  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08NEOOKDGC@?$FLIndex?3?5@
  0005f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00069	ff 50 38	 call	 QWORD PTR [rax+56]

; 583  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getTokenIndex(token));

  0006c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00076	ff 90 d0 00 00
	00		 call	 QWORD PTR [rax+208]
  0007c	8b d0		 mov	 edx, eax
  0007e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00083	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00088	ff 50 78	 call	 QWORD PTR [rax+120]

; 584  :     outtext->append8(outtext, " (Start: ");

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LBBAKIIA@?5?$CIStart?3?5@
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  0009c	ff 50 38	 call	 QWORD PTR [rax+56]

; 585  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getStartIndex(token));

  0009f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  000a4	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  000a9	ff 90 e0 00 00
	00		 call	 QWORD PTR [rax+224]
  000af	8b d0		 mov	 edx, eax
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000b6	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  000bb	ff 50 78	 call	 QWORD PTR [rax+120]

; 586  :     outtext->append8(outtext, "-Stop: ");

  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07LGAFOPAI@?9Stop?3?5@
  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  000cf	ff 50 38	 call	 QWORD PTR [rax+56]

; 587  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getStopIndex(token));

  000d2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  000d7	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  000dc	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  000e2	8b d0		 mov	 edx, eax
  000e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000e9	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  000ee	ff 50 78	 call	 QWORD PTR [rax+120]

; 588  :     outtext->append8(outtext, ") ='");

  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04KDEICOAP@?$CJ?5?$DN?8@
  000f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  000fd	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00102	ff 50 38	 call	 QWORD PTR [rax+56]

; 589  :     outtext->appendS(outtext, text);

  00105	48 8b 54 24 20	 mov	 rdx, QWORD PTR text$[rsp]
  0010a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00114	ff 50 58	 call	 QWORD PTR [rax+88]

; 590  :     outtext->append8(outtext, "', type<");

  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_08KMKDFHHP@?8?0?5type?$DM@
  0011e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00123	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00128	ff 50 38	 call	 QWORD PTR [rax+56]

; 591  :     outtext->addi   (outtext, token->type);

  0012b	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00130	8b 10		 mov	 edx, DWORD PTR [rax]
  00132	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  0013c	ff 50 78	 call	 QWORD PTR [rax+120]

; 592  :     outtext->append8(outtext, "> ");

  0013f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LLMPMKNF@?$DO?5@
  00146	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  0014b	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00150	ff 50 38	 call	 QWORD PTR [rax+56]

; 593  : 
; 594  :     if	(token->getChannel(token) > ANTLR3_TOKEN_DEFAULT_CHANNEL)

  00153	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00158	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0015d	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  00163	85 c0		 test	 eax, eax
  00165	76 47		 jbe	 SHORT $LN4@toString

; 595  :     {
; 596  : 		outtext->append8(outtext, "(channel = ");

  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@NJBPMJAH@?$CIchannel?5?$DN?5@
  0016e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00173	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00178	ff 50 38	 call	 QWORD PTR [rax+56]

; 597  : 		outtext->addi	(outtext, (ANTLR3_INT32)token->getChannel(token));

  0017b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00185	ff 90 c0 00 00
	00		 call	 QWORD PTR [rax+192]
  0018b	8b d0		 mov	 edx, eax
  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  00192	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00197	ff 50 78	 call	 QWORD PTR [rax+120]

; 598  : 		outtext->append8(outtext, ") ");

  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KCKGHPCA@?$CJ?5@
  001a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001a6	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001ab	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@toString:

; 599  :     }
; 600  : 
; 601  :     outtext->append8(outtext, "Line: ");

  001ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06FIEBOLOH@Line?3?5@
  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001bf	ff 50 38	 call	 QWORD PTR [rax+56]

; 602  :     outtext->addi   (outtext, (ANTLR3_INT32)token->getLine(token));

  001c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  001c7	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  001cc	ff 90 a0 00 00
	00		 call	 QWORD PTR [rax+160]
  001d2	8b d0		 mov	 edx, eax
  001d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001d9	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001de	ff 50 78	 call	 QWORD PTR [rax+120]

; 603  :     outtext->append8(outtext, " LinePos:");

  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09PNCFGGF@?5LinePos?3@
  001e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  001ed	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  001f2	ff 50 38	 call	 QWORD PTR [rax+56]

; 604  :     outtext->addi   (outtext, token->getCharPositionInLine(token));

  001f5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  001fa	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  001ff	ff 90 b0 00 00
	00		 call	 QWORD PTR [rax+176]
  00205	8b d0		 mov	 edx, eax
  00207	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  0020c	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00211	ff 50 78	 call	 QWORD PTR [rax+120]

; 605  :     outtext->addc   (outtext, ']');

  00214	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  00219	48 8b 4c 24 28	 mov	 rcx, QWORD PTR outtext$[rsp]
  0021e	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
  00223	ff 50 70	 call	 QWORD PTR [rax+112]

; 606  : 
; 607  :     return  outtext;

  00226	48 8b 44 24 28	 mov	 rax, QWORD PTR outtext$[rsp]
$LN1@toString:

; 608  : }

  0022b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0022f	5f		 pop	 rdi
  00230	c3		 ret	 0
toString ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setStopIndex
_TEXT	SEGMENT
token$ = 16
stop$ = 24
setStopIndex PROC					; COMDAT

; 553  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 554  :     token->stop	= stop;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR stop$[rsp]
  00015	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 555  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getStopIndex
_TEXT	SEGMENT
token$ = 16
getStopIndex PROC					; COMDAT

; 548  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 549  :     return  token->stop;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]

; 550  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
getStopIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setStartIndex
_TEXT	SEGMENT
token$ = 16
start$ = 24
setStartIndex PROC					; COMDAT

; 543  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 544  :     token->start    = start;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR start$[rsp]
  00015	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 545  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getStartIndex
_TEXT	SEGMENT
tv69 = 0
token$ = 32
getStartIndex PROC					; COMDAT

; 538  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 539  : 	return  token->start == -1 ? (ANTLR3_MARKER)(token->input->data) : token->start;

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0000f	48 83 78 38 ff	 cmp	 QWORD PTR [rax+56], -1
  00014	75 13		 jne	 SHORT $LN3@getStartIn
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0001b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0001f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00023	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
  00027	eb 0d		 jmp	 SHORT $LN4@getStartIn
$LN3@getStartIn:
  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  0002e	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00032	48 89 04 24	 mov	 QWORD PTR tv69[rsp], rax
$LN4@getStartIn:
  00036	48 8b 04 24	 mov	 rax, QWORD PTR tv69[rsp]

; 540  : }

  0003a	48 83 c4 10	 add	 rsp, 16
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
getStartIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setTokenIndex
_TEXT	SEGMENT
token$ = 16
index$ = 24
setTokenIndex PROC					; COMDAT

; 533  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 534  :     token->index    = index;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	48 8b 4c 24 18	 mov	 rcx, QWORD PTR index$[rsp]
  00015	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 535  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
setTokenIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getTokenIndex
_TEXT	SEGMENT
token$ = 16
getTokenIndex PROC					; COMDAT

; 528  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 529  :     return  token->index;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]

; 530  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
getTokenIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setChannel
_TEXT	SEGMENT
token$ = 16
channel$ = 24
setChannel PROC						; COMDAT

; 523  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 524  :     token->channel  = channel;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR channel$[rsp]
  00013	89 48 24	 mov	 DWORD PTR [rax+36], ecx

; 525  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
setChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getChannel
_TEXT	SEGMENT
token$ = 16
getChannel PROC						; COMDAT

; 518  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 519  :     return  token->channel;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 40 24	 mov	 eax, DWORD PTR [rax+36]

; 520  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getChannel ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setCharPositionInLine
_TEXT	SEGMENT
token$ = 16
pos$ = 24
setCharPositionInLine PROC				; COMDAT

; 513  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 514  :     token->charPosition = pos;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR pos$[rsp]
  00013	89 48 20	 mov	 DWORD PTR [rax+32], ecx

; 515  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
setCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getCharPositionInLine
_TEXT	SEGMENT
token$ = 16
getCharPositionInLine PROC				; COMDAT

; 508  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 509  :     return  token->charPosition;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 40 20	 mov	 eax, DWORD PTR [rax+32]

; 510  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getCharPositionInLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setLine
_TEXT	SEGMENT
token$ = 16
line$ = 24
setLine	PROC						; COMDAT

; 503  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 504  :     token->line = line;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR line$[rsp]
  00013	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 505  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
setLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getLine
_TEXT	SEGMENT
token$ = 16
getLine	PROC						; COMDAT

; 498  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 499  :     return  token->line;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]

; 500  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
getLine	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setType
_TEXT	SEGMENT
token$ = 16
type$ = 24
setType	PROC						; COMDAT

; 493  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 494  :     token->type = type;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR type$[rsp]
  00013	89 08		 mov	 DWORD PTR [rax], ecx

; 495  : }

  00015	5f		 pop	 rdi
  00016	c3		 ret	 0
setType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getType
_TEXT	SEGMENT
token$ = 16
getType	PROC						; COMDAT

; 488  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 489  :     return  token->type;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	8b 00		 mov	 eax, DWORD PTR [rax]

; 490  : }

  0000d	5f		 pop	 rdi
  0000e	c3		 ret	 0
getType	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setText8
_TEXT	SEGMENT
tv66 = 32
token$ = 64
text$ = 72
setText8 PROC						; COMDAT

; 439  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 440  : 	// No text to set, so ignore
; 441  : 	//
; 442  : 	if	(text == NULL) return;

  0000f	48 83 7c 24 48
	00		 cmp	 QWORD PTR text$[rsp], 0
  00015	75 02		 jne	 SHORT $LN4@setText8
  00017	eb 52		 jmp	 SHORT $LN1@setText8
$LN4@setText8:

; 443  : 
; 444  : 	switch	(token->textState)

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0001e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00021	89 44 24 20	 mov	 DWORD PTR tv66[rsp], eax
  00025	83 7c 24 20 00	 cmp	 DWORD PTR tv66[rsp], 0
  0002a	74 09		 je	 SHORT $LN5@setText8
  0002c	83 7c 24 20 01	 cmp	 DWORD PTR tv66[rsp], 1
  00031	74 02		 je	 SHORT $LN6@setText8
  00033	eb 1c		 jmp	 SHORT $LN7@setText8
$LN5@setText8:
$LN6@setText8:

; 445  : 	{
; 446  : 		case	ANTLR3_TEXT_NONE:
; 447  : 		case	ANTLR3_TEXT_CHARP:	// Caller must free before setting again, if it needs to be freed
; 448  : 
; 449  : 			// Nothing in there yet, or just a char *, so just set the
; 450  : 			// text as a pointer
; 451  : 			//
; 452  : 			token->textState		= ANTLR3_TEXT_CHARP;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  0003a	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 453  : 			token->tokText.chars	= (pANTLR3_UCHAR)text;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR text$[rsp]
  0004b	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 454  : 			break;

  0004f	eb 1a		 jmp	 SHORT $LN2@setText8
$LN7@setText8:

; 455  : 
; 456  : 		default:
; 457  : 
; 458  : 			// It was already a pANTLR3_STRING, so just override it
; 459  : 			//
; 460  : 			token->tokText.text->set8(token->tokText.text, (const char *)text);

  00051	48 8b 44 24 40	 mov	 rax, QWORD PTR token$[rsp]
  00056	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0005a	48 8b 54 24 48	 mov	 rdx, QWORD PTR text$[rsp]
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR token$[rsp]
  00064	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00068	ff 50 28	 call	 QWORD PTR [rax+40]
$LN2@setText8:
$LN1@setText8:

; 461  : 			break;
; 462  : 	}
; 463  : 
; 464  : 	// We are done 
; 465  : 	//
; 466  : 	return;
; 467  : }

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5f		 pop	 rdi
  00070	c3		 ret	 0
setText8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT setText
_TEXT	SEGMENT
token$ = 16
text$ = 24
setText	PROC						; COMDAT

; 475  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi

; 476  : 	// Merely replaces and existing pre-defined text with the supplied
; 477  : 	// string
; 478  : 	//
; 479  : 	token->textState	= ANTLR3_TEXT_STRING;

  0000b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00010	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 480  : 	token->tokText.text	= text;

  00017	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0001c	48 8b 4c 24 18	 mov	 rcx, QWORD PTR text$[rsp]
  00021	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 481  : 
; 482  : 	/* We are done 
; 483  : 	*/
; 484  : 	return;
; 485  : }

  00025	5f		 pop	 rdi
  00026	c3		 ret	 0
setText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT getText
_TEXT	SEGMENT
tv65 = 32
tv131 = 40
tv142 = 48
token$ = 80
getText	PROC						; COMDAT

; 375  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 376  : 	switch (token->textState)

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0000f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00012	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00016	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  0001b	74 1c		 je	 SHORT $LN5@getText
  0001d	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  00022	74 02		 je	 SHORT $LN4@getText
  00024	eb 6e		 jmp	 SHORT $LN8@getText
$LN4@getText:

; 377  : 	{
; 378  : 		case ANTLR3_TEXT_STRING:
; 379  : 
; 380  : 			// Someone already created a string for this token, so we just
; 381  : 			// use it.
; 382  : 			//
; 383  : 			return	token->tokText.text;

  00026	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0002b	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0002f	e9 1d 01 00 00	 jmp	 $LN1@getText

; 384  : 			break;

  00034	e9 18 01 00 00	 jmp	 $LN2@getText
$LN5@getText:

; 385  :     
; 386  : 		case ANTLR3_TEXT_CHARP:
; 387  : 
; 388  : 			// We had a straight text pointer installed, now we
; 389  : 			// must convert it to a string. Note we have to do this here
; 390  : 			// or otherwise setText8() will just install the same char*
; 391  : 			//
; 392  : 			if	(token->strFactory != NULL)

  00039	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0003e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00043	74 43		 je	 SHORT $LN6@getText

; 393  : 			{
; 394  : 				token->tokText.text	= token->strFactory->newStr8(token->strFactory, (pANTLR3_UINT8)token->tokText.chars);

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0004a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00053	48 8b 51 50	 mov	 rdx, QWORD PTR [rcx+80]
  00057	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  0005c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00060	ff 50 38	 call	 QWORD PTR [rax+56]
  00063	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00068	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 395  : 				token->textState	= ANTLR3_TEXT_STRING;

  0006c	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00071	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 396  : 				return token->tokText.text;

  00078	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0007d	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00081	e9 cb 00 00 00	 jmp	 $LN1@getText

; 397  : 			}

  00086	eb 07		 jmp	 SHORT $LN7@getText
$LN6@getText:

; 398  : 			else
; 399  : 			{
; 400  : 				// We cannot do anything here
; 401  : 				//
; 402  : 				return NULL;

  00088	33 c0		 xor	 eax, eax
  0008a	e9 c2 00 00 00	 jmp	 $LN1@getText
$LN7@getText:

; 403  : 			}
; 404  : 			break;

  0008f	e9 bd 00 00 00	 jmp	 $LN2@getText
$LN8@getText:

; 405  : 
; 406  : 		default:
; 407  : 
; 408  : 			// EOF is a special case
; 409  : 			//
; 410  : 			if (token->type == ANTLR3_TOKEN_EOF)

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00099	83 38 ff	 cmp	 DWORD PTR [rax], -1	; ffffffffH
  0009c	75 51		 jne	 SHORT $LN9@getText

; 411  : 			{
; 412  : 				token->tokText.text				= token->strFactory->newStr8(token->strFactory, (pANTLR3_UINT8)"<EOF>");

  0009e	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000a3	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05FLDDOMNH@?$DMEOF?$DO@
  000ae	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000b3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b7	ff 50 38	 call	 QWORD PTR [rax+56]
  000ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000bf	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 413  : 				token->textState				= ANTLR3_TEXT_STRING;

  000c3	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000c8	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 414  : 				token->tokText.text->factory	= token->strFactory;

  000cf	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000d4	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  000dd	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000e1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 415  : 				return token->tokText.text;

  000e4	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000e9	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000ed	eb 62		 jmp	 SHORT $LN1@getText
$LN9@getText:

; 416  : 			}
; 417  : 
; 418  : 
; 419  : 			// We had nothing installed in the token, create a new string
; 420  : 			// from the input stream
; 421  : 			//
; 422  : 
; 423  : 			if	(token->input != NULL)

  000ef	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  000f4	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  000f9	74 54		 je	 SHORT $LN10@getText

; 424  : 			{
; 425  : 			
; 426  : 				return	token->input->substr(	token->input, 

  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00100	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  00105	ff 90 f0 00 00
	00		 call	 QWORD PTR [rax+240]
  0010b	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  00110	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00115	48 8b 54 24 50	 mov	 rdx, QWORD PTR token$[rsp]
  0011a	ff 92 e0 00 00
	00		 call	 QWORD PTR [rdx+224]
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR token$[rsp]
  00125	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00129	48 89 4c 24 30	 mov	 QWORD PTR tv142[rsp], rcx
  0012e	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv131[rsp]
  00133	4c 8b c2	 mov	 r8, rdx
  00136	48 8b d0	 mov	 rdx, rax
  00139	48 8b 44 24 50	 mov	 rax, QWORD PTR token$[rsp]
  0013e	48 8b 48 28	 mov	 rcx, QWORD PTR [rax+40]
  00142	48 8b 44 24 30	 mov	 rax, QWORD PTR tv142[rsp]
  00147	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
  0014d	eb 02		 jmp	 SHORT $LN1@getText
$LN10@getText:

; 427  : 												token->getStartIndex(token), 
; 428  :  												token->getStopIndex(token)
; 429  : 											);
; 430  : 			}
; 431  : 
; 432  : 			// Nothing to return, there is no input stream
; 433  : 			//
; 434  : 			return NULL;

  0014f	33 c0		 xor	 eax, eax
$LN2@getText:
$LN1@getText:

; 435  : 			break;
; 436  : 	}
; 437  : }

  00151	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00155	5f		 pop	 rdi
  00156	c3		 ret	 0
getText	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT antlr3SetTokenAPI
_TEXT	SEGMENT
token$ = 16
antlr3SetTokenAPI PROC					; COMDAT

; 350  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 351  :     token->getText		    = getText;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getText
  00012	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 352  :     token->setText		    = setText;

  00016	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText
  00022	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 353  :     token->setText8		    = setText8;

  00029	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setText8
  00035	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 354  :     token->getType		    = getType;

  0003c	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getType
  00048	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 355  :     token->setType		    = setType;

  0004f	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setType
  0005b	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 356  :     token->getLine		    = getLine;

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getLine
  0006e	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 357  :     token->setLine		    = setLine;

  00075	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setLine
  00081	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 358  :     token->setLine		    = setLine;

  00088	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setLine
  00094	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 359  :     token->getCharPositionInLine    = getCharPositionInLine;

  0009b	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getCharPositionInLine
  000a7	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 360  :     token->setCharPositionInLine    = setCharPositionInLine;

  000ae	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setCharPositionInLine
  000ba	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 361  :     token->getChannel		    = getChannel;

  000c1	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getChannel
  000cd	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 362  :     token->setChannel		    = setChannel;

  000d4	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setChannel
  000e0	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 363  :     token->getTokenIndex	    = getTokenIndex;

  000e7	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getTokenIndex
  000f3	48 89 88 d0 00
	00 00		 mov	 QWORD PTR [rax+208], rcx

; 364  :     token->setTokenIndex	    = setTokenIndex;

  000fa	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setTokenIndex
  00106	48 89 88 d8 00
	00 00		 mov	 QWORD PTR [rax+216], rcx

; 365  :     token->getStartIndex	    = getStartIndex;

  0010d	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getStartIndex
  00119	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx

; 366  :     token->setStartIndex	    = setStartIndex;

  00120	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setStartIndex
  0012c	48 89 88 e8 00
	00 00		 mov	 QWORD PTR [rax+232], rcx

; 367  :     token->getStopIndex		    = getStopIndex;

  00133	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:getStopIndex
  0013f	48 89 88 f0 00
	00 00		 mov	 QWORD PTR [rax+240], rcx

; 368  :     token->setStopIndex		    = setStopIndex;

  00146	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setStopIndex
  00152	48 89 88 f8 00
	00 00		 mov	 QWORD PTR [rax+248], rcx

; 369  :     token->toString		    = toString;

  00159	48 8b 44 24 10	 mov	 rax, QWORD PTR token$[rsp]
  0015e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toString
  00165	48 89 88 00 01
	00 00		 mov	 QWORD PTR [rax+256], rcx

; 370  : 
; 371  :     return;
; 372  : }

  0016c	5f		 pop	 rdi
  0016d	c3		 ret	 0
antlr3SetTokenAPI ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT antlr3TokenFactoryNew
_TEXT	SEGMENT
factory$ = 32
input$ = 64
antlr3TokenFactoryNew PROC				; COMDAT

; 93   : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 94   :     pANTLR3_TOKEN_FACTORY   factory;
; 95   : 
; 96   :     /* allocate memory
; 97   :      */
; 98   :     factory	= (pANTLR3_TOKEN_FACTORY) ANTLR3_MALLOC((size_t)sizeof(ANTLR3_TOKEN_FACTORY));

  0000a	b9 48 01 00 00	 mov	 ecx, 328		; 00000148H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 99   : 
; 100  :     if	(factory == NULL)

  0001a	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@antlr3Toke

; 101  :     {
; 102  : 	return	NULL;

  00022	33 c0		 xor	 eax, eax
  00024	e9 a8 00 00 00	 jmp	 $LN1@antlr3Toke
$LN2@antlr3Toke:

; 103  :     }
; 104  : 
; 105  :     /* Install factory API
; 106  :      */
; 107  :     factory->newToken	    = newPoolToken;

  00029	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPoolToken
  00035	48 89 88 28 01
	00 00		 mov	 QWORD PTR [rax+296], rcx

; 108  :     factory->close	    = factoryClose;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:factoryClose
  00048	48 89 88 40 01
	00 00		 mov	 QWORD PTR [rax+320], rcx

; 109  :     factory->setInputStream = setInputStream;

  0004f	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00054	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setInputStream
  0005b	48 89 88 38 01
	00 00		 mov	 QWORD PTR [rax+312], rcx

; 110  :     factory->reset          = factoryReset;

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:factoryReset
  0006e	48 89 88 30 01
	00 00		 mov	 QWORD PTR [rax+304], rcx

; 111  :     
; 112  :     /* Allocate the initial pool
; 113  :      */
; 114  :     factory->thisPool	= -1;

  00075	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0007a	c7 40 08 ff ff
	ff ff		 mov	 DWORD PTR [rax+8], -1

; 115  :     factory->pools      = NULL;

  00081	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00086	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 116  :     factory->maxPool    = -1;

  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00092	c7 40 0c ff ff
	ff ff		 mov	 DWORD PTR [rax+12], -1

; 117  :     newPool(factory);

  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  0009e	e8 00 00 00 00	 call	 newPool

; 118  : 
; 119  :     /* Factory space is good, we now want to initialize our cheating token
; 120  :      * which one it is initialized is the model for all tokens we manufacture
; 121  :      */
; 122  :     antlr3SetTokenAPI(&factory->unTruc);

  000a3	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000a8	48 83 c0 18	 add	 rax, 24
  000ac	48 8b c8	 mov	 rcx, rax
  000af	e8 00 00 00 00	 call	 antlr3SetTokenAPI

; 123  : 
; 124  :     /* Set some initial variables for future copying
; 125  :      */
; 126  :     factory->unTruc.factoryMade	= ANTLR3_TRUE;

  000b4	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000b9	c6 40 1c 01	 mov	 BYTE PTR [rax+28], 1

; 127  : 
; 128  :     // Input stream
; 129  :     //
; 130  :     setInputStream(factory, input);

  000bd	48 8b 54 24 40	 mov	 rdx, QWORD PTR input$[rsp]
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  000c7	e8 00 00 00 00	 call	 setInputStream

; 131  :     
; 132  :     return  factory;

  000cc	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Toke:

; 133  : 
; 134  : }

  000d1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d5	5f		 pop	 rdi
  000d6	c3		 ret	 0
antlr3TokenFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3commontoken.c
;	COMDAT antlr3CommonTokenNew
_TEXT	SEGMENT
token$ = 32
ttype$ = 64
antlr3CommonTokenNew PROC				; COMDAT

; 74   : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 75   : 	pANTLR3_COMMON_TOKEN    token;
; 76   : 
; 77   : 	// Create a raw token with the interface installed
; 78   : 	//
; 79   : 	token   = newToken();

  00009	e8 00 00 00 00	 call	 newToken
  0000e	48 89 44 24 20	 mov	 QWORD PTR token$[rsp], rax

; 80   : 
; 81   : 	if	(token != NULL)

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR token$[rsp], 0
  00019	74 14		 je	 SHORT $LN2@antlr3Comm

; 82   : 	{
; 83   : 		token->setType(token, ttype);

  0001b	8b 54 24 40	 mov	 edx, DWORD PTR ttype$[rsp]
  0001f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR token$[rsp]
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]
  00029	ff 90 98 00 00
	00		 call	 QWORD PTR [rax+152]
$LN2@antlr3Comm:

; 84   : 	}
; 85   : 
; 86   : 	// All good
; 87   : 	//
; 88   : 	return  token;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR token$[rsp]

; 89   : }

  00034	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00038	5f		 pop	 rdi
  00039	c3		 ret	 0
antlr3CommonTokenNew ENDP
_TEXT	ENDS
END
