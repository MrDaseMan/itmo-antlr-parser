; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	e2a
CONST	SEGMENT
trailingBytesForUTF8 DD 00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	01H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	02H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	03H
	DD	04H
	DD	04H
	DD	04H
	DD	04H
	DD	05H
	DD	05H
	DD	05H
	DD	05H
offsetsFromUTF8 DD 00H
	DD	03080H
	DD	0e2080H
	DD	03c82080H
	DD	0fa082080H
	DD	082082080H
	ORG $+8
e2a	DD	00H
	DD	01H
	DD	02H
	DD	03H
	DD	085H
	DD	09H
	DD	086H
	DD	07fH
	DD	087H
	DD	08dH
	DD	08eH
	DD	0bH
	DD	0cH
	DD	0dH
	DD	0eH
	DD	0fH
	DD	010H
	DD	011H
	DD	012H
	DD	013H
	DD	08fH
	DD	0aH
	DD	08H
	DD	097H
	DD	018H
	DD	019H
	DD	09cH
	DD	09dH
	DD	01cH
	DD	01dH
	DD	01eH
	DD	01fH
	DD	080H
	DD	081H
	DD	082H
	DD	083H
	DD	084H
	DD	092H
	DD	017H
	DD	01bH
	DD	088H
	DD	089H
	DD	08aH
	DD	08bH
	DD	08cH
	DD	05H
	DD	06H
	DD	07H
	DD	090H
	DD	091H
	DD	016H
	DD	093H
	DD	094H
	DD	095H
	DD	096H
	DD	04H
	DD	098H
	DD	099H
	DD	09aH
	DD	09bH
	DD	014H
	DD	015H
	DD	09eH
	DD	01aH
	DD	020H
	DD	0a0H
	DD	0e2H
	DD	0e4H
	DD	0e0H
	DD	0e1H
	DD	0e3H
	DD	0e5H
	DD	0e7H
	DD	0f1H
	DD	060H
	DD	02eH
	DD	03cH
	DD	028H
	DD	02bH
	DD	07cH
	DD	026H
	DD	0e9H
	DD	0eaH
	DD	0ebH
	DD	0e8H
	DD	0edH
	DD	0eeH
	DD	0efH
	DD	0ecH
	DD	0dfH
	DD	021H
	DD	024H
	DD	02aH
	DD	029H
	DD	03bH
	DD	09fH
	DD	02dH
	DD	02fH
	DD	0c2H
	DD	0c4H
	DD	0c0H
	DD	0c1H
	DD	0c3H
	DD	0c5H
	DD	0c7H
	DD	0d1H
	DD	05eH
	DD	02cH
	DD	025H
	DD	05fH
	DD	03eH
	DD	03fH
	DD	0f8H
	DD	0c9H
	DD	0caH
	DD	0cbH
	DD	0c8H
	DD	0cdH
	DD	0ceH
	DD	0cfH
	DD	0ccH
	DD	0a8H
	DD	03aH
	DD	023H
	DD	040H
	DD	027H
	DD	03dH
	DD	022H
	DD	0d8H
	DD	061H
	DD	062H
	DD	063H
	DD	064H
	DD	065H
	DD	066H
	DD	067H
	DD	068H
	DD	069H
	DD	0abH
	DD	0bbH
	DD	0f0H
	DD	0fdH
	DD	0feH
	DD	0b1H
	DD	0b0H
	DD	06aH
	DD	06bH
	DD	06cH
	DD	06dH
	DD	06eH
	DD	06fH
	DD	070H
	DD	071H
	DD	072H
	DD	0aaH
	DD	0baH
	DD	0e6H
	DD	0b8H
	DD	0c6H
	DD	0a4H
	DD	0b5H
	DD	0afH
	DD	073H
	DD	074H
	DD	075H
	DD	076H
	DD	077H
	DD	078H
	DD	079H
	DD	07aH
	DD	0a1H
	DD	0bfH
	DD	0d0H
	DD	0ddH
	DD	0deH
	DD	0aeH
	DD	0a2H
	DD	0a3H
	DD	0a5H
	DD	0b7H
	DD	0a9H
	DD	0a7H
	DD	0b6H
	DD	0bcH
	DD	0bdH
	DD	0beH
	DD	0acH
	DD	05bH
	DD	05cH
	DD	05dH
	DD	0b4H
	DD	0d7H
	DD	0f9H
	DD	041H
	DD	042H
	DD	043H
	DD	044H
	DD	045H
	DD	046H
	DD	047H
	DD	048H
	DD	049H
	DD	0adH
	DD	0f4H
	DD	0f6H
	DD	0f2H
	DD	0f3H
	DD	0f5H
	DD	0a6H
	DD	04aH
	DD	04bH
	DD	04cH
	DD	04dH
	DD	04eH
	DD	04fH
	DD	050H
	DD	051H
	DD	052H
	DD	0b9H
	DD	0fbH
	DD	0fcH
	DD	0dbH
	DD	0faH
	DD	0ffH
	DD	0d9H
	DD	0f7H
	DD	053H
	DD	054H
	DD	055H
	DD	056H
	DD	057H
	DD	058H
	DD	059H
	DD	05aH
	DD	0b2H
	DD	0d4H
	DD	0d6H
	DD	0d2H
	DD	0d3H
	DD	0d5H
	DD	030H
	DD	031H
	DD	032H
	DD	033H
	DD	034H
	DD	035H
	DD	036H
	DD	037H
	DD	038H
	DD	039H
	DD	0b3H
	DD	07bH
	DD	0dcH
	DD	07dH
	DD	0daH
	DD	07eH
CONST	ENDS
PUBLIC	antlr38BitSetupStream
PUBLIC	antlr3UTF16SetupStream
PUBLIC	antlr3UTF32SetupStream
PUBLIC	antlr3UTF8SetupStream
PUBLIC	antlr3EBCDICSetupStream
PUBLIC	antlr3GenericSetupStream
PUBLIC	??_C@_08ONBMMFLC@?9memory?9@			; `string'
EXTRN	__imp_toupper:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	antlr3IntStreamNew:PROC
EXTRN	antlr3StringFactoryNew:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetupStream DD imagerel $LN3
	DD	imagerel $LN3+41
	DD	imagerel $unwind$antlr38BitSetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16SetupStream DD imagerel $LN11
	DD	imagerel $LN11+324
	DD	imagerel $unwind$antlr3UTF16SetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32SetupStream DD imagerel $LN11
	DD	imagerel $LN11+264
	DD	imagerel $unwind$antlr3UTF32SetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF8SetupStream DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$antlr3UTF8SetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EBCDICSetupStream DD imagerel $LN3
	DD	imagerel $LN3+72
	DD	imagerel $unwind$antlr3EBCDICSetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3GenericSetupStream DD imagerel $LN3
	DD	imagerel $LN3+544
	DD	imagerel $unwind$antlr3GenericSetupStream
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitConsume DD imagerel antlr38BitConsume
	DD	imagerel antlr38BitConsume+158
	DD	imagerel $unwind$antlr38BitConsume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitLA DD imagerel antlr38BitLA
	DD	imagerel antlr38BitLA+98
	DD	imagerel $unwind$antlr38BitLA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitLA_ucase DD imagerel antlr38BitLA_ucase
	DD	imagerel antlr38BitLA_ucase+111
	DD	imagerel $unwind$antlr38BitLA_ucase
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitIndex DD imagerel antlr38BitIndex
	DD	imagerel antlr38BitIndex+37
	DD	imagerel $unwind$antlr38BitIndex
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitMark DD imagerel antlr38BitMark
	DD	imagerel antlr38BitMark+300
	DD	imagerel $unwind$antlr38BitMark
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitRewind DD imagerel antlr38BitRewind
	DD	imagerel antlr38BitRewind+203
	DD	imagerel $unwind$antlr38BitRewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitRewindLast DD imagerel antlr38BitRewindLast
	DD	imagerel antlr38BitRewindLast+38
	DD	imagerel $unwind$antlr38BitRewindLast
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitRelease DD imagerel antlr38BitRelease
	DD	imagerel antlr38BitRelease+49
	DD	imagerel $unwind$antlr38BitRelease
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSeek DD imagerel antlr38BitSeek
	DD	imagerel antlr38BitSeek+131
	DD	imagerel $unwind$antlr38BitSeek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetSourceName DD imagerel antlr38BitGetSourceName
	DD	imagerel antlr38BitGetSourceName+17
	DD	imagerel $unwind$antlr38BitGetSourceName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3InputClose DD imagerel antlr3InputClose
	DD	imagerel antlr3InputClose+179
	DD	imagerel $unwind$antlr3InputClose
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3InputReset DD imagerel antlr3InputReset
	DD	imagerel antlr3InputReset+142
	DD	imagerel $unwind$antlr3InputReset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitReuse DD imagerel antlr38BitReuse
	DD	imagerel antlr38BitReuse+264
	DD	imagerel $unwind$antlr38BitReuse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitLT DD imagerel antlr38BitLT
	DD	imagerel antlr38BitLT+45
	DD	imagerel $unwind$antlr38BitLT
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSize DD imagerel antlr38BitSize
	DD	imagerel antlr38BitSize+16
	DD	imagerel $unwind$antlr38BitSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSubstr DD imagerel antlr38BitSubstr
	DD	imagerel antlr38BitSubstr+84
	DD	imagerel $unwind$antlr38BitSubstr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetLine DD imagerel antlr38BitGetLine
	DD	imagerel antlr38BitGetLine+16
	DD	imagerel $unwind$antlr38BitGetLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetLineBuf DD imagerel antlr38BitGetLineBuf
	DD	imagerel antlr38BitGetLineBuf+17
	DD	imagerel $unwind$antlr38BitGetLineBuf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitGetCharPosition DD imagerel antlr38BitGetCharPosition
	DD	imagerel antlr38BitGetCharPosition+16
	DD	imagerel $unwind$antlr38BitGetCharPosition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetLine DD imagerel antlr38BitSetLine
	DD	imagerel antlr38BitSetLine+24
	DD	imagerel $unwind$antlr38BitSetLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetCharPosition DD imagerel antlr38BitSetCharPosition
	DD	imagerel antlr38BitSetCharPosition+24
	DD	imagerel $unwind$antlr38BitSetCharPosition
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetNewLineChar DD imagerel antlr38BitSetNewLineChar
	DD	imagerel antlr38BitSetNewLineChar+27
	DD	imagerel $unwind$antlr38BitSetNewLineChar
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr38BitSetUcaseLA DD imagerel antlr38BitSetUcaseLA
	DD	imagerel antlr38BitSetUcaseLA+61
	DD	imagerel $unwind$antlr38BitSetUcaseLA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Consume DD imagerel antlr3UTF16Consume
	DD	imagerel antlr3UTF16Consume+279
	DD	imagerel $unwind$antlr3UTF16Consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16LA DD imagerel antlr3UTF16LA
	DD	imagerel antlr3UTF16LA+552
	DD	imagerel $unwind$antlr3UTF16LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16ConsumeLE DD imagerel antlr3UTF16ConsumeLE
	DD	imagerel antlr3UTF16ConsumeLE+313
	DD	imagerel $unwind$antlr3UTF16ConsumeLE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16LALE DD imagerel antlr3UTF16LALE
	DD	imagerel antlr3UTF16LALE+632
	DD	imagerel $unwind$antlr3UTF16LALE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16ConsumeBE DD imagerel antlr3UTF16ConsumeBE
	DD	imagerel antlr3UTF16ConsumeBE+313
	DD	imagerel $unwind$antlr3UTF16ConsumeBE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16LABE DD imagerel antlr3UTF16LABE
	DD	imagerel antlr3UTF16LABE+638
	DD	imagerel $unwind$antlr3UTF16LABE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Index DD imagerel antlr3UTF16Index
	DD	imagerel antlr3UTF16Index+37
	DD	imagerel $unwind$antlr3UTF16Index
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Seek DD imagerel antlr3UTF16Seek
	DD	imagerel antlr3UTF16Seek+121
	DD	imagerel $unwind$antlr3UTF16Seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF16Substr DD imagerel antlr3UTF16Substr
	DD	imagerel antlr3UTF16Substr+92
	DD	imagerel $unwind$antlr3UTF16Substr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Consume DD imagerel antlr3UTF32Consume
	DD	imagerel antlr3UTF32Consume+159
	DD	imagerel $unwind$antlr3UTF32Consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32LA DD imagerel antlr3UTF32LA
	DD	imagerel antlr3UTF32LA+97
	DD	imagerel $unwind$antlr3UTF32LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32LALE DD imagerel antlr3UTF32LALE
	DD	imagerel antlr3UTF32LALE+147
	DD	imagerel $unwind$antlr3UTF32LALE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32LABE DD imagerel antlr3UTF32LABE
	DD	imagerel antlr3UTF32LABE+147
	DD	imagerel $unwind$antlr3UTF32LABE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Index DD imagerel antlr3UTF32Index
	DD	imagerel antlr3UTF32Index+37
	DD	imagerel $unwind$antlr3UTF32Index
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Seek DD imagerel antlr3UTF32Seek
	DD	imagerel antlr3UTF32Seek+121
	DD	imagerel $unwind$antlr3UTF32Seek
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF32Substr DD imagerel antlr3UTF32Substr
	DD	imagerel antlr3UTF32Substr+92
	DD	imagerel $unwind$antlr3UTF32Substr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF8Consume DD imagerel antlr3UTF8Consume
	DD	imagerel antlr3UTF8Consume+592
	DD	imagerel $unwind$antlr3UTF8Consume
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3UTF8LA DD imagerel antlr3UTF8LA
	DD	imagerel antlr3UTF8LA+720
	DD	imagerel $unwind$antlr3UTF8LA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3EBCDICLA DD imagerel antlr3EBCDICLA
	DD	imagerel antlr3EBCDICLA+108
	DD	imagerel $unwind$antlr3EBCDICLA
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_08ONBMMFLC@?9memory?9@
CONST	SEGMENT
??_C@_08ONBMMFLC@?9memory?9@ DB '-memory-', 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EBCDICLA DD 020e01H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF8LA DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF8Consume DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Substr DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Seek DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Index DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32LABE DD 020e01H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32LALE DD 020e01H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32LA DD 020e01H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32Consume DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Substr DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Seek DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Index DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16LABE DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16ConsumeBE DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16LALE DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16ConsumeLE DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16LA DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16Consume DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetUcaseLA DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetNewLineChar DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetCharPosition DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetLine DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetCharPosition DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetLineBuf DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetLine DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSubstr DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSize DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitLT DD 020e01H
	DD	0700a320eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitReuse DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3InputReset DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3InputClose DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitGetSourceName DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSeek DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitRelease DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitRewindLast DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitRewind DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitMark DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitIndex DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitLA_ucase DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitLA DD 020e01H
	DD	0700a120eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitConsume DD 020a01H
	DD	07006120aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3GenericSetupStream DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3EBCDICSetupStream DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF8SetupStream DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF32SetupStream DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3UTF16SetupStream DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr38BitSetupStream DD 020a01H
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3EBCDICLA
_TEXT	SEGMENT
input$ = 0
is$ = 32
la$ = 40
antlr3EBCDICLA PROC					; COMDAT

; 2042 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16

; 2043 :     pANTLR3_INPUT_STREAM input;
; 2044 : 
; 2045 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 2046 : 
; 2047 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001b	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00020	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00024	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00028	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0002d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00031	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00034	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00038	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	72 09		 jb	 SHORT $LN2@antlr3EBCD

; 2048 :     {
; 2049 :         return	ANTLR3_CHARSTREAM_EOF;

  00041	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00046	eb 1e		 jmp	 SHORT $LN1@antlr3EBCD

; 2050 :     }

  00048	eb 1c		 jmp	 SHORT $LN3@antlr3EBCD
$LN2@antlr3EBCD:

; 2051 :     else
; 2052 :     {
; 2053 :         // Translate the required character via the constant conversion table
; 2054 :         //
; 2055 :         return	e2a[(*((pANTLR3_UINT8)input->nextChar + la - 1))];

  0004a	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00057	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:e2a
  00063	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
$LN3@antlr3EBCD:
$LN1@antlr3EBCD:

; 2056 :     }
; 2057 : }

  00066	48 83 c4 10	 add	 rsp, 16
  0006a	5f		 pop	 rdi
  0006b	c3		 ret	 0
antlr3EBCDICLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF8LA
_TEXT	SEGMENT
input$ = 0
extraBytesToRead$ = 8
ch$ = 12
nextChar$ = 16
tv89 = 24
tv90 = 28
tv139 = 32
is$ = 64
la$ = 72
antlr3UTF8LA PROC					; COMDAT

; 1878 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1879 :     pANTLR3_INPUT_STREAM    input;
; 1880 :     ANTLR3_UINT32           extraBytesToRead;
; 1881 :     ANTLR3_UCHAR            ch;
; 1882 :     pANTLR3_UINT8           nextChar;
; 1883 : 
; 1884 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1885 : 
; 1886 :     nextChar = (pANTLR3_UINT8)input->nextChar;

  0001b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00023	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1887 : 
; 1888 :     // Do we need to traverse forwards or backwards?
; 1889 :     // - LA(0) is treated as LA(1) and we assume that the nextChar is
; 1890 :     //   already positioned.
; 1891 :     // - LA(n+) ; n>1 means we must traverse forward n-1 characters catering for UTF8 encoding
; 1892 :     // - LA(-n) means we must traverse backwards n chracters
; 1893 :     //
; 1894 :     if (la > 1) {

  00028	83 7c 24 48 01	 cmp	 DWORD PTR la$[rsp], 1
  0002d	7e 7d		 jle	 SHORT $LN10@antlr3UTF8

; 1895 : 
; 1896 :         // Make sure that we have at least one character left before trying to
; 1897 :         // loop through the buffer.
; 1898 :         //
; 1899 :         if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0002f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00033	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00036	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003a	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0003e	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00043	73 5b		 jae	 SHORT $LN12@antlr3UTF8
$LN2@antlr3UTF8:

; 1900 :         {	
; 1901 :             // Now traverse n-1 characters forward
; 1902 :             //
; 1903 :             while (--la > 0)

  00045	8b 44 24 48	 mov	 eax, DWORD PTR la$[rsp]
  00049	ff c8		 dec	 eax
  0004b	89 44 24 48	 mov	 DWORD PTR la$[rsp], eax
  0004f	83 7c 24 48 00	 cmp	 DWORD PTR la$[rsp], 0
  00054	7e 48		 jle	 SHORT $LN3@antlr3UTF8

; 1904 :             {
; 1905 :                 // Does the next character require trailing bytes?
; 1906 :                 // If so advance the pointer by that many bytes as well as advancing
; 1907 :                 // one position for what will be at least a single byte character.
; 1908 :                 //
; 1909 :                 nextChar += trailingBytesForUTF8[*nextChar] + 1;

  00056	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0005b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  00065	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00068	ff c0		 inc	 eax
  0006a	8b c0		 mov	 eax, eax
  0006c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00071	48 03 c8	 add	 rcx, rax
  00074	48 8b c1	 mov	 rax, rcx
  00077	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1910 : 
; 1911 :                 // Does that calculation take us past the byte length of the buffer?
; 1912 :                 //
; 1913 :                 if	(nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0007c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00080	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00083	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00087	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0008b	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00090	72 0a		 jb	 SHORT $LN14@antlr3UTF8

; 1914 :                 {
; 1915 :                     return ANTLR3_CHARSTREAM_EOF;

  00092	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00097	e9 13 02 00 00	 jmp	 $LN1@antlr3UTF8
$LN14@antlr3UTF8:

; 1916 :                 }
; 1917 :             }

  0009c	eb a7		 jmp	 SHORT $LN2@antlr3UTF8
$LN3@antlr3UTF8:

; 1918 :         }

  0009e	eb 0a		 jmp	 SHORT $LN13@antlr3UTF8
$LN12@antlr3UTF8:

; 1919 :         else
; 1920 :         {
; 1921 :             return ANTLR3_CHARSTREAM_EOF;

  000a0	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  000a5	e9 05 02 00 00	 jmp	 $LN1@antlr3UTF8
$LN13@antlr3UTF8:

; 1922 :         }
; 1923 :     }

  000aa	eb 73		 jmp	 SHORT $LN11@antlr3UTF8
$LN10@antlr3UTF8:
$LN4@antlr3UTF8:

; 1924 :     else
; 1925 :     {
; 1926 :         // LA is negative so we decrease the pointer by n character positions
; 1927 :         //
; 1928 :         while   (nextChar > (pANTLR3_UINT8)input->data && la++ < 0)

  000ac	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000b0	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000b4	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000b9	76 64		 jbe	 SHORT $LN5@antlr3UTF8
  000bb	8b 44 24 48	 mov	 eax, DWORD PTR la$[rsp]
  000bf	89 44 24 18	 mov	 DWORD PTR tv89[rsp], eax
  000c3	8b 44 24 48	 mov	 eax, DWORD PTR la$[rsp]
  000c7	ff c0		 inc	 eax
  000c9	89 44 24 48	 mov	 DWORD PTR la$[rsp], eax
  000cd	83 7c 24 18 00	 cmp	 DWORD PTR tv89[rsp], 0
  000d2	7d 0a		 jge	 SHORT $LN23@antlr3UTF8
  000d4	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000dc	eb 08		 jmp	 SHORT $LN24@antlr3UTF8
$LN23@antlr3UTF8:
  000de	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN24@antlr3UTF8:
  000e6	83 7c 24 1c 00	 cmp	 DWORD PTR tv90[rsp], 0
  000eb	74 32		 je	 SHORT $LN5@antlr3UTF8

; 1929 :         {
; 1930 :             // Traversing backwards in UTF8 means decermenting by one
; 1931 :             // then continuing to decrement while ever a character pattern
; 1932 :             // is flagged as being a trailing byte of an encoded code point.
; 1933 :             // Trailing UTF8 bytes always start with 10 in binary. We assumne that
; 1934 :             // the UTF8 is well formed and do not check boundary conditions
; 1935 :             //
; 1936 :             nextChar--;

  000ed	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000f2	48 ff c8	 dec	 rax
  000f5	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN6@antlr3UTF8:

; 1937 :             while ((*nextChar & 0xC0) == 0x80)

  000fa	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000ff	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00102	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00107	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0010c	75 0f		 jne	 SHORT $LN7@antlr3UTF8

; 1938 :             {
; 1939 :                 nextChar--;

  0010e	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00113	48 ff c8	 dec	 rax
  00116	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1940 :             }

  0011b	eb dd		 jmp	 SHORT $LN6@antlr3UTF8
$LN7@antlr3UTF8:

; 1941 :         }

  0011d	eb 8d		 jmp	 SHORT $LN4@antlr3UTF8
$LN5@antlr3UTF8:
$LN11@antlr3UTF8:

; 1942 :     }
; 1943 : 
; 1944 :     // nextChar is now pointing at the UTF8 encoded character that we need to
; 1945 :     // decode and return.
; 1946 :     //
; 1947 :     // Are there more bytes needed to make up the whole thing?
; 1948 :     //
; 1949 :     extraBytesToRead = trailingBytesForUTF8[*nextChar];

  0011f	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00124	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  0012e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00131	89 44 24 08	 mov	 DWORD PTR extraBytesToRead$[rsp], eax

; 1950 :     if	(nextChar + extraBytesToRead >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00135	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  00139	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0013e	48 03 c8	 add	 rcx, rax
  00141	48 8b c1	 mov	 rax, rcx
  00144	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00148	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  0014b	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0014f	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00153	48 3b c1	 cmp	 rax, rcx
  00156	72 0a		 jb	 SHORT $LN15@antlr3UTF8

; 1951 :     {
; 1952 :         return ANTLR3_CHARSTREAM_EOF;

  00158	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0015d	e9 4d 01 00 00	 jmp	 $LN1@antlr3UTF8
$LN15@antlr3UTF8:

; 1953 :     }
; 1954 : 
; 1955 :     // Cases deliberately fall through (see note A in antlrconvertutf.c)
; 1956 :     // 
; 1957 :     ch  = 0;

  00162	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR ch$[rsp], 0

; 1958 :     switch (extraBytesToRead) {

  0016a	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  0016e	89 44 24 20	 mov	 DWORD PTR tv139[rsp], eax
  00172	83 7c 24 20 05	 cmp	 DWORD PTR tv139[rsp], 5
  00177	0f 87 14 01 00
	00		 ja	 $LN8@antlr3UTF8
  0017d	8b 44 24 20	 mov	 eax, DWORD PTR tv139[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00188	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN25@antlr3UTF8[rcx+rax*4]
  0018f	48 03 c1	 add	 rax, rcx
  00192	ff e0		 jmp	 rax
$LN16@antlr3UTF8:

; 1959 :             case 5: ch += *nextChar++; ch <<= 6;

  00194	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00199	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019c	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001a0	03 c8		 add	 ecx, eax
  001a2	8b c1		 mov	 eax, ecx
  001a4	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001a8	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001ad	48 ff c0	 inc	 rax
  001b0	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  001b5	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  001b9	c1 e0 06	 shl	 eax, 6
  001bc	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF8:

; 1960 :             case 4: ch += *nextChar++; ch <<= 6;

  001c0	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001c5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001c8	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001cc	03 c8		 add	 ecx, eax
  001ce	8b c1		 mov	 eax, ecx
  001d0	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001d4	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001d9	48 ff c0	 inc	 rax
  001dc	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  001e1	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  001e5	c1 e0 06	 shl	 eax, 6
  001e8	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN18@antlr3UTF8:

; 1961 :             case 3: ch += *nextChar++; ch <<= 6;

  001ec	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f4	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001f8	03 c8		 add	 ecx, eax
  001fa	8b c1		 mov	 eax, ecx
  001fc	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00200	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00205	48 ff c0	 inc	 rax
  00208	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0020d	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00211	c1 e0 06	 shl	 eax, 6
  00214	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN19@antlr3UTF8:

; 1962 :             case 2: ch += *nextChar++; ch <<= 6;

  00218	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0021d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00220	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00224	03 c8		 add	 ecx, eax
  00226	8b c1		 mov	 eax, ecx
  00228	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  0022c	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00231	48 ff c0	 inc	 rax
  00234	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00239	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  0023d	c1 e0 06	 shl	 eax, 6
  00240	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN20@antlr3UTF8:

; 1963 :             case 1: ch += *nextChar++; ch <<= 6;

  00244	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00249	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0024c	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00250	03 c8		 add	 ecx, eax
  00252	8b c1		 mov	 eax, ecx
  00254	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00258	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0025d	48 ff c0	 inc	 rax
  00260	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00265	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00269	c1 e0 06	 shl	 eax, 6
  0026c	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN21@antlr3UTF8:

; 1964 :             case 0: ch += *nextChar++;

  00270	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00275	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00278	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  0027c	03 c8		 add	 ecx, eax
  0027e	8b c1		 mov	 eax, ecx
  00280	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00284	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00289	48 ff c0	 inc	 rax
  0028c	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN8@antlr3UTF8:

; 1965 :     }
; 1966 : 
; 1967 :     // Magically correct the input value
; 1968 :     //
; 1969 :     ch -= offsetsFromUTF8[extraBytesToRead];

  00291	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  0029c	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0029f	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  002a3	2b c8		 sub	 ecx, eax
  002a5	8b c1		 mov	 eax, ecx
  002a7	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax

; 1970 : 
; 1971 :     return ch;

  002ab	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF8:

; 1972 : }

  002af	48 83 c4 30	 add	 rsp, 48			; 00000030H
  002b3	5f		 pop	 rdi
  002b4	c3		 ret	 0
  002b5	0f 1f 00	 npad	 3
$LN25@antlr3UTF8:
  002b8	00 00 00 00	 DD	 $LN21@antlr3UTF8
  002bc	00 00 00 00	 DD	 $LN20@antlr3UTF8
  002c0	00 00 00 00	 DD	 $LN19@antlr3UTF8
  002c4	00 00 00 00	 DD	 $LN18@antlr3UTF8
  002c8	00 00 00 00	 DD	 $LN17@antlr3UTF8
  002cc	00 00 00 00	 DD	 $LN16@antlr3UTF8
antlr3UTF8LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF8Consume
_TEXT	SEGMENT
input$ = 0
extraBytesToRead$ = 8
ch$ = 12
nextChar$ = 16
tv90 = 24
is$ = 48
antlr3UTF8Consume PROC					; COMDAT

; 1812 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1813 :     pANTLR3_INPUT_STREAM    input;
; 1814 :     ANTLR3_UINT32           extraBytesToRead;
; 1815 :     ANTLR3_UCHAR            ch;
; 1816 :     pANTLR3_UINT8           nextChar;
; 1817 : 
; 1818 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1819 : 
; 1820 :     nextChar = (pANTLR3_UINT8)input->nextChar;

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0001f	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1821 : 
; 1822 :     if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00024	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00028	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0002b	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0002f	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00033	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00038	0f 83 f3 01 00
	00		 jae	 $LN4@antlr3UTF8

; 1823 :     {	
; 1824 : 	// Indicate one more character in this line
; 1825 : 	//
; 1826 : 	input->charPositionInLine++;

  0003e	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00042	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00045	ff c0		 inc	 eax
  00047	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0004b	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1827 : 	
; 1828 :         // Are there more bytes needed to make up the whole thing?
; 1829 :         //
; 1830 :         extraBytesToRead = trailingBytesForUTF8[*nextChar];

  0004e	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00053	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00056	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:trailingBytesForUTF8
  0005d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00060	89 44 24 08	 mov	 DWORD PTR extraBytesToRead$[rsp], eax

; 1831 : 
; 1832 :         if	(nextChar + extraBytesToRead >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00064	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  00068	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00077	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  0007a	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  0007e	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00082	48 3b c1	 cmp	 rax, rcx
  00085	72 1c		 jb	 SHORT $LN5@antlr3UTF8

; 1833 :         {
; 1834 :             input->nextChar = (((pANTLR3_UINT8)input->data) + input->sizeBuf);

  00087	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0008e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00092	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00096	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0009a	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1835 :             return;

  0009e	e9 8e 01 00 00	 jmp	 $LN1@antlr3UTF8
$LN5@antlr3UTF8:

; 1836 :         }
; 1837 : 
; 1838 :         // Cases deliberately fall through (see note A in antlrconvertutf.c)
; 1839 :         // Legal UTF8 is only 4 bytes but 6 bytes could be used in old UTF8 so
; 1840 :         // we allow it.
; 1841 :         //
; 1842 :         ch  = 0;

  000a3	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR ch$[rsp], 0

; 1843 :        	switch (extraBytesToRead) {

  000ab	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  000af	89 44 24 18	 mov	 DWORD PTR tv90[rsp], eax
  000b3	83 7c 24 18 05	 cmp	 DWORD PTR tv90[rsp], 5
  000b8	0f 87 14 01 00
	00		 ja	 $LN2@antlr3UTF8
  000be	8b 44 24 18	 mov	 eax, DWORD PTR tv90[rsp]
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000c9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN14@antlr3UTF8[rcx+rax*4]
  000d0	48 03 c1	 add	 rax, rcx
  000d3	ff e0		 jmp	 rax
$LN6@antlr3UTF8:

; 1844 : 	    case 5: ch += *nextChar++; ch <<= 6;

  000d5	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000da	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000dd	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  000e1	03 c8		 add	 ecx, eax
  000e3	8b c1		 mov	 eax, ecx
  000e5	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  000e9	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000ee	48 ff c0	 inc	 rax
  000f1	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  000f6	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  000fa	c1 e0 06	 shl	 eax, 6
  000fd	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN7@antlr3UTF8:

; 1845 : 	    case 4: ch += *nextChar++; ch <<= 6;

  00101	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00106	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00109	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  0010d	03 c8		 add	 ecx, eax
  0010f	8b c1		 mov	 eax, ecx
  00111	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00115	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0011a	48 ff c0	 inc	 rax
  0011d	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00122	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00126	c1 e0 06	 shl	 eax, 6
  00129	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN8@antlr3UTF8:

; 1846 : 	    case 3: ch += *nextChar++; ch <<= 6;

  0012d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00132	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00135	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00139	03 c8		 add	 ecx, eax
  0013b	8b c1		 mov	 eax, ecx
  0013d	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00141	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00146	48 ff c0	 inc	 rax
  00149	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0014e	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  00152	c1 e0 06	 shl	 eax, 6
  00155	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN9@antlr3UTF8:

; 1847 : 	    case 2: ch += *nextChar++; ch <<= 6;

  00159	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0015e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00161	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00165	03 c8		 add	 ecx, eax
  00167	8b c1		 mov	 eax, ecx
  00169	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  0016d	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00172	48 ff c0	 inc	 rax
  00175	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  0017a	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  0017e	c1 e0 06	 shl	 eax, 6
  00181	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN10@antlr3UTF8:

; 1848 : 	    case 1: ch += *nextChar++; ch <<= 6;

  00185	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0018a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018d	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  00191	03 c8		 add	 ecx, eax
  00193	8b c1		 mov	 eax, ecx
  00195	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  00199	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0019e	48 ff c0	 inc	 rax
  001a1	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  001a6	8b 44 24 0c	 mov	 eax, DWORD PTR ch$[rsp]
  001aa	c1 e0 06	 shl	 eax, 6
  001ad	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
$LN11@antlr3UTF8:

; 1849 : 	    case 0: ch += *nextChar++;

  001b1	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001b6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b9	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001bd	03 c8		 add	 ecx, eax
  001bf	8b c1		 mov	 eax, ecx
  001c1	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax
  001c5	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001ca	48 ff c0	 inc	 rax
  001cd	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN2@antlr3UTF8:

; 1850 : 	}
; 1851 : 
; 1852 :         // Magically correct the input value
; 1853 :         //
; 1854 : 	ch -= offsetsFromUTF8[extraBytesToRead];

  001d2	8b 44 24 08	 mov	 eax, DWORD PTR extraBytesToRead$[rsp]
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:offsetsFromUTF8
  001dd	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001e0	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch$[rsp]
  001e4	2b c8		 sub	 ecx, eax
  001e6	8b c1		 mov	 eax, ecx
  001e8	89 44 24 0c	 mov	 DWORD PTR ch$[rsp], eax

; 1855 : 	if  (ch == input->newlineChar)

  001ec	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001f0	8b 80 d0 00 00
	00		 mov	 eax, DWORD PTR [rax+208]
  001f6	39 44 24 0c	 cmp	 DWORD PTR ch$[rsp], eax
  001fa	75 28		 jne	 SHORT $LN12@antlr3UTF8

; 1856 : 	{
; 1857 : 	    /* Reset for start of a new line of input
; 1858 : 	     */
; 1859 : 	    input->line++;

  001fc	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00200	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00203	ff c0		 inc	 eax
  00205	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00209	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1860 : 	    input->charPositionInLine	= 0;

  0020c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00210	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1861 : 	    input->currentLine		= (void *)nextChar;

  00217	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0021b	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00220	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN12@antlr3UTF8:

; 1862 : 	}
; 1863 : 
; 1864 :         // Update input pointer
; 1865 :         //
; 1866 :         input->nextChar = nextChar;

  00224	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00228	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0022d	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN4@antlr3UTF8:
$LN1@antlr3UTF8:

; 1867 :     }
; 1868 : }

  00231	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00235	5f		 pop	 rdi
  00236	c3		 ret	 0
  00237	90		 npad	 1
$LN14@antlr3UTF8:
  00238	00 00 00 00	 DD	 $LN11@antlr3UTF8
  0023c	00 00 00 00	 DD	 $LN10@antlr3UTF8
  00240	00 00 00 00	 DD	 $LN9@antlr3UTF8
  00244	00 00 00 00	 DD	 $LN8@antlr3UTF8
  00248	00 00 00 00	 DD	 $LN7@antlr3UTF8
  0024c	00 00 00 00	 DD	 $LN6@antlr3UTF8
antlr3UTF8Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Substr
_TEXT	SEGMENT
tv75 = 32
input$ = 64
start$ = 72
stop$ = 80
antlr3UTF32Substr PROC					; COMDAT

; 1628 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1629 :     return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, ((ANTLR3_UINT32_CAST(stop - start))/4) + 1);

  00014	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  0001e	48 2b c8	 sub	 rcx, rax
  00021	48 8b c1	 mov	 rax, rcx
  00024	33 d2		 xor	 edx, edx
  00026	b9 04 00 00 00	 mov	 ecx, 4
  0002b	f7 f1		 div	 ecx
  0002d	ff c0		 inc	 eax
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00034	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00038	48 89 4c 24 20	 mov	 QWORD PTR tv75[rsp], rcx
  0003d	44 8b c0	 mov	 r8d, eax
  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0004a	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv75[rsp]
  00053	ff 50 20	 call	 QWORD PTR [rax+32]

; 1630 : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
antlr3UTF32Substr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Seek
_TEXT	SEGMENT
input$ = 32
is$ = 64
seekPoint$ = 72
antlr3UTF32Seek PROC					; COMDAT

; 1641 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1642 : 	pANTLR3_INPUT_STREAM input;
; 1643 : 
; 1644 : 	input   = ((pANTLR3_INPUT_STREAM) is->super);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1645 : 
; 1646 : 	// If the requested seek point is less than the current
; 1647 : 	// input point, then we assume that we are resetting from a mark
; 1648 : 	// and do not need to scan, but can just set to there as rewind will
; 1649 :         // reset line numbers and so on.
; 1650 : 	//
; 1651 : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00022	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00026	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  0002b	7f 10		 jg	 SHORT $LN4@antlr3UTF3

; 1652 : 	{
; 1653 : 		input->nextChar	= (void *)seekPoint;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  00037	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1654 : 	}

  0003b	eb 36		 jmp	 SHORT $LN5@antlr3UTF3
$LN4@antlr3UTF3:
$LN2@antlr3UTF3:

; 1655 : 	else
; 1656 : 	{
; 1657 :             // Call consume until we reach the asked for seek point or EOF
; 1658 :             //
; 1659 :             while (is->_LA(is, 1) != ANTLR3_CHARSTREAM_EOF && seekPoint < (ANTLR3_MARKER)input->nextChar)

  0003d	ba 01 00 00 00	 mov	 edx, 1
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0004c	ff 50 30	 call	 QWORD PTR [rax+48]
  0004f	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00052	74 1f		 je	 SHORT $LN3@antlr3UTF3
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00059	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005d	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  00062	7d 0f		 jge	 SHORT $LN3@antlr3UTF3

; 1660 : 	    {
; 1661 : 		is->consume(is);

  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0006e	ff 50 28	 call	 QWORD PTR [rax+40]

; 1662 : 	    }

  00071	eb ca		 jmp	 SHORT $LN2@antlr3UTF3
$LN3@antlr3UTF3:
$LN5@antlr3UTF3:

; 1663 : 	}
; 1664 : }

  00073	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
antlr3UTF32Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Index
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr3UTF32Index PROC					; COMDAT

; 1611 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 1612 :     pANTLR3_INPUT_STREAM input;
; 1613 : 
; 1614 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1615 : 
; 1616 :     return  (ANTLR3_MARKER)(input->nextChar);

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 1617 : }

  0001f	48 83 c4 10	 add	 rsp, 16
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
antlr3UTF32Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32LABE
_TEXT	SEGMENT
input$ = 0
c$1 = 8
is$ = 32
la$ = 40
antlr3UTF32LABE PROC					; COMDAT

; 1730 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16

; 1731 :     pANTLR3_INPUT_STREAM input;
; 1732 : 	
; 1733 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1734 : 
; 1735 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001b	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00020	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00024	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00028	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0002d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00031	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00034	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00038	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	72 09		 jb	 SHORT $LN2@antlr3UTF3

; 1736 :     {
; 1737 : 		return	ANTLR3_CHARSTREAM_EOF;

  00041	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00046	eb 45		 jmp	 SHORT $LN1@antlr3UTF3

; 1738 :     }

  00048	eb 43		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1739 :     else
; 1740 :     {
; 1741 :         ANTLR3_UCHAR   c;
; 1742 : 
; 1743 :         c = (ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  0004a	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00057	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
  0005b	89 44 24 08	 mov	 DWORD PTR c$1[rsp], eax

; 1744 : 
; 1745 :         // Swap Endianess to Little Endian
; 1746 :         //
; 1747 :         return (c>>24) | ((c<<8) & 0x00FF0000) | ((c>>8) & 0x0000FF00) | (c<<24);

  0005f	8b 44 24 08	 mov	 eax, DWORD PTR c$1[rsp]
  00063	c1 e8 18	 shr	 eax, 24
  00066	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0006a	c1 e1 08	 shl	 ecx, 8
  0006d	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00073	0b c1		 or	 eax, ecx
  00075	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  00079	c1 e9 08	 shr	 ecx, 8
  0007c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00082	0b c1		 or	 eax, ecx
  00084	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  00088	c1 e1 18	 shl	 ecx, 24
  0008b	0b c1		 or	 eax, ecx
$LN3@antlr3UTF3:
$LN1@antlr3UTF3:

; 1748 :     }
; 1749 : }

  0008d	48 83 c4 10	 add	 rsp, 16
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
antlr3UTF32LABE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32LALE
_TEXT	SEGMENT
input$ = 0
c$1 = 8
is$ = 32
la$ = 40
antlr3UTF32LALE PROC					; COMDAT

; 1699 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16

; 1700 :     pANTLR3_INPUT_STREAM input;
; 1701 : 	
; 1702 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1703 : 
; 1704 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001b	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00020	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00024	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00028	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0002d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00031	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00034	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00038	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	72 09		 jb	 SHORT $LN2@antlr3UTF3

; 1705 :     {
; 1706 : 		return	ANTLR3_CHARSTREAM_EOF;

  00041	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00046	eb 45		 jmp	 SHORT $LN1@antlr3UTF3

; 1707 :     }

  00048	eb 43		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1708 :     else
; 1709 :     {
; 1710 :         ANTLR3_UCHAR   c;
; 1711 : 
; 1712 :         c = (ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  0004a	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00057	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
  0005b	89 44 24 08	 mov	 DWORD PTR c$1[rsp], eax

; 1713 : 
; 1714 :         // Swap Endianess to Big Endian
; 1715 :         //
; 1716 :         return (c>>24) | ((c<<8) & 0x00FF0000) | ((c>>8) & 0x0000FF00) | (c<<24);

  0005f	8b 44 24 08	 mov	 eax, DWORD PTR c$1[rsp]
  00063	c1 e8 18	 shr	 eax, 24
  00066	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  0006a	c1 e1 08	 shl	 ecx, 8
  0006d	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  00073	0b c1		 or	 eax, ecx
  00075	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  00079	c1 e9 08	 shr	 ecx, 8
  0007c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00082	0b c1		 or	 eax, ecx
  00084	8b 4c 24 08	 mov	 ecx, DWORD PTR c$1[rsp]
  00088	c1 e1 18	 shl	 ecx, 24
  0008b	0b c1		 or	 eax, ecx
$LN3@antlr3UTF3:
$LN1@antlr3UTF3:

; 1717 :     }
; 1718 : }

  0008d	48 83 c4 10	 add	 rsp, 16
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
antlr3UTF32LALE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32LA
_TEXT	SEGMENT
input$ = 0
is$ = 32
la$ = 40
antlr3UTF32LA PROC					; COMDAT

; 1675 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16

; 1676 :     pANTLR3_INPUT_STREAM input;
; 1677 : 	
; 1678 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1679 : 
; 1680 :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001b	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00020	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00024	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00028	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0002d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00031	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00034	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00038	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	72 09		 jb	 SHORT $LN2@antlr3UTF3

; 1681 :     {
; 1682 : 		return	ANTLR3_CHARSTREAM_EOF;

  00041	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00046	eb 13		 jmp	 SHORT $LN1@antlr3UTF3

; 1683 :     }

  00048	eb 11		 jmp	 SHORT $LN3@antlr3UTF3
$LN2@antlr3UTF3:

; 1684 :     else
; 1685 :     {
; 1686 : 		return	(ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar + la - 1));

  0004a	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00057	8b 44 81 fc	 mov	 eax, DWORD PTR [rcx+rax*4-4]
$LN3@antlr3UTF3:
$LN1@antlr3UTF3:

; 1687 :     }
; 1688 : }

  0005b	48 83 c4 10	 add	 rsp, 16
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
antlr3UTF32LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32Consume
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr3UTF32Consume PROC					; COMDAT

; 1578 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 1579 :     pANTLR3_INPUT_STREAM input;
; 1580 : 
; 1581 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1582 : 
; 1583 :     // SizeBuf is always in bytes
; 1584 :     //
; 1585 :     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0001e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00022	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00026	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0002a	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0002e	73 69		 jae	 SHORT $LN2@antlr3UTF3

; 1586 :     {	
; 1587 : 	/* Indicate one more character in this line
; 1588 : 	 */
; 1589 : 	input->charPositionInLine++;

  00030	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00034	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00037	ff c0		 inc	 eax
  00039	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003d	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1590 : 	
; 1591 : 	if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT32)input->nextChar)) == input->newlineChar)

  00040	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0004c	8b 89 d0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+208]
  00052	39 08		 cmp	 DWORD PTR [rax], ecx
  00054	75 2f		 jne	 SHORT $LN3@antlr3UTF3

; 1592 : 	{
; 1593 : 	    /* Reset for start of a new line of input
; 1594 : 	     */
; 1595 : 	    input->line++;

  00056	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005a	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0005d	ff c0		 inc	 eax
  0005f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00063	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1596 : 	    input->charPositionInLine	= 0;

  00066	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006a	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1597 : 	    input->currentLine		= (void *)(((pANTLR3_UINT32)input->nextChar) + 1);

  00071	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	48 83 c0 04	 add	 rax, 4
  0007d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00081	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF3:

; 1598 : 	}
; 1599 : 
; 1600 : 	/* Increment to next character position
; 1601 : 	 */
; 1602 : 	input->nextChar = (void *)(((pANTLR3_UINT32)input->nextChar) + 1);

  00085	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00089	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008d	48 83 c0 04	 add	 rax, 4
  00091	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00095	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@antlr3UTF3:

; 1603 :     }
; 1604 : }

  00099	48 83 c4 10	 add	 rsp, 16
  0009d	5f		 pop	 rdi
  0009e	c3		 ret	 0
antlr3UTF32Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Substr
_TEXT	SEGMENT
tv75 = 32
input$ = 64
start$ = 72
stop$ = 80
antlr3UTF16Substr PROC					; COMDAT

; 1054 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1055 :     return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, ((ANTLR3_UINT32_CAST(stop - start))/2) + 1);

  00014	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  0001e	48 2b c8	 sub	 rcx, rax
  00021	48 8b c1	 mov	 rax, rcx
  00024	33 d2		 xor	 edx, edx
  00026	b9 02 00 00 00	 mov	 ecx, 2
  0002b	f7 f1		 div	 ecx
  0002d	ff c0		 inc	 eax
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00034	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00038	48 89 4c 24 20	 mov	 QWORD PTR tv75[rsp], rcx
  0003d	44 8b c0	 mov	 r8d, eax
  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0004a	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR tv75[rsp]
  00053	ff 50 20	 call	 QWORD PTR [rax+32]

; 1056 : }

  00056	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
antlr3UTF16Substr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Seek
_TEXT	SEGMENT
input$ = 32
is$ = 64
seekPoint$ = 72
antlr3UTF16Seek PROC					; COMDAT

; 1021 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1022 : 	pANTLR3_INPUT_STREAM input;
; 1023 : 
; 1024 : 	input   = ((pANTLR3_INPUT_STREAM) is->super);

  0000f	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1025 : 
; 1026 : 	// If the requested seek point is less than the current
; 1027 : 	// input point, then we assume that we are resetting from a mark
; 1028 : 	// and do not need to scan, but can just set to there as rewind will
; 1029 :         // reset line numbers and so on.
; 1030 : 	//
; 1031 : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00022	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00026	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  0002b	7f 10		 jg	 SHORT $LN4@antlr3UTF1

; 1032 : 	{
; 1033 : 		input->nextChar	= (void *)seekPoint;

  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  00037	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1034 : 	}

  0003b	eb 36		 jmp	 SHORT $LN5@antlr3UTF1
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 1035 : 	else
; 1036 : 	{
; 1037 :             // Call consume until we reach the asked for seek point or EOF
; 1038 :             //
; 1039 :             while (is->_LA(is, 1) != ANTLR3_CHARSTREAM_EOF && seekPoint < (ANTLR3_MARKER)input->nextChar)

  0003d	ba 01 00 00 00	 mov	 edx, 1
  00042	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0004c	ff 50 30	 call	 QWORD PTR [rax+48]
  0004f	83 f8 ff	 cmp	 eax, -1			; ffffffffH
  00052	74 1f		 je	 SHORT $LN3@antlr3UTF1
  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00059	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005d	48 39 44 24 48	 cmp	 QWORD PTR seekPoint$[rsp], rax
  00062	7d 0f		 jge	 SHORT $LN3@antlr3UTF1

; 1040 : 	    {
; 1041 : 		is->consume(is);

  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR is$[rsp]
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  0006e	ff 50 28	 call	 QWORD PTR [rax+40]

; 1042 : 	    }

  00071	eb ca		 jmp	 SHORT $LN2@antlr3UTF1
$LN3@antlr3UTF1:
$LN5@antlr3UTF1:

; 1043 : 	}
; 1044 : }

  00073	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
antlr3UTF16Seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Index
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr3UTF16Index PROC					; COMDAT

; 1004 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 1005 :     pANTLR3_INPUT_STREAM input;
; 1006 : 
; 1007 :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1008 : 
; 1009 :     return  (ANTLR3_MARKER)(input->nextChar);

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 1010 : }

  0001f	48 83 c4 10	 add	 rsp, 16
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
antlr3UTF16Index ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16LABE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
nextChar$ = 16
tv93 = 24
tv94 = 28
is$ = 48
la$ = 56
antlr3UTF16LABE PROC					; COMDAT

; 1366 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1367 : 	pANTLR3_INPUT_STREAM input;
; 1368 :         UTF32           ch;
; 1369 :         UTF32           ch2;
; 1370 :         pANTLR3_UCHAR   nextChar;
; 1371 : 
; 1372 :         // Find the input interface and where we are currently pointing to
; 1373 :         // in the input stream
; 1374 :         //
; 1375 : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1376 :         nextChar    = (pANTLR3_UCHAR)input->nextChar;

  0001b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00023	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1377 : 
; 1378 :         // If a positive offset then advance forward, else retreat
; 1379 :         //
; 1380 :         if  (la >= 0)

  00028	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  0002d	0f 8c bf 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 1381 :         {
; 1382 :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00033	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  00037	ff c8		 dec	 eax
  00039	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  0003d	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00042	0f 8e a5 00 00
	00		 jle	 $LN3@antlr3UTF1
  00048	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00057	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0005c	0f 83 8b 00 00
	00		 jae	 $LN3@antlr3UTF1

; 1383 :             {
; 1384 :                 // Advance our copy of the input pointer
; 1385 :                 //
; 1386 :                 // Next char in Big Endian byte order
; 1387 :                 //
; 1388 :                 ch  = ((*nextChar) << 8) + *(nextChar+1);

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00067	8b 00		 mov	 eax, DWORD PTR [rax]
  00069	c1 e0 08	 shl	 eax, 8
  0006c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00071	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00074	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1389 :                 nextChar += 2;

  00078	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0007d	48 83 c0 08	 add	 rax, 8
  00081	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1390 : 
; 1391 :                 // If we have a surrogate pair then we need to consume
; 1392 :                 // a following valid LO surrogate.
; 1393 :                 //
; 1394 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00086	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  0008e	72 58		 jb	 SHORT $LN8@antlr3UTF1
  00090	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00098	77 4e		 ja	 SHORT $LN8@antlr3UTF1

; 1395 :                 {
; 1396 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1397 :                     //
; 1398 :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0009a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0009e	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000a1	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000a5	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000a9	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000ae	73 38		 jae	 SHORT $LN9@antlr3UTF1

; 1399 :                     {
; 1400 :                         // Next character is in big endian byte order
; 1401 :                         //
; 1402 :                         ch2 = ((*nextChar) << 8) + *(nextChar+1);

  000b0	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000b5	8b 00		 mov	 eax, DWORD PTR [rax]
  000b7	c1 e0 08	 shl	 eax, 8
  000ba	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  000bf	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  000c2	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1403 : 
; 1404 :                         // If it's a valid low surrogate, consume it
; 1405 :                         //
; 1406 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000c6	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000ce	72 18		 jb	 SHORT $LN10@antlr3UTF1
  000d0	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000d8	77 0e		 ja	 SHORT $LN10@antlr3UTF1

; 1407 :                         {
; 1408 :                             // We consumed one 16 bit character
; 1409 :                             //
; 1410 : 		            nextChar += 2;

  000da	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000df	48 83 c0 08	 add	 rax, 8
  000e3	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN10@antlr3UTF1:
$LN9@antlr3UTF1:
$LN8@antlr3UTF1:

; 1411 :                         }
; 1412 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1413 :                         // it.
; 1414 :                         //
; 1415 :                     } 
; 1416 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1417 :                     // it because the buffer ended
; 1418 :                     //
; 1419 :                 }
; 1420 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1421 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1422 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1423 :                 //
; 1424 :             }

  000e8	e9 46 ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 1425 :         }

  000ed	e9 ca 00 00 00	 jmp	 $LN7@antlr3UTF1
$LN6@antlr3UTF1:
$LN4@antlr3UTF1:

; 1426 :         else
; 1427 :         {
; 1428 :             // We need to go backwards from our input point
; 1429 :             //
; 1430 :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000f2	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000f6	89 44 24 18	 mov	 DWORD PTR tv93[rsp], eax
  000fa	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00104	83 7c 24 18 00	 cmp	 DWORD PTR tv93[rsp], 0
  00109	7d 0a		 jge	 SHORT $LN19@antlr3UTF1
  0010b	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00113	eb 08		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  00115	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN20@antlr3UTF1:
  0011d	83 7c 24 1c 00	 cmp	 DWORD PTR tv94[rsp], 0
  00122	0f 84 94 00 00
	00		 je	 $LN5@antlr3UTF1
  00128	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0012c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00130	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00135	0f 86 81 00 00
	00		 jbe	 $LN5@antlr3UTF1

; 1431 :             {
; 1432 :                 // Get the previous 16 bit character
; 1433 :                 //
; 1434 :                 ch = ((*nextChar - 2) << 8) + (*nextChar -1);

  0013b	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00140	8b 00		 mov	 eax, DWORD PTR [rax]
  00142	83 e8 02	 sub	 eax, 2
  00145	c1 e0 08	 shl	 eax, 8
  00148	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0014d	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0014f	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00153	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1435 :                 nextChar -= 2;

  00157	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0015c	48 83 e8 08	 sub	 rax, 8
  00160	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1436 : 
; 1437 :                 // If we found a low surrogate then go back one more character if
; 1438 :                 // the hi surrogate is there
; 1439 :                 //
; 1440 :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  00165	81 7c 24 08 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  0016d	72 48		 jb	 SHORT $LN11@antlr3UTF1
  0016f	81 7c 24 08 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  00177	77 3e		 ja	 SHORT $LN11@antlr3UTF1

; 1441 :                 {
; 1442 :                     ch2 = ((*nextChar - 2) << 8) + (*nextChar -1);

  00179	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0017e	8b 00		 mov	 eax, DWORD PTR [rax]
  00180	83 e8 02	 sub	 eax, 2
  00183	c1 e0 08	 shl	 eax, 8
  00186	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0018b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0018d	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00191	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1443 :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  00195	81 7c 24 0c 00
	d8 00 00	 cmp	 DWORD PTR ch2$[rsp], 55296 ; 0000d800H
  0019d	72 18		 jb	 SHORT $LN12@antlr3UTF1
  0019f	81 7c 24 0c ff
	db 00 00	 cmp	 DWORD PTR ch2$[rsp], 56319 ; 0000dbffH
  001a7	77 0e		 ja	 SHORT $LN12@antlr3UTF1

; 1444 :                     {
; 1445 :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 1446 :                         //
; 1447 :                         nextChar -=2;

  001a9	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001ae	48 83 e8 08	 sub	 rax, 8
  001b2	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN12@antlr3UTF1:
$LN11@antlr3UTF1:

; 1448 :                     }
; 1449 :                 }
; 1450 :             }

  001b7	e9 36 ff ff ff	 jmp	 $LN4@antlr3UTF1
$LN5@antlr3UTF1:
$LN7@antlr3UTF1:

; 1451 :         }
; 1452 : 
; 1453 :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 1454 :         //
; 1455 :         // Input buffer size is always in bytes
; 1456 :         //
; 1457 : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  001bc	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001c0	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001c3	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  001c7	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001cb	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001d0	72 0f		 jb	 SHORT $LN13@antlr3UTF1

; 1458 : 	{
; 1459 : 		return	ANTLR3_CHARSTREAM_EOF;

  001d2	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001d7	e9 9c 00 00 00	 jmp	 $LN1@antlr3UTF1

; 1460 : 	}

  001dc	e9 93 00 00 00	 jmp	 $LN14@antlr3UTF1
$LN13@antlr3UTF1:

; 1461 : 	else
; 1462 : 	{
; 1463 :             // Pick up the next 16 character (big endian byte order)
; 1464 :             //
; 1465 :             ch = ((*nextChar) << 8) + *(nextChar+1);

  001e1	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001e6	8b 00		 mov	 eax, DWORD PTR [rax]
  001e8	c1 e0 08	 shl	 eax, 8
  001eb	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  001f0	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  001f3	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1466 :             nextChar += 2;

  001f7	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001fc	48 83 c0 08	 add	 rax, 8
  00200	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1467 : 
; 1468 :             // If we have a surrogate pair then we need to consume
; 1469 :             // a following valid LO surrogate.
; 1470 :             //
; 1471 :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00205	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  0020d	72 65		 jb	 SHORT $LN15@antlr3UTF1
  0020f	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00217	77 5b		 ja	 SHORT $LN15@antlr3UTF1

; 1472 :             {
; 1473 :                 // If the 16 bits following the high surrogate are in the source buffer...
; 1474 :                 //
; 1475 :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00219	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0021d	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00220	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00224	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00228	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0022d	73 45		 jae	 SHORT $LN16@antlr3UTF1

; 1476 :                 {
; 1477 :                     // Next character is in big endian byte order
; 1478 :                     //
; 1479 :                     ch2 = ((*nextChar) << 8) + *(nextChar+1);

  0022f	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00234	8b 00		 mov	 eax, DWORD PTR [rax]
  00236	c1 e0 08	 shl	 eax, 8
  00239	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  0023e	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  00241	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1480 : 
; 1481 :                     // If it's a valid low surrogate, consume it
; 1482 :                     //
; 1483 :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  00245	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  0024d	72 25		 jb	 SHORT $LN17@antlr3UTF1
  0024f	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00257	77 1b		 ja	 SHORT $LN17@antlr3UTF1

; 1484 :                     {
; 1485 :                         // Construct the UTF32 code point
; 1486 :                         //
; 1487 :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  00259	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
  0025d	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  00262	c1 e0 0a	 shl	 eax, 10
  00265	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch2$[rsp]
  00269	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  00270	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF1:
$LN16@antlr3UTF1:
$LN15@antlr3UTF1:
$LN14@antlr3UTF1:

; 1488 : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 1489 :                     }
; 1490 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1491 :                     // it.
; 1492 :                     //
; 1493 :                 } 
; 1494 :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1495 :                 // it because the buffer ended
; 1496 :                 //
; 1497 :             }
; 1498 :         }
; 1499 :         return ch;

  00274	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF1:

; 1500 : }

  00278	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0027c	5f		 pop	 rdi
  0027d	c3		 ret	 0
antlr3UTF16LABE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16ConsumeBE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
is$ = 32
antlr3UTF16ConsumeBE PROC				; COMDAT

; 1287 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 1288 : 	pANTLR3_INPUT_STREAM input;
; 1289 :         UTF32   ch;
; 1290 :         UTF32   ch2;
; 1291 : 
; 1292 : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1293 : 
; 1294 :         // Buffer size is always in bytes
; 1295 :         //
; 1296 : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0001e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00022	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00026	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0002a	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0002e	0f 83 ff 00 00
	00		 jae	 $LN2@antlr3UTF1

; 1297 : 	{	
; 1298 : 		// Indicate one more character in this line
; 1299 : 		//
; 1300 : 		input->charPositionInLine++;

  00034	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00038	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0003b	ff c0		 inc	 eax
  0003d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00041	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1301 : 
; 1302 : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00044	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00048	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  00059	75 2f		 jne	 SHORT $LN3@antlr3UTF1

; 1303 : 		{
; 1304 : 			// Reset for start of a new line of input
; 1305 : 			//
; 1306 : 			input->line++;

  0005b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00062	ff c0		 inc	 eax
  00064	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00068	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1307 : 			input->charPositionInLine	= 0;

  0006b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006f	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1308 : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00076	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	48 83 c0 02	 add	 rax, 2
  00082	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00086	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF1:

; 1309 : 		}
; 1310 : 
; 1311 : 		// Increment to next character position, accounting for any surrogates
; 1312 : 		//
; 1313 :                 // Next char in big endian form
; 1314 :                 //
; 1315 :                 ch  = *((pANTLR3_UINT8)input->nextChar + 1) + (*((pANTLR3_UINT8)input->nextChar ) <<8);

  0008a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00092	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00096	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0009a	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0009e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000a1	c1 e1 08	 shl	 ecx, 8
  000a4	03 c1		 add	 eax, ecx
  000a6	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1316 : 
; 1317 :                 // We consumed one 16 bit character
; 1318 :                 //
; 1319 : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000aa	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000ae	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b2	48 83 c0 02	 add	 rax, 2
  000b6	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ba	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1320 : 
; 1321 :                 // If we have a surrogate pair then we need to consume
; 1322 :                 // a following valid LO surrogate.
; 1323 :                 //
; 1324 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  000be	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000c6	72 6b		 jb	 SHORT $LN4@antlr3UTF1
  000c8	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000d0	77 61		 ja	 SHORT $LN4@antlr3UTF1

; 1325 : 
; 1326 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1327 :                     //
; 1328 :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000d2	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000d6	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000d9	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000dd	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000e1	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000e5	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000e9	73 48		 jae	 SHORT $LN5@antlr3UTF1

; 1329 :                     {
; 1330 :                         // Big endian
; 1331 :                         //
; 1332 :                         ch2 = *((pANTLR3_UINT8)input->nextChar + 1) + (*((pANTLR3_UINT8)input->nextChar ) <<8);

  000eb	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000ef	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f3	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000f7	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000fb	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000ff	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00102	c1 e1 08	 shl	 ecx, 8
  00105	03 c1		 add	 eax, ecx
  00107	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1333 : 
; 1334 :                         // If it's a valid low surrogate, consume it
; 1335 :                         //
; 1336 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  0010b	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00113	72 1e		 jb	 SHORT $LN6@antlr3UTF1
  00115	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  0011d	77 14		 ja	 SHORT $LN6@antlr3UTF1

; 1337 :                         {
; 1338 :                             // We consumed one 16 bit character
; 1339 :                             //
; 1340 : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0011f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00123	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00127	48 83 c0 02	 add	 rax, 2
  0012b	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0012f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN6@antlr3UTF1:
$LN5@antlr3UTF1:
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 1341 :                         }
; 1342 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1343 :                         // it.
; 1344 :                         //
; 1345 :                     } 
; 1346 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1347 :                     // it because the buffer ended
; 1348 :                     //
; 1349 :                 } 
; 1350 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1351 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1352 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1353 :                 //
; 1354 : 	}
; 1355 : }

  00133	48 83 c4 10	 add	 rsp, 16
  00137	5f		 pop	 rdi
  00138	c3		 ret	 0
antlr3UTF16ConsumeBE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16LALE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
nextChar$ = 16
tv93 = 24
tv94 = 28
is$ = 48
la$ = 56
antlr3UTF16LALE PROC					; COMDAT

; 1145 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1146 : 	pANTLR3_INPUT_STREAM input;
; 1147 :         UTF32           ch;
; 1148 :         UTF32           ch2;
; 1149 :         pANTLR3_UCHAR   nextChar;
; 1150 : 
; 1151 :         // Find the input interface and where we are currently pointing to
; 1152 :         // in the input stream
; 1153 :         //
; 1154 : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1155 :         nextChar    = (pANTLR3_UCHAR)input->nextChar;

  0001b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00023	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1156 : 
; 1157 :         // If a positive offset then advance forward, else retreat
; 1158 :         //
; 1159 :         if  (la >= 0)

  00028	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  0002d	0f 8c bf 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 1160 :         {
; 1161 :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00033	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  00037	ff c8		 dec	 eax
  00039	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  0003d	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00042	0f 8e a5 00 00
	00		 jle	 $LN3@antlr3UTF1
  00048	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00057	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0005c	0f 83 8b 00 00
	00		 jae	 $LN3@antlr3UTF1

; 1162 :             {
; 1163 :                 // Advance our copy of the input pointer
; 1164 :                 //
; 1165 :                 // Next char in Little Endian byte order
; 1166 :                 //
; 1167 :                 ch  = (*nextChar) + (*(nextChar+1) << 8);

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00067	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0006a	c1 e0 08	 shl	 eax, 8
  0006d	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00072	03 01		 add	 eax, DWORD PTR [rcx]
  00074	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1168 :                 nextChar += 2;

  00078	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0007d	48 83 c0 08	 add	 rax, 8
  00081	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1169 : 
; 1170 :                 // If we have a surrogate pair then we need to consume
; 1171 :                 // a following valid LO surrogate.
; 1172 :                 //
; 1173 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00086	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  0008e	72 58		 jb	 SHORT $LN8@antlr3UTF1
  00090	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00098	77 4e		 ja	 SHORT $LN8@antlr3UTF1

; 1174 :                 {
; 1175 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1176 :                     //
; 1177 :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0009a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0009e	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000a1	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000a5	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000a9	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000ae	73 38		 jae	 SHORT $LN9@antlr3UTF1

; 1178 :                     {
; 1179 :                         // Next character is in little endian byte order
; 1180 :                         //
; 1181 :                         ch2 = (*nextChar) + (*(nextChar+1) << 8);

  000b0	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b8	c1 e0 08	 shl	 eax, 8
  000bb	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  000c0	03 01		 add	 eax, DWORD PTR [rcx]
  000c2	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1182 : 
; 1183 :                         // If it's a valid low surrogate, consume it
; 1184 :                         //
; 1185 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000c6	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000ce	72 18		 jb	 SHORT $LN10@antlr3UTF1
  000d0	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000d8	77 0e		 ja	 SHORT $LN10@antlr3UTF1

; 1186 :                         {
; 1187 :                             // We consumed one 16 bit character
; 1188 :                             //
; 1189 : 		            nextChar += 2;

  000da	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000df	48 83 c0 08	 add	 rax, 8
  000e3	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN10@antlr3UTF1:
$LN9@antlr3UTF1:
$LN8@antlr3UTF1:

; 1190 :                         }
; 1191 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1192 :                         // it.
; 1193 :                         //
; 1194 :                     } 
; 1195 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1196 :                     // it because the buffer ended
; 1197 :                     //
; 1198 :                 }
; 1199 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1200 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1201 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1202 :                 //
; 1203 :             }

  000e8	e9 46 ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 1204 :         }

  000ed	e9 c4 00 00 00	 jmp	 $LN7@antlr3UTF1
$LN6@antlr3UTF1:
$LN4@antlr3UTF1:

; 1205 :         else
; 1206 :         {
; 1207 :             // We need to go backwards from our input point
; 1208 :             //
; 1209 :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000f2	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000f6	89 44 24 18	 mov	 DWORD PTR tv93[rsp], eax
  000fa	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  00104	83 7c 24 18 00	 cmp	 DWORD PTR tv93[rsp], 0
  00109	7d 0a		 jge	 SHORT $LN19@antlr3UTF1
  0010b	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00113	eb 08		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  00115	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN20@antlr3UTF1:
  0011d	83 7c 24 1c 00	 cmp	 DWORD PTR tv94[rsp], 0
  00122	0f 84 8e 00 00
	00		 je	 $LN5@antlr3UTF1
  00128	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0012c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00130	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00135	76 7f		 jbe	 SHORT $LN5@antlr3UTF1

; 1210 :             {
; 1211 :                 // Get the previous 16 bit character
; 1212 :                 //
; 1213 :                 ch = (*nextChar - 2) + ((*nextChar -1) << 8);

  00137	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0013c	8b 00		 mov	 eax, DWORD PTR [rax]
  0013e	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00143	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00145	ff c9		 dec	 ecx
  00147	c1 e1 08	 shl	 ecx, 8
  0014a	8d 44 08 fe	 lea	 eax, DWORD PTR [rax+rcx-2]
  0014e	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1214 :                 nextChar -= 2;

  00152	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00157	48 83 e8 08	 sub	 rax, 8
  0015b	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1215 : 
; 1216 :                 // If we found a low surrogate then go back one more character if
; 1217 :                 // the hi surrogate is there
; 1218 :                 //
; 1219 :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  00160	81 7c 24 08 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  00168	72 47		 jb	 SHORT $LN11@antlr3UTF1
  0016a	81 7c 24 08 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  00172	77 3d		 ja	 SHORT $LN11@antlr3UTF1

; 1220 :                 {
; 1221 :                     ch2 = (*nextChar - 2) + ((*nextChar -1) << 8);

  00174	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00179	8b 00		 mov	 eax, DWORD PTR [rax]
  0017b	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00180	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00182	ff c9		 dec	 ecx
  00184	c1 e1 08	 shl	 ecx, 8
  00187	8d 44 08 fe	 lea	 eax, DWORD PTR [rax+rcx-2]
  0018b	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1222 :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  0018f	81 7c 24 0c 00
	d8 00 00	 cmp	 DWORD PTR ch2$[rsp], 55296 ; 0000d800H
  00197	72 18		 jb	 SHORT $LN12@antlr3UTF1
  00199	81 7c 24 0c ff
	db 00 00	 cmp	 DWORD PTR ch2$[rsp], 56319 ; 0000dbffH
  001a1	77 0e		 ja	 SHORT $LN12@antlr3UTF1

; 1223 :                     {
; 1224 :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 1225 :                         //
; 1226 :                         nextChar -=2;

  001a3	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001a8	48 83 e8 08	 sub	 rax, 8
  001ac	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN12@antlr3UTF1:
$LN11@antlr3UTF1:

; 1227 :                     }
; 1228 :                 }
; 1229 :             }

  001b1	e9 3c ff ff ff	 jmp	 $LN4@antlr3UTF1
$LN5@antlr3UTF1:
$LN7@antlr3UTF1:

; 1230 :         }
; 1231 : 
; 1232 :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 1233 :         //
; 1234 :         // Input buffer size is always in bytes
; 1235 :         //
; 1236 : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  001b6	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001ba	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001bd	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  001c1	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001c5	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001ca	72 0f		 jb	 SHORT $LN13@antlr3UTF1

; 1237 : 	{
; 1238 : 		return	ANTLR3_CHARSTREAM_EOF;

  001cc	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  001d1	e9 9c 00 00 00	 jmp	 $LN1@antlr3UTF1

; 1239 : 	}

  001d6	e9 93 00 00 00	 jmp	 $LN14@antlr3UTF1
$LN13@antlr3UTF1:

; 1240 : 	else
; 1241 : 	{
; 1242 :             // Pick up the next 16 character (little endian byte order)
; 1243 :             //
; 1244 :             ch = (*nextChar) + (*(nextChar+1) << 8);

  001db	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001e0	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001e3	c1 e0 08	 shl	 eax, 8
  001e6	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  001eb	03 01		 add	 eax, DWORD PTR [rcx]
  001ed	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1245 :             nextChar += 2;

  001f1	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001f6	48 83 c0 08	 add	 rax, 8
  001fa	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 1246 : 
; 1247 :             // If we have a surrogate pair then we need to consume
; 1248 :             // a following valid LO surrogate.
; 1249 :             //
; 1250 :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  001ff	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  00207	72 65		 jb	 SHORT $LN15@antlr3UTF1
  00209	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  00211	77 5b		 ja	 SHORT $LN15@antlr3UTF1

; 1251 :             {
; 1252 :                 // If the 16 bits following the high surrogate are in the source buffer...
; 1253 :                 //
; 1254 :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00213	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00217	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0021a	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0021e	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00222	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00227	73 45		 jae	 SHORT $LN16@antlr3UTF1

; 1255 :                 {
; 1256 :                     // Next character is in little endian byte order
; 1257 :                     //
; 1258 :                     ch2 = (*nextChar) + (*(nextChar+1) << 8);

  00229	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0022e	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00231	c1 e0 08	 shl	 eax, 8
  00234	48 8b 4c 24 10	 mov	 rcx, QWORD PTR nextChar$[rsp]
  00239	03 01		 add	 eax, DWORD PTR [rcx]
  0023b	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1259 : 
; 1260 :                     // If it's a valid low surrogate, consume it
; 1261 :                     //
; 1262 :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  0023f	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00247	72 25		 jb	 SHORT $LN17@antlr3UTF1
  00249	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00251	77 1b		 ja	 SHORT $LN17@antlr3UTF1

; 1263 :                     {
; 1264 :                         // Construct the UTF32 code point
; 1265 :                         //
; 1266 :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  00253	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
  00257	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  0025c	c1 e0 0a	 shl	 eax, 10
  0025f	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch2$[rsp]
  00263	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  0026a	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF1:
$LN16@antlr3UTF1:
$LN15@antlr3UTF1:
$LN14@antlr3UTF1:

; 1267 : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 1268 :                     }
; 1269 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1270 :                     // it.
; 1271 :                     //
; 1272 :                 } 
; 1273 :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1274 :                 // it because the buffer ended
; 1275 :                 //
; 1276 :             }
; 1277 :         }
; 1278 :         return ch;

  0026e	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF1:

; 1279 : }

  00272	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00276	5f		 pop	 rdi
  00277	c3		 ret	 0
antlr3UTF16LALE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16ConsumeLE
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
is$ = 32
antlr3UTF16ConsumeLE PROC				; COMDAT

; 1068 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 1069 : 	pANTLR3_INPUT_STREAM input;
; 1070 :         UTF32   ch;
; 1071 :         UTF32   ch2;
; 1072 : 
; 1073 : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 1074 : 
; 1075 :         // Buffer size is always in bytes
; 1076 :         //
; 1077 : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0001e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00022	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00026	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0002a	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0002e	0f 83 ff 00 00
	00		 jae	 $LN2@antlr3UTF1

; 1078 : 	{	
; 1079 : 		// Indicate one more character in this line
; 1080 : 		//
; 1081 : 		input->charPositionInLine++;

  00034	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00038	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0003b	ff c0		 inc	 eax
  0003d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00041	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 1082 : 
; 1083 : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00044	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00048	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  00059	75 2f		 jne	 SHORT $LN3@antlr3UTF1

; 1084 : 		{
; 1085 : 			// Reset for start of a new line of input
; 1086 : 			//
; 1087 : 			input->line++;

  0005b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00062	ff c0		 inc	 eax
  00064	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00068	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 1088 : 			input->charPositionInLine	= 0;

  0006b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006f	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1089 : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00076	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	48 83 c0 02	 add	 rax, 2
  00082	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00086	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF1:

; 1090 : 		}
; 1091 : 
; 1092 : 		// Increment to next character position, accounting for any surrogates
; 1093 : 		//
; 1094 :                 // Next char in litle endian form
; 1095 :                 //
; 1096 :                 ch  = *((pANTLR3_UINT8)input->nextChar) + (*((pANTLR3_UINT8)input->nextChar + 1) <<8);

  0008a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00092	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00095	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00099	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0009d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  000a1	c1 e1 08	 shl	 ecx, 8
  000a4	03 c1		 add	 eax, ecx
  000a6	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 1097 : 
; 1098 :                 // We consumed one 16 bit character
; 1099 :                 //
; 1100 : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000aa	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000ae	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000b2	48 83 c0 02	 add	 rax, 2
  000b6	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000ba	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1101 : 
; 1102 :                 // If we have a surrogate pair then we need to consume
; 1103 :                 // a following valid LO surrogate.
; 1104 :                 //
; 1105 :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  000be	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000c6	72 6b		 jb	 SHORT $LN4@antlr3UTF1
  000c8	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000d0	77 61		 ja	 SHORT $LN4@antlr3UTF1

; 1106 : 
; 1107 :                     // If the 16 bits following the high surrogate are in the source buffer...
; 1108 :                     //
; 1109 :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000d2	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000d6	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000d9	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000dd	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000e1	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000e5	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000e9	73 48		 jae	 SHORT $LN5@antlr3UTF1

; 1110 :                     {
; 1111 :                         ch2 = *((pANTLR3_UINT8)input->nextChar) + (*((pANTLR3_UINT8)input->nextChar + 1) <<8);

  000eb	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000ef	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f6	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000fa	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000fe	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00102	c1 e1 08	 shl	 ecx, 8
  00105	03 c1		 add	 eax, ecx
  00107	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 1112 : 
; 1113 :                         // If it's a valid low surrogate, consume it
; 1114 :                         //
; 1115 :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  0010b	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  00113	72 1e		 jb	 SHORT $LN6@antlr3UTF1
  00115	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  0011d	77 14		 ja	 SHORT $LN6@antlr3UTF1

; 1116 :                         {
; 1117 :                             // We consumed one 16 bit character
; 1118 :                             //
; 1119 : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  0011f	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00123	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00127	48 83 c0 02	 add	 rax, 2
  0012b	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0012f	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN6@antlr3UTF1:
$LN5@antlr3UTF1:
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 1120 :                         }
; 1121 :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1122 :                         // it.
; 1123 :                         //
; 1124 :                     } 
; 1125 :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 1126 :                     // it because the buffer ended
; 1127 :                     //
; 1128 :                 } 
; 1129 :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 1130 :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 1131 :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 1132 :                 //
; 1133 : 	}
; 1134 : }

  00133	48 83 c4 10	 add	 rsp, 16
  00137	5f		 pop	 rdi
  00138	c3		 ret	 0
antlr3UTF16ConsumeLE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16LA
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
nextChar$ = 16
tv89 = 24
tv90 = 28
is$ = 48
la$ = 56
antlr3UTF16LA PROC					; COMDAT

; 865  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 866  : 	pANTLR3_INPUT_STREAM input;
; 867  :         UTF32   ch;
; 868  :         UTF32   ch2;
; 869  :         UTF16   * nextChar;
; 870  : 
; 871  :         // Find the input interface and where we are currently pointing to
; 872  :         // in the input stream
; 873  :         //
; 874  : 	input       = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 875  :         nextChar    = (UTF16*)input->nextChar;

  0001b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001f	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00023	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 876  : 
; 877  :         // If a positive offset then advance forward, else retreat
; 878  :         //
; 879  :         if  (la >= 0)

  00028	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  0002d	0f 8c a7 00 00
	00		 jl	 $LN6@antlr3UTF1
$LN2@antlr3UTF1:

; 880  :         {
; 881  :             while   (--la > 0 && (pANTLR3_UINT8)nextChar < ((pANTLR3_UINT8)input->data) + input->sizeBuf )

  00033	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  00037	ff c8		 dec	 eax
  00039	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  0003d	83 7c 24 38 00	 cmp	 DWORD PTR la$[rsp], 0
  00042	0f 8e 8d 00 00
	00		 jle	 $LN3@antlr3UTF1
  00048	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0004c	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00057	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  0005c	73 77		 jae	 SHORT $LN3@antlr3UTF1

; 882  :             {
; 883  :                 // Advance our copy of the input pointer
; 884  :                 //
; 885  :                 // Next char in natural machine byte order
; 886  :                 //
; 887  :                 ch  = *nextChar++;

  0005e	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00063	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00066	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
  0006a	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0006f	48 83 c0 02	 add	 rax, 2
  00073	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 888  : 
; 889  :                 // If we have a surrogate pair then we need to consume
; 890  :                 // a following valid LO surrogate.
; 891  :                 //
; 892  :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  00078	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  00080	72 4e		 jb	 SHORT $LN8@antlr3UTF1
  00082	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  0008a	77 44		 ja	 SHORT $LN8@antlr3UTF1

; 893  :                 {
; 894  :                     // If the 16 bits following the high surrogate are in the source buffer...
; 895  :                     //
; 896  :                     if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0008c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00090	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00093	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00097	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0009b	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  000a0	73 2e		 jae	 SHORT $LN9@antlr3UTF1

; 897  :                     {
; 898  :                         // Next character is in natural machine byte order
; 899  :                         //
; 900  :                         ch2 = *nextChar;

  000a2	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000a7	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000aa	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 901  : 
; 902  :                         // If it's a valid low surrogate, consume it
; 903  :                         //
; 904  :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000ae	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000b6	72 18		 jb	 SHORT $LN10@antlr3UTF1
  000b8	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000c0	77 0e		 ja	 SHORT $LN10@antlr3UTF1

; 905  :                         {
; 906  :                             // We consumed one 16 bit character
; 907  :                             //
; 908  : 		            nextChar++;

  000c2	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  000c7	48 83 c0 02	 add	 rax, 2
  000cb	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN10@antlr3UTF1:
$LN9@antlr3UTF1:
$LN8@antlr3UTF1:

; 909  :                         }
; 910  :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 911  :                         // it.
; 912  :                         //
; 913  :                     } 
; 914  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 915  :                     // it because the buffer ended
; 916  :                     //
; 917  :                 }
; 918  :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 919  :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 920  :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 921  :                 //
; 922  :             }

  000d0	e9 5e ff ff ff	 jmp	 $LN2@antlr3UTF1
$LN3@antlr3UTF1:

; 923  :         }

  000d5	e9 a3 00 00 00	 jmp	 $LN7@antlr3UTF1
$LN6@antlr3UTF1:
$LN4@antlr3UTF1:

; 924  :         else
; 925  :         {
; 926  :             // We need to go backwards from our input point
; 927  :             //
; 928  :             while   (la++ < 0 && (pANTLR3_UINT8)nextChar > (pANTLR3_UINT8)input->data )

  000da	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000de	89 44 24 18	 mov	 DWORD PTR tv89[rsp], eax
  000e2	8b 44 24 38	 mov	 eax, DWORD PTR la$[rsp]
  000e6	ff c0		 inc	 eax
  000e8	89 44 24 38	 mov	 DWORD PTR la$[rsp], eax
  000ec	83 7c 24 18 00	 cmp	 DWORD PTR tv89[rsp], 0
  000f1	7d 0a		 jge	 SHORT $LN19@antlr3UTF1
  000f3	c7 44 24 1c 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000fb	eb 08		 jmp	 SHORT $LN20@antlr3UTF1
$LN19@antlr3UTF1:
  000fd	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN20@antlr3UTF1:
  00105	83 7c 24 1c 00	 cmp	 DWORD PTR tv90[rsp], 0
  0010a	74 71		 je	 SHORT $LN5@antlr3UTF1
  0010c	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00110	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00114	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00119	76 62		 jbe	 SHORT $LN5@antlr3UTF1

; 929  :             {
; 930  :                 // Get the previous 16 bit character
; 931  :                 //
; 932  :                 ch = *--nextChar;

  0011b	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  00120	48 83 e8 02	 sub	 rax, 2
  00124	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
  00129	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0012e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00131	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 933  : 
; 934  :                 // If we found a low surrogate then go back one more character if
; 935  :                 // the hi surrogate is there
; 936  :                 //
; 937  :                 if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) 

  00135	81 7c 24 08 00
	dc 00 00	 cmp	 DWORD PTR ch$[rsp], 56320 ; 0000dc00H
  0013d	72 39		 jb	 SHORT $LN11@antlr3UTF1
  0013f	81 7c 24 08 ff
	df 00 00	 cmp	 DWORD PTR ch$[rsp], 57343 ; 0000dfffH
  00147	77 2f		 ja	 SHORT $LN11@antlr3UTF1

; 938  :                 {
; 939  :                     ch2 = *(nextChar-1);

  00149	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0014e	0f b7 40 fe	 movzx	 eax, WORD PTR [rax-2]
  00152	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 940  :                     if (ch2 >= UNI_SUR_HIGH_START && ch2 <= UNI_SUR_HIGH_END) 

  00156	81 7c 24 0c 00
	d8 00 00	 cmp	 DWORD PTR ch2$[rsp], 55296 ; 0000d800H
  0015e	72 18		 jb	 SHORT $LN12@antlr3UTF1
  00160	81 7c 24 0c ff
	db 00 00	 cmp	 DWORD PTR ch2$[rsp], 56319 ; 0000dbffH
  00168	77 0e		 ja	 SHORT $LN12@antlr3UTF1

; 941  :                     {
; 942  :                         // Yes, there is a high surrogate to match it so decrement one more and point to that
; 943  :                         //
; 944  :                         nextChar--;

  0016a	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  0016f	48 83 e8 02	 sub	 rax, 2
  00173	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax
$LN12@antlr3UTF1:
$LN11@antlr3UTF1:

; 945  :                     }
; 946  :                 }
; 947  :             }

  00178	e9 5d ff ff ff	 jmp	 $LN4@antlr3UTF1
$LN5@antlr3UTF1:
$LN7@antlr3UTF1:

; 948  :         }
; 949  : 
; 950  :         // Our local copy of nextChar is now pointing to either the correct character or end of file
; 951  :         //
; 952  :         // Input buffer size is always in bytes
; 953  :         //
; 954  : 	if	( (pANTLR3_UINT8)nextChar >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0017d	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00181	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  00184	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00188	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0018c	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  00191	72 0c		 jb	 SHORT $LN13@antlr3UTF1

; 955  : 	{
; 956  : 		return	ANTLR3_CHARSTREAM_EOF;

  00193	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00198	e9 85 00 00 00	 jmp	 $LN1@antlr3UTF1

; 957  : 	}

  0019d	eb 7f		 jmp	 SHORT $LN14@antlr3UTF1
$LN13@antlr3UTF1:

; 958  : 	else
; 959  : 	{
; 960  :             // Pick up the next 16 character (native machine byte order)
; 961  :             //
; 962  :             ch = *nextChar++;

  0019f	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001a4	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001a7	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
  001ab	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001b0	48 83 c0 02	 add	 rax, 2
  001b4	48 89 44 24 10	 mov	 QWORD PTR nextChar$[rsp], rax

; 963  : 
; 964  :             // If we have a surrogate pair then we need to consume
; 965  :             // a following valid LO surrogate.
; 966  :             //
; 967  :             if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) 

  001b9	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  001c1	72 5b		 jb	 SHORT $LN15@antlr3UTF1
  001c3	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  001cb	77 51		 ja	 SHORT $LN15@antlr3UTF1

; 968  :             {
; 969  :                 // If the 16 bits following the high surrogate are in the source buffer...
; 970  :                 //
; 971  :                 if	((pANTLR3_UINT8)(nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  001cd	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  001d1	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  001d4	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  001d8	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001dc	48 39 44 24 10	 cmp	 QWORD PTR nextChar$[rsp], rax
  001e1	73 3b		 jae	 SHORT $LN16@antlr3UTF1

; 972  :                 {
; 973  :                     // Next character is in natural machine byte order
; 974  :                     //
; 975  :                     ch2 = *nextChar;

  001e3	48 8b 44 24 10	 mov	 rax, QWORD PTR nextChar$[rsp]
  001e8	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001eb	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 976  : 
; 977  :                     // If it's a valid low surrogate, consume it
; 978  :                     //
; 979  :                     if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  001ef	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  001f7	72 25		 jb	 SHORT $LN17@antlr3UTF1
  001f9	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  00201	77 1b		 ja	 SHORT $LN17@antlr3UTF1

; 980  :                     {
; 981  :                         // Construct the UTF32 code point
; 982  :                         //
; 983  :                         ch = ((ch - UNI_SUR_HIGH_START) << halfShift)

  00203	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
  00207	2d 00 d8 00 00	 sub	 eax, 55296		; 0000d800H
  0020c	c1 e0 0a	 shl	 eax, 10
  0020f	8b 4c 24 0c	 mov	 ecx, DWORD PTR ch2$[rsp]
  00213	8d 84 08 00 24
	00 00		 lea	 eax, DWORD PTR [rax+rcx+9216]
  0021a	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax
$LN17@antlr3UTF1:
$LN16@antlr3UTF1:
$LN15@antlr3UTF1:
$LN14@antlr3UTF1:

; 984  : 			    + (ch2 - UNI_SUR_LOW_START) + halfBase;
; 985  :                     }
; 986  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 987  :                     // it.
; 988  :                     //
; 989  :                 } 
; 990  :                 // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 991  :                 // it because the buffer ended
; 992  :                 //
; 993  :             }
; 994  :         }
; 995  :         return ch;

  0021e	8b 44 24 08	 mov	 eax, DWORD PTR ch$[rsp]
$LN1@antlr3UTF1:

; 996  : }

  00222	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00226	5f		 pop	 rdi
  00227	c3		 ret	 0
antlr3UTF16LA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16Consume
_TEXT	SEGMENT
input$ = 0
ch$ = 8
ch2$ = 12
is$ = 32
antlr3UTF16Consume PROC					; COMDAT

; 786  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 787  : 	pANTLR3_INPUT_STREAM input;
; 788  :         UTF32   ch;
; 789  :         UTF32   ch2;
; 790  : 
; 791  : 	input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 792  : 
; 793  :         // Buffer size is always in bytes
; 794  :         //
; 795  : 	if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0001e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00022	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00026	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0002a	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0002e	0f 83 dd 00 00
	00		 jae	 $LN2@antlr3UTF1

; 796  : 	{	
; 797  : 		// Indicate one more character in this line
; 798  : 		//
; 799  : 		input->charPositionInLine++;

  00034	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00038	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0003b	ff c0		 inc	 eax
  0003d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00041	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 800  : 
; 801  : 		if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)input->nextChar)) == input->newlineChar)

  00044	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00048	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  00059	75 2f		 jne	 SHORT $LN3@antlr3UTF1

; 802  : 		{
; 803  : 			// Reset for start of a new line of input
; 804  : 			//
; 805  : 			input->line++;

  0005b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005f	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  00062	ff c0		 inc	 eax
  00064	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00068	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 806  : 			input->charPositionInLine	= 0;

  0006b	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006f	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 807  : 			input->currentLine		= (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00076	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	48 83 c0 02	 add	 rax, 2
  00082	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00086	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr3UTF1:

; 808  : 		}
; 809  : 
; 810  : 		// Increment to next character position, accounting for any surrogates
; 811  : 		//
; 812  :                 // Next char in natural machine byte order
; 813  :                 //
; 814  :                 ch  = *((UTF16*)input->nextChar);

  0008a	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0008e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00092	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00095	89 44 24 08	 mov	 DWORD PTR ch$[rsp], eax

; 815  : 
; 816  :                 // We consumed one 16 bit character
; 817  :                 //
; 818  : 		input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  00099	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0009d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000a1	48 83 c0 02	 add	 rax, 2
  000a5	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000a9	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 819  : 
; 820  :                 // If we have a surrogate pair then we need to consume
; 821  :                 // a following valid LO surrogate.
; 822  :                 //
; 823  :                 if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {

  000ad	81 7c 24 08 00
	d8 00 00	 cmp	 DWORD PTR ch$[rsp], 55296 ; 0000d800H
  000b5	72 5a		 jb	 SHORT $LN4@antlr3UTF1
  000b7	81 7c 24 08 ff
	db 00 00	 cmp	 DWORD PTR ch$[rsp], 56319 ; 0000dbffH
  000bf	77 50		 ja	 SHORT $LN4@antlr3UTF1

; 824  : 
; 825  :                     // If the 16 bits following the high surrogate are in the source buffer...
; 826  :                     //
; 827  :                     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  000c1	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000c5	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  000c8	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000cc	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  000d0	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  000d4	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  000d8	73 37		 jae	 SHORT $LN5@antlr3UTF1

; 828  :                     {
; 829  :                         // Next character is in natural machine byte order
; 830  :                         //
; 831  :                         ch2 = *((UTF16*)input->nextChar);

  000da	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  000de	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000e2	0f b7 00	 movzx	 eax, WORD PTR [rax]
  000e5	89 44 24 0c	 mov	 DWORD PTR ch2$[rsp], eax

; 832  : 
; 833  :                         // If it's a valid low surrogate, consume it
; 834  :                         //
; 835  :                         if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) 

  000e9	81 7c 24 0c 00
	dc 00 00	 cmp	 DWORD PTR ch2$[rsp], 56320 ; 0000dc00H
  000f1	72 1e		 jb	 SHORT $LN6@antlr3UTF1
  000f3	81 7c 24 0c ff
	df 00 00	 cmp	 DWORD PTR ch2$[rsp], 57343 ; 0000dfffH
  000fb	77 14		 ja	 SHORT $LN6@antlr3UTF1

; 836  :                         {
; 837  :                             // We consumed one 16 bit character
; 838  :                             //
; 839  : 		            input->nextChar = (void *)(((pANTLR3_UINT16)input->nextChar) + 1);

  000fd	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00101	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00105	48 83 c0 02	 add	 rax, 2
  00109	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0010d	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN6@antlr3UTF1:
$LN5@antlr3UTF1:
$LN4@antlr3UTF1:
$LN2@antlr3UTF1:

; 840  :                         }
; 841  :                         // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 842  :                         // it.
; 843  :                         //
; 844  :                     } 
; 845  :                     // Note that we ignore a valid hi surrogate that has no lo surrogate to go with
; 846  :                     // it because the buffer ended
; 847  :                     //
; 848  :                 } 
; 849  :                 // Note that we did not check for an invalid low surrogate here, or that fact that the
; 850  :                 // lo surrogate was missing. We just picked out one 16 bit character unless the character
; 851  :                 // was a valid hi surrogate, in whcih case we consumed two 16 bit characters.
; 852  :                 //
; 853  : 	}
; 854  : }

  00111	48 83 c4 10	 add	 rsp, 16
  00115	5f		 pop	 rdi
  00116	c3		 ret	 0
antlr3UTF16Consume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSetUcaseLA
_TEXT	SEGMENT
input$ = 16
flag$ = 24
antlr38BitSetUcaseLA PROC				; COMDAT

; 240  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 241  : 	if	(flag)

  0000a	0f b6 44 24 18	 movzx	 eax, BYTE PTR flag$[rsp]
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN2@antlr38Bit

; 242  : 	{
; 243  : 		// Return the upper case version of the characters
; 244  : 		//
; 245  : 		input->istream->_LA		    =  antlr38BitLA_ucase;

  00013	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLA_ucase
  00022	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 246  : 	}

  00026	eb 13		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 247  : 	else
; 248  : 	{
; 249  : 		// Return the raw characters as they are in the buffer
; 250  : 		//
; 251  : 		input->istream->_LA		    =  antlr38BitLA;

  00028	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0002d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLA
  00037	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN3@antlr38Bit:

; 252  : 	}
; 253  : }

  0003b	5f		 pop	 rdi
  0003c	c3		 ret	 0
antlr38BitSetUcaseLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSetNewLineChar
_TEXT	SEGMENT
input$ = 16
newlineChar$ = 24
antlr38BitSetNewLineChar PROC				; COMDAT

; 693  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 694  :     input->newlineChar	= newlineChar;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR newlineChar$[rsp]
  00013	89 88 d0 00 00
	00		 mov	 DWORD PTR [rax+208], ecx

; 695  : }

  00019	5f		 pop	 rdi
  0001a	c3		 ret	 0
antlr38BitSetNewLineChar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSetCharPosition
_TEXT	SEGMENT
input$ = 16
position$ = 24
antlr38BitSetCharPosition PROC				; COMDAT

; 677  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 678  :     input->charPositionInLine = position;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR position$[rsp]
  00013	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 679  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
antlr38BitSetCharPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSetLine
_TEXT	SEGMENT
input$ = 16
line$ = 24
antlr38BitSetLine PROC					; COMDAT

; 662  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 663  :     input->line	= line;

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 4c 24 18	 mov	 ecx, DWORD PTR line$[rsp]
  00013	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 664  : }

  00016	5f		 pop	 rdi
  00017	c3		 ret	 0
antlr38BitSetLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitGetCharPosition
_TEXT	SEGMENT
input$ = 16
antlr38BitGetCharPosition PROC				; COMDAT

; 645  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 646  :     return  input->charPositionInLine;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	8b 40 40	 mov	 eax, DWORD PTR [rax+64]

; 647  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr38BitGetCharPosition ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitGetLineBuf
_TEXT	SEGMENT
input$ = 16
antlr38BitGetLineBuf PROC				; COMDAT

; 634  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 635  :     return  input->currentLine;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]

; 636  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
antlr38BitGetLineBuf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitGetLine
_TEXT	SEGMENT
input$ = 16
antlr38BitGetLine PROC					; COMDAT

; 622  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 623  :     return  input->line;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	8b 40 34	 mov	 eax, DWORD PTR [rax+52]

; 624  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr38BitGetLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSubstr
_TEXT	SEGMENT
tv74 = 32
input$ = 64
start$ = 72
stop$ = 80
antlr38BitSubstr PROC					; COMDAT

; 611  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 612  : 	return  input->strFactory->newPtr(input->strFactory, (pANTLR3_UINT8)start, (ANTLR3_UINT32)(stop - start + 1));

  00014	48 8b 44 24 48	 mov	 rax, QWORD PTR start$[rsp]
  00019	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stop$[rsp]
  0001e	48 2b c8	 sub	 rcx, rax
  00021	48 8b c1	 mov	 rax, rcx
  00024	48 ff c0	 inc	 rax
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  0002c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00030	48 89 4c 24 20	 mov	 QWORD PTR tv74[rsp], rcx
  00035	44 8b c0	 mov	 r8d, eax
  00038	48 8b 54 24 48	 mov	 rdx, QWORD PTR start$[rsp]
  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00042	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR tv74[rsp]
  0004b	ff 50 20	 call	 QWORD PTR [rax+32]

; 613  : }

  0004e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00052	5f		 pop	 rdi
  00053	c3		 ret	 0
antlr38BitSubstr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSize
_TEXT	SEGMENT
input$ = 16
antlr38BitSize PROC					; COMDAT

; 434  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 435  :     return  input->sizeBuf;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR input$[rsp]
  0000b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]

; 436  : }

  0000e	5f		 pop	 rdi
  0000f	c3		 ret	 0
antlr38BitSize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitLT
_TEXT	SEGMENT
input$ = 48
lt$ = 56
antlr38BitLT PROC					; COMDAT

; 403  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 404  :     /* Casting is horrible but it means no warnings and LT should never be called
; 405  :      * on a character stream anyway I think. If it is then, the void * will need to be 
; 406  :      * cast back in a similar manner. Yuck! But this means that LT for Token streams and
; 407  :      * tree streams is correct.
; 408  :      */
; 409  :     return (ANTLR3_FUNC_PTR(input->istream->_LA(input->istream, lt)));

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	8b 54 24 38	 mov	 edx, DWORD PTR lt$[rsp]
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0001f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00022	ff 50 30	 call	 QWORD PTR [rax+48]
  00025	8b c0		 mov	 eax, eax

; 410  : }

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5f		 pop	 rdi
  0002c	c3		 ret	 0
antlr38BitLT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitReuse
_TEXT	SEGMENT
tv76 = 32
tv88 = 40
tv94 = 48
input$ = 80
inString$ = 88
size$ = 96
name$ = 104
antlr38BitReuse PROC					; COMDAT

; 289  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 290  :     input->isAllocated	= ANTLR3_FALSE;

  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  0001e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 291  :     input->data		= inString;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  0002a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inString$[rsp]
  0002f	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 292  :     input->sizeBuf	= size;

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00038	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  0003c	89 48 30	 mov	 DWORD PTR [rax+48], ecx

; 293  :     
; 294  :     // Now we can set up the file name. As we are reusing the stream, there may already
; 295  :     // be a string that we can reuse for holding the filename.
; 296  :     //
; 297  : 	if	(input->istream->streamName == NULL) 

  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00044	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00047	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0004c	75 5d		 jne	 SHORT $LN2@antlr38Bit

; 298  : 	{
; 299  : 		input->istream->streamName	= input->strFactory->newStr(input->strFactory, name == NULL ? (pANTLR3_UINT8)"-memory-" : name);

  0004e	48 83 7c 24 68
	00		 cmp	 QWORD PTR name$[rsp], 0
  00054	75 0e		 jne	 SHORT $LN5@antlr38Bit
  00056	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08ONBMMFLC@?9memory?9@
  0005d	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
  00062	eb 0a		 jmp	 SHORT $LN6@antlr38Bit
$LN5@antlr38Bit:
  00064	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  00069	48 89 44 24 20	 mov	 QWORD PTR tv76[rsp], rax
$LN6@antlr38Bit:
  0006e	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00073	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00077	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv76[rsp]
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  00081	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00085	ff 50 30	 call	 QWORD PTR [rax+48]
  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  0008d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00090	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 300  : 		input->fileName		= input->istream->streamName;

  00094	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  00099	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  000a1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a5	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 301  : 	}

  000a9	eb 4a		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 302  : 	else
; 303  : 	{
; 304  : 		input->istream->streamName->set(input->istream->streamName,  (name == NULL ? (const char *)"-memory-" : (const char *)name));

  000ab	48 83 7c 24 68
	00		 cmp	 QWORD PTR name$[rsp], 0
  000b1	75 0e		 jne	 SHORT $LN7@antlr38Bit
  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08ONBMMFLC@?9memory?9@
  000ba	48 89 44 24 28	 mov	 QWORD PTR tv88[rsp], rax
  000bf	eb 0a		 jmp	 SHORT $LN8@antlr38Bit
$LN7@antlr38Bit:
  000c1	48 8b 44 24 68	 mov	 rax, QWORD PTR name$[rsp]
  000c6	48 89 44 24 28	 mov	 QWORD PTR tv88[rsp], rax
$LN8@antlr38Bit:
  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  000d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  000d8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000db	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000df	48 89 4c 24 30	 mov	 QWORD PTR tv94[rsp], rcx
  000e4	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv88[rsp]
  000e9	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000ed	48 8b 44 24 30	 mov	 rax, QWORD PTR tv94[rsp]
  000f2	ff 50 20	 call	 QWORD PTR [rax+32]
$LN3@antlr38Bit:

; 305  : 	}
; 306  : 
; 307  :     input->reset(input);

  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR input$[rsp]
  000fa	48 8b 44 24 50	 mov	 rax, QWORD PTR input$[rsp]
  000ff	ff 50 70	 call	 QWORD PTR [rax+112]

; 308  : }

  00102	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
antlr38BitReuse ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3InputReset
_TEXT	SEGMENT
input$ = 48
antlr3InputReset PROC					; COMDAT

; 262  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 263  : 
; 264  :     input->nextChar		= input->data;	/* Input at first character */

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0000f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00014	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00018	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 265  :     input->line			= 1;		/* starts at line 1	    */

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00021	c7 40 34 01 00
	00 00		 mov	 DWORD PTR [rax+52], 1

; 266  :     input->charPositionInLine	= 0;

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0002d	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 267  :     input->currentLine		= input->data;

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0003e	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00042	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 268  :     input->markDepth		= 0;		/* Reset markers	    */

  00046	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004b	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 269  :     
; 270  :     /* Clear out up the markers table if it is there
; 271  :      */
; 272  :     if	(input->markers != NULL)

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00057	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  0005c	74 1a		 je	 SHORT $LN2@antlr3Inpu

; 273  :     {
; 274  :         input->markers->clear(input->markers);

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00063	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00067	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0006c	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00070	ff 90 38 01 00
	00		 call	 QWORD PTR [rax+312]

; 275  :     }

  00076	eb 10		 jmp	 SHORT $LN3@antlr3Inpu
$LN2@antlr3Inpu:

; 276  :     else
; 277  :     {
; 278  :         /* Install a new markers table
; 279  :          */
; 280  :         input->markers  = antlr3VectorNew(0);

  00078	33 c9		 xor	 ecx, ecx
  0007a	e8 00 00 00 00	 call	 antlr3VectorNew
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00084	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax
$LN3@antlr3Inpu:

; 281  :     }
; 282  : }

  00088	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
antlr3InputReset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3InputClose
_TEXT	SEGMENT
input$ = 48
antlr3InputClose PROC					; COMDAT

; 204  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 205  :     // Close any markers in the input stream
; 206  :     //
; 207  :     if	(input->markers != NULL)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0000f	48 83 78 48 00	 cmp	 QWORD PTR [rax+72], 0
  00014	74 25		 je	 SHORT $LN2@antlr3Inpu

; 208  :     {
; 209  : 		input->markers->free(input->markers);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0001b	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0001f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00024	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00028	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 210  : 		input->markers = NULL;

  0002e	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00033	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0
$LN2@antlr3Inpu:

; 211  :     }
; 212  : 
; 213  :     // Close the string factory
; 214  :     //
; 215  :     if	(input->strFactory != NULL)

  0003b	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00040	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00045	74 15		 je	 SHORT $LN3@antlr3Inpu

; 216  :     {
; 217  : 		input->strFactory->close(input->strFactory);

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004c	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00050	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00055	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00059	ff 50 50	 call	 QWORD PTR [rax+80]
$LN3@antlr3Inpu:

; 218  :     }
; 219  : 
; 220  :     // Free the input stream buffer if we allocated it
; 221  :     //
; 222  :     if	(input->isAllocated && input->data != NULL)

  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00061	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00065	74 28		 je	 SHORT $LN4@antlr3Inpu
  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0006c	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00071	74 1c		 je	 SHORT $LN4@antlr3Inpu

; 223  :     {
; 224  : 		ANTLR3_FREE(input->data);

  00073	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00078	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 225  : 		input->data = NULL;

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00087	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN4@antlr3Inpu:

; 226  :     }
; 227  :     
; 228  :     input->istream->free(input->istream);

  0008f	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0009c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0009f	ff 50 78	 call	 QWORD PTR [rax+120]

; 229  : 
; 230  :     // Finally, free the space for the structure itself
; 231  :     //
; 232  :     ANTLR3_FREE(input);

  000a2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 233  : 
; 234  :     // Done
; 235  :     //
; 236  : }

  000ad	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b1	5f		 pop	 rdi
  000b2	c3		 ret	 0
antlr3InputClose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitGetSourceName
_TEXT	SEGMENT
is$ = 16
antlr38BitGetSourceName PROC				; COMDAT

; 194  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 195  : 	return	is->streamName;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR is$[rsp]
  0000b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]

; 196  : }

  0000f	5f		 pop	 rdi
  00010	c3		 ret	 0
antlr38BitGetSourceName ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSeek
_TEXT	SEGMENT
count$ = 32
input$ = 40
tv72 = 48
is$ = 80
seekPoint$ = 88
antlr38BitSeek PROC					; COMDAT

; 578  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 579  : 	ANTLR3_INT32   count;
; 580  : 	pANTLR3_INPUT_STREAM input;
; 581  : 
; 582  : 	input   = (pANTLR3_INPUT_STREAM)ANTLR3_FUNC_PTR(((pANTLR3_INPUT_STREAM) is->super));

  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 583  : 
; 584  : 	/* If the requested seek point is less than the current
; 585  : 	* input point, then we assume that we are resetting from a mark
; 586  : 	* and do not need to scan, but can just set to there.
; 587  : 	*/
; 588  : 	if	(seekPoint <= (ANTLR3_MARKER)(input->nextChar))

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00022	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00026	48 39 44 24 58	 cmp	 QWORD PTR seekPoint$[rsp], rax
  0002b	7f 10		 jg	 SHORT $LN4@antlr38Bit

; 589  : 	{
; 590  : 		input->nextChar	= ((pANTLR3_UINT8) seekPoint);

  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00032	48 8b 4c 24 58	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  00037	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 591  : 	}

  0003b	eb 40		 jmp	 SHORT $LN5@antlr38Bit
$LN4@antlr38Bit:

; 592  : 	else
; 593  : 	{
; 594  : 		count	= (ANTLR3_UINT32)(seekPoint - (ANTLR3_MARKER)(input->nextChar));

  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00042	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00046	48 8b 4c 24 58	 mov	 rcx, QWORD PTR seekPoint$[rsp]
  0004b	48 2b c8	 sub	 rcx, rax
  0004e	48 8b c1	 mov	 rax, rcx
  00051	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax
$LN2@antlr38Bit:

; 595  : 
; 596  : 		while (count--)

  00055	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  00059	89 44 24 30	 mov	 DWORD PTR tv72[rsp], eax
  0005d	8b 44 24 20	 mov	 eax, DWORD PTR count$[rsp]
  00061	ff c8		 dec	 eax
  00063	89 44 24 20	 mov	 DWORD PTR count$[rsp], eax
  00067	83 7c 24 30 00	 cmp	 DWORD PTR tv72[rsp], 0
  0006c	74 0f		 je	 SHORT $LN3@antlr38Bit

; 597  : 		{
; 598  : 			is->consume(is);

  0006e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00078	ff 50 28	 call	 QWORD PTR [rax+40]

; 599  : 		}

  0007b	eb d8		 jmp	 SHORT $LN2@antlr38Bit
$LN3@antlr38Bit:
$LN5@antlr38Bit:

; 600  : 	}
; 601  : }

  0007d	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
antlr38BitSeek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitRelease
_TEXT	SEGMENT
input$ = 0
is$ = 32
mark$ = 40
antlr38BitRelease PROC					; COMDAT

; 558  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 559  :     pANTLR3_INPUT_STREAM input;
; 560  : 
; 561  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 562  : 
; 563  :     /* We don't do much here in fact as we never free any higher marks in
; 564  :      * the hashtable as we just resuse any memory allocated for them.
; 565  :      */
; 566  :     input->markDepth	= (ANTLR3_UINT32)(mark - 1);

  0001c	48 8b 44 24 28	 mov	 rax, QWORD PTR mark$[rsp]
  00021	48 ff c8	 dec	 rax
  00024	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00028	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 567  : }

  0002b	48 83 c4 10	 add	 rsp, 16
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
antlr38BitRelease ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitRewindLast
_TEXT	SEGMENT
is$ = 48
antlr38BitRewindLast PROC				; COMDAT

; 505  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 506  :     is->rewind(is, is->lastMarker);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 50 18	 mov	 rdx, QWORD PTR [rax+24]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR is$[rsp]
  00018	48 8b 44 24 30	 mov	 rax, QWORD PTR is$[rsp]
  0001d	ff 50 48	 call	 QWORD PTR [rax+72]

; 507  : }

  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5f		 pop	 rdi
  00025	c3		 ret	 0
antlr38BitRewindLast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitRewind
_TEXT	SEGMENT
state$ = 32
input$ = 40
tv90 = 48
is$ = 80
mark$ = 88
antlr38BitRewind PROC					; COMDAT

; 518  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 519  :     pANTLR3_LEX_STATE	state;
; 520  :     pANTLR3_INPUT_STREAM input;
; 521  : 
; 522  :     input   = ((pANTLR3_INPUT_STREAM) is->super);

  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  00014	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00018	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 523  : 
; 524  :     /* Perform any clean up of the marks
; 525  :      */
; 526  :     input->istream->release(input->istream, mark);

  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 8b 54 24 58	 mov	 rdx, QWORD PTR mark$[rsp]
  0002a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  0002f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00032	ff 50 58	 call	 QWORD PTR [rax+88]

; 527  : 
; 528  :     /* Find the supplied mark state 
; 529  :      */
; 530  :     state   = (pANTLR3_LEX_STATE)input->markers->get(input->markers, (ANTLR3_UINT32)(mark - 1));

  00035	48 8b 44 24 58	 mov	 rax, QWORD PTR mark$[rsp]
  0003a	48 ff c8	 dec	 rax
  0003d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00042	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  00046	48 89 4c 24 30	 mov	 QWORD PTR tv90[rsp], rcx
  0004b	8b d0		 mov	 edx, eax
  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00052	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  00056	48 8b 44 24 30	 mov	 rax, QWORD PTR tv90[rsp]
  0005b	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  00061	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 531  : 	if (state == NULL) { return; }

  00066	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  0006c	75 02		 jne	 SHORT $LN2@antlr38Bit
  0006e	eb 55		 jmp	 SHORT $LN1@antlr38Bit
$LN2@antlr38Bit:

; 532  : 
; 533  :     /* Seek input pointer to the requested point (note we supply the void *pointer
; 534  :      * to whatever is implementing the int stream to seek).
; 535  :      */
; 536  :     antlr38BitSeek(is, (ANTLR3_MARKER)(state->nextChar));

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00075	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  0007d	e8 00 00 00 00	 call	 antlr38BitSeek

; 537  : 
; 538  :     /* Reset to the reset of the information in the mark
; 539  :      */
; 540  :     input->charPositionInLine	= state->charPositionInLine;

  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00087	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0008c	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0008f	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 541  :     input->currentLine		= state->currentLine;

  00092	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0009c	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000a0	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 542  :     input->line			= state->line;

  000a4	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000ae	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000b1	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 543  :     input->nextChar		= state->nextChar;

  000b4	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000b9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  000be	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000c1	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx
$LN1@antlr38Bit:

; 544  : 
; 545  :     /* And we are done
; 546  :      */
; 547  : }

  000c5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
antlr38BitRewind ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitMark
_TEXT	SEGMENT
state$ = 32
input$ = 40
tv140 = 48
is$ = 80
antlr38BitMark PROC					; COMDAT

; 446  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 447  :     pANTLR3_LEX_STATE	    state;
; 448  :     pANTLR3_INPUT_STREAM    input;
; 449  : 
; 450  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 44 24 28	 mov	 QWORD PTR input$[rsp], rax

; 451  : 
; 452  :     /* New mark point 
; 453  :      */
; 454  :     ++input->markDepth;

  00018	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  0001d	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00020	ff c0		 inc	 eax
  00022	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00027	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 455  : 
; 456  :     /* See if we are revisiting a mark as we can just reuse the vector
; 457  :      * entry if we are, otherwise, we need a new one
; 458  :      */
; 459  :     if	(input->markDepth > input->markers->count)

  0002a	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  0002f	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  00033	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00038	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003b	39 41 44	 cmp	 DWORD PTR [rcx+68], eax
  0003e	76 57		 jbe	 SHORT $LN2@antlr38Bit

; 460  :     {	
; 461  : 		state = (pANTLR3_LEX_STATE)ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));

  00040	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004b	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 462  : 		if (state == NULL)

  00050	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  00056	75 19		 jne	 SHORT $LN4@antlr38Bit

; 463  : 		{
; 464  : 			// malloc failed
; 465  : 			--input->markDepth;

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  0005d	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00060	ff c8		 dec	 eax
  00062	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00067	89 41 44	 mov	 DWORD PTR [rcx+68], eax

; 466  : 			return 0;

  0006a	33 c0		 xor	 eax, eax
  0006c	e9 b5 00 00 00	 jmp	 $LN1@antlr38Bit
$LN4@antlr38Bit:

; 467  : 		}
; 468  : 
; 469  : 		/* Add it to the table
; 470  : 		 */
; 471  : 		input->markers->add(input->markers, state, ANTLR3_FREE_FUNC);	/* No special structure, just free() on delete */

  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00076	48 8b 40 48	 mov	 rax, QWORD PTR [rax+72]
  0007a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_free
  00081	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  00086	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  0008b	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  0008f	ff 90 48 01 00
	00		 call	 QWORD PTR [rax+328]

; 472  :     }

  00095	eb 33		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 473  :     else
; 474  :     {
; 475  : 		state	= (pANTLR3_LEX_STATE)input->markers->get(input->markers, input->markDepth - 1);

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  0009c	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0009f	ff c8		 dec	 eax
  000a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000a6	48 8b 49 48	 mov	 rcx, QWORD PTR [rcx+72]
  000aa	48 89 4c 24 30	 mov	 QWORD PTR tv140[rsp], rcx
  000af	8b d0		 mov	 edx, eax
  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  000b6	48 8b 48 48	 mov	 rcx, QWORD PTR [rax+72]
  000ba	48 8b 44 24 30	 mov	 rax, QWORD PTR tv140[rsp]
  000bf	ff 90 28 01 00
	00		 call	 QWORD PTR [rax+296]
  000c5	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax
$LN3@antlr38Bit:

; 476  : 
; 477  : 		/* Assume no errors for speed, it will just blow up if the table failed
; 478  : 		 * for some reasons, hence lots of unit tests on the tables ;-)
; 479  : 		 */
; 480  :     }
; 481  : 
; 482  :     /* We have created or retrieved the state, so update it with the current
; 483  :      * elements of the lexer state.
; 484  :      */
; 485  :     state->charPositionInLine	= input->charPositionInLine;

  000ca	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000cf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000d4	8b 49 40	 mov	 ecx, DWORD PTR [rcx+64]
  000d7	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 486  :     state->currentLine		= input->currentLine;

  000da	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000e4	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000e8	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 487  :     state->line			= input->line;

  000ec	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  000f6	8b 49 34	 mov	 ecx, DWORD PTR [rcx+52]
  000f9	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 488  :     state->nextChar		= input->nextChar;

  000fc	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR input$[rsp]
  00106	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0010a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 489  : 
; 490  :     is->lastMarker  = input->markDepth;

  0010d	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00112	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00115	48 8b 4c 24 50	 mov	 rcx, QWORD PTR is$[rsp]
  0011a	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 491  : 
; 492  :     /* And that's it
; 493  :      */
; 494  :     return  input->markDepth;

  0011e	48 8b 44 24 28	 mov	 rax, QWORD PTR input$[rsp]
  00123	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
$LN1@antlr38Bit:

; 495  : }

  00126	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0012a	5f		 pop	 rdi
  0012b	c3		 ret	 0
antlr38BitMark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitIndex
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr38BitIndex PROC					; COMDAT

; 417  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 418  :     pANTLR3_INPUT_STREAM input;
; 419  : 
; 420  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 421  : 
; 422  :     return  (ANTLR3_MARKER)(((pANTLR3_UINT8)input->nextChar));

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]

; 423  : }

  0001f	48 83 c4 10	 add	 rsp, 16
  00023	5f		 pop	 rdi
  00024	c3		 ret	 0
antlr38BitIndex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitLA_ucase
_TEXT	SEGMENT
input$ = 32
is$ = 64
la$ = 72
antlr38BitLA_ucase PROC					; COMDAT

; 378  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 379  :     pANTLR3_INPUT_STREAM input;
; 380  : 	
; 381  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 382  : 
; 383  :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001c	48 63 44 24 48	 movsxd	 rax, DWORD PTR la$[rsp]
  00021	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00026	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0002a	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0002f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00034	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00037	48 8b 54 24 20	 mov	 rdx, QWORD PTR input$[rsp]
  0003c	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00040	48 3b c1	 cmp	 rax, rcx
  00043	72 09		 jb	 SHORT $LN2@antlr38Bit

; 384  :     {
; 385  : 		return	ANTLR3_CHARSTREAM_EOF;

  00045	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0004a	eb 1d		 jmp	 SHORT $LN1@antlr38Bit

; 386  :     }

  0004c	eb 1b		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 387  :     else
; 388  :     {
; 389  : 		return	(ANTLR3_UCHAR)toupper((*((pANTLR3_UINT8)input->nextChar + la - 1)));

  0004e	48 63 44 24 48	 movsxd	 rax, DWORD PTR la$[rsp]
  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR input$[rsp]
  00058	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  0005c	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
  00061	8b c8		 mov	 ecx, eax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
$LN3@antlr38Bit:
$LN1@antlr38Bit:

; 390  :     }
; 391  : }

  00069	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
antlr38BitLA_ucase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitLA
_TEXT	SEGMENT
input$ = 0
is$ = 32
la$ = 40
antlr38BitLA PROC					; COMDAT

; 351  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 10	 sub	 rsp, 16

; 352  :     pANTLR3_INPUT_STREAM input;
; 353  : 	
; 354  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000e	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  00013	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00017	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 355  : 
; 356  :     if	(( ((pANTLR3_UINT8)input->nextChar) + la - 1) >= (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  0001b	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  00020	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00024	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00028	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  0002d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00031	8b 49 30	 mov	 ecx, DWORD PTR [rcx+48]
  00034	48 8b 14 24	 mov	 rdx, QWORD PTR input$[rsp]
  00038	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0003c	48 3b c1	 cmp	 rax, rcx
  0003f	72 09		 jb	 SHORT $LN2@antlr38Bit

; 357  :     {
; 358  : 		return	ANTLR3_CHARSTREAM_EOF;

  00041	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00046	eb 14		 jmp	 SHORT $LN1@antlr38Bit

; 359  :     }

  00048	eb 12		 jmp	 SHORT $LN3@antlr38Bit
$LN2@antlr38Bit:

; 360  :     else
; 361  :     {
; 362  : 		return	(ANTLR3_UCHAR)(*((pANTLR3_UINT8)input->nextChar + la - 1));

  0004a	48 63 44 24 28	 movsxd	 rax, DWORD PTR la$[rsp]
  0004f	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00053	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00057	0f b6 44 01 ff	 movzx	 eax, BYTE PTR [rcx+rax-1]
$LN3@antlr38Bit:
$LN1@antlr38Bit:

; 363  :     }
; 364  : }

  0005c	48 83 c4 10	 add	 rsp, 16
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
antlr38BitLA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitConsume
_TEXT	SEGMENT
input$ = 0
is$ = 32
antlr38BitConsume PROC					; COMDAT

; 316  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 317  :     pANTLR3_INPUT_STREAM input;
; 318  : 
; 319  :     input   = ((pANTLR3_INPUT_STREAM) (is->super));

  0000a	48 8b 44 24 20	 mov	 rax, QWORD PTR is$[rsp]
  0000f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00013	48 89 04 24	 mov	 QWORD PTR input$[rsp], rax

; 320  : 
; 321  :     if	((pANTLR3_UINT8)(input->nextChar) < (((pANTLR3_UINT8)input->data) + input->sizeBuf))

  00017	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0001b	8b 40 30	 mov	 eax, DWORD PTR [rax+48]
  0001e	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00022	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  00026	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0002a	48 39 41 28	 cmp	 QWORD PTR [rcx+40], rax
  0002e	73 68		 jae	 SHORT $LN2@antlr38Bit

; 322  :     {	
; 323  : 	/* Indicate one more character in this line
; 324  : 	 */
; 325  : 	input->charPositionInLine++;

  00030	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00034	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00037	ff c0		 inc	 eax
  00039	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0003d	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 326  : 	
; 327  : 	if  ((ANTLR3_UCHAR)(*((pANTLR3_UINT8)input->nextChar)) == input->newlineChar)

  00040	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004b	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  0004f	3b 81 d0 00 00
	00		 cmp	 eax, DWORD PTR [rcx+208]
  00055	75 2e		 jne	 SHORT $LN3@antlr38Bit

; 328  : 	{
; 329  : 	    /* Reset for start of a new line of input
; 330  : 	     */
; 331  : 	    input->line++;

  00057	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0005b	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  0005e	ff c0		 inc	 eax
  00060	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00064	89 41 34	 mov	 DWORD PTR [rcx+52], eax

; 332  : 	    input->charPositionInLine	= 0;

  00067	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  0006b	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 333  : 	    input->currentLine		= (void *)(((pANTLR3_UINT8)input->nextChar) + 1);

  00072	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00076	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007a	48 ff c0	 inc	 rax
  0007d	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00081	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@antlr38Bit:

; 334  : 	}
; 335  : 
; 336  : 	/* Increment to next character position
; 337  : 	 */
; 338  : 	input->nextChar = (void *)(((pANTLR3_UINT8)input->nextChar) + 1);

  00085	48 8b 04 24	 mov	 rax, QWORD PTR input$[rsp]
  00089	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008d	48 ff c0	 inc	 rax
  00090	48 8b 0c 24	 mov	 rcx, QWORD PTR input$[rsp]
  00094	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax
$LN2@antlr38Bit:

; 339  :     }
; 340  : }

  00098	48 83 c4 10	 add	 rsp, 16
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
antlr38BitConsume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3GenericSetupStream
_TEXT	SEGMENT
input$ = 48
antlr3GenericSetupStream PROC				; COMDAT

; 137  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 138  :     /* Install function pointers for an 8 bit input
; 139  :      */
; 140  : 
; 141  :     /* Allocate stream interface
; 142  :      */
; 143  :     input->istream		= antlr3IntStreamNew();

  0000a	e8 00 00 00 00	 call	 antlr3IntStreamNew
  0000f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax

; 144  :     input->istream->type        = ANTLR3_CHARSTREAM;

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0001c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001f	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 145  :     input->istream->super       = input;

  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  00032	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 146  : 
; 147  :     /* Intstream API
; 148  :      */
; 149  :     input->istream->consume	    = antlr38BitConsume;	    // Consume the next 8 bit character in the buffer			

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitConsume
  00045	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 150  :     input->istream->_LA		    = antlr38BitLA;	            // Return the UTF32 character at offset n (1 based)			

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLA
  00058	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 151  :     input->istream->index	    = antlr38BitIndex;	            // Current index (offset from first character			    

  0005c	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00061	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitIndex
  0006b	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 152  :     input->istream->mark	    = antlr38BitMark;		    // Record the current lex state for later restore			

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00074	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitMark
  0007e	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 153  :     input->istream->rewind	    = antlr38BitRewind;	            // How to rewind the input									

  00082	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00087	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitRewind
  00091	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 154  :     input->istream->rewindLast	    = antlr38BitRewindLast;	    // How to rewind the input									

  00095	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0009a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitRewindLast
  000a4	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 155  :     input->istream->seek	    = antlr38BitSeek;		    // How to seek to a specific point in the stream		    

  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSeek
  000b7	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 156  :     input->istream->release	    = antlr38BitRelease;	    // Reset marks after mark n									

  000bb	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitRelease
  000ca	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 157  :     input->istream->getSourceName   = antlr38BitGetSourceName;      // Return a string that names the input source

  000ce	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000d3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetSourceName
  000dd	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 158  : 
; 159  :     /* Charstream API
; 160  :      */
; 161  :     input->close		    =  antlr3InputClose;	    // Close down the stream completely										

  000e1	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3InputClose
  000ed	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 162  :     input->free			    =  antlr3InputClose;	    // Synonym for free														

  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3InputClose
  000fd	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 163  :     input->reset		    =  antlr3InputReset;	    // Reset input to start	

  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3InputReset
  0010d	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 164  :     input->reuse                    =  antlr38BitReuse;             // Install a new input string and reset

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitReuse
  0011d	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 165  :     input->_LT			    =  antlr38BitLT;		    // Same as _LA for 8 bit file										

  00121	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitLT
  0012d	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 166  :     input->size			    =  antlr38BitSize;		    // Return the size of the input buffer									

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSize
  00140	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 167  :     input->substr		    =  antlr38BitSubstr;	    // Return a string from the input stream								

  00147	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSubstr
  00153	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 168  :     input->getLine		    =  antlr38BitGetLine;	    // Return the current line number in the input stream					

  0015a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetLine
  00166	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 169  :     input->getLineBuf		    =  antlr38BitGetLineBuf;	    // Return a pointer to the start of the current line being consumed	    

  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetLineBuf
  00179	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 170  :     input->getCharPositionInLine    =  antlr38BitGetCharPosition;   // Return the offset into the current line of input						

  00180	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitGetCharPosition
  0018c	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 171  :     input->setLine		    =  antlr38BitSetLine;	    // Set the input stream line number (does not set buffer pointers)	    

  00193	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetLine
  0019f	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 172  :     input->setCharPositionInLine    =  antlr38BitSetCharPosition;   // Set the offset in to the current line (does not set any pointers)   

  001a6	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetCharPosition
  001b2	48 89 88 c0 00
	00 00		 mov	 QWORD PTR [rax+192], rcx

; 173  :     input->SetNewLineChar	    =  antlr38BitSetNewLineChar;    // Set the value of the newline trigger character						

  001b9	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetNewLineChar
  001c5	48 89 88 c8 00
	00 00		 mov	 QWORD PTR [rax+200], rcx

; 174  :     input->setUcaseLA		    =  antlr38BitSetUcaseLA;        // Changes the LA function to return upper case always

  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr38BitSetUcaseLA
  001d8	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 175  : 
; 176  :     input->charByteSize		    = 1;		// Size in bytes of characters in this stream.

  001df	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001e4	c6 80 d4 00 00
	00 01		 mov	 BYTE PTR [rax+212], 1

; 177  : 
; 178  :     /* Initialize entries for tables etc
; 179  :      */
; 180  :     input->markers  = NULL;

  001eb	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  001f0	48 c7 40 48 00
	00 00 00	 mov	 QWORD PTR [rax+72], 0

; 181  : 
; 182  :     /* Set up the input stream brand new
; 183  :      */
; 184  :     input->reset(input);

  001f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  001fd	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00202	ff 50 70	 call	 QWORD PTR [rax+112]

; 185  :     
; 186  :     /* Install default line separator character (it can be replaced
; 187  :      * by the grammar programmer later)
; 188  :      */
; 189  :     input->SetNewLineChar(input, (ANTLR3_UCHAR)'\n');

  00205	ba 0a 00 00 00	 mov	 edx, 10
  0020a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0020f	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00214	ff 90 c8 00 00
	00		 call	 QWORD PTR [rax+200]

; 190  : }

  0021a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0021e	5f		 pop	 rdi
  0021f	c3		 ret	 0
antlr3GenericSetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3EBCDICSetupStream
_TEXT	SEGMENT
input$ = 48
antlr3EBCDICSetupStream PROC				; COMDAT

; 2021 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2022 :     // EBCDIC streams can use the standard 8 bit string factory
; 2023 :     //
; 2024 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00015	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0001f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 2025 : 
; 2026 :     // Generic API that does not care about endianess.
; 2027 :     //
; 2028 :     input->istream->_LA         = antlr3EBCDICLA;       // Return the UTF32 character at offset n (1 based)    

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3EBCDICLA
  00032	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 2029 :     input->charByteSize		= 1;	                // Size in bytes of characters in this stream.

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0003b	c6 80 d4 00 00
	00 01		 mov	 BYTE PTR [rax+212], 1

; 2030 : }

  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
antlr3EBCDICSetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF8SetupStream
_TEXT	SEGMENT
input$ = 48
antlr3UTF8SetupStream PROC				; COMDAT

; 1758 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1759 :     // Build a string factory for this stream. This is a UTF16 string factory which is a standard
; 1760 :     // part of the ANTLR3 string. The string factory is then passed through the whole chain of lexer->parser->tree->treeparser
; 1761 :     // and so on.
; 1762 :     //
; 1763 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00015	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0001f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1764 : 
; 1765 :     // Generic API that does not care about endianess.
; 1766 :     //
; 1767 :     input->istream->consume	= antlr3UTF8Consume;	// Consume the next UTF32 character in the buffer

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  00028	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF8Consume
  00032	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1768 :     input->istream->_LA         = antlr3UTF8LA;         // Return the UTF32 character at offset n (1 based)    

  00036	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF8LA
  00045	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1769 :     input->charByteSize		= 0;	                // Size in bytes of characters in this stream.

  00049	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0004e	c6 80 d4 00 00
	00 00		 mov	 BYTE PTR [rax+212], 0

; 1770 : }

  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
antlr3UTF8SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF32SetupStream
_TEXT	SEGMENT
tv76 = 32
input$ = 64
machineBigEndian$ = 72
inputBigEndian$ = 80
antlr3UTF32SetupStream PROC				; COMDAT

; 1508 : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1509 :     // Build a string factory for this stream. This is a UTF32 string factory which is a standard
; 1510 :     // part of the ANTLR3 string. The string factory is then passed through the whole chain of lexer->parser->tree->treeparser
; 1511 :     // and so on.
; 1512 :     //
; 1513 :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00018	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  0001e	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00028	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1514 : 
; 1515 :     // Generic API that does not care about endianess.
; 1516 :     //
; 1517 :     input->istream->index	    =  antlr3UTF32Index;            // Calculate current index in input stream, UTF16 based

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Index
  0003b	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 1518 :     input->substr		    =  antlr3UTF32Substr;	    // Return a string from the input stream

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Substr
  0004b	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 1519 :     input->istream->seek	    =  antlr3UTF32Seek;		    // How to seek to a specific point in the stream

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Seek
  00061	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1520 :     input->istream->consume	    =  antlr3UTF32Consume;	    // Consume the next UTF32 character in the buffer

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  0006a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32Consume
  00074	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 1521 : 
; 1522 :     // We must install different UTF32 LA routines according to whether the input
; 1523 :     // is the same endianess as the machine we are executing upon or not. If it is not
; 1524 :     // then we must install methods that can convert the endianess on the fly as they go
; 1525 :     //
; 1526 :     switch (machineBigEndian)

  00078	0f b6 44 24 48	 movzx	 eax, BYTE PTR machineBigEndian$[rsp]
  0007d	88 44 24 20	 mov	 BYTE PTR tv76[rsp], al
  00081	80 7c 24 20 00	 cmp	 BYTE PTR tv76[rsp], 0
  00086	74 3d		 je	 SHORT $LN7@antlr3UTF3
  00088	80 7c 24 20 01	 cmp	 BYTE PTR tv76[rsp], 1
  0008d	74 02		 je	 SHORT $LN4@antlr3UTF3
  0008f	eb 65		 jmp	 SHORT $LN2@antlr3UTF3
$LN4@antlr3UTF3:

; 1527 :     {
; 1528 :         case    ANTLR3_TRUE:
; 1529 : 
; 1530 :             // Machine is Big Endian, if the input is also then install the 
; 1531 :             // methods that do not access input by bytes and reverse them.
; 1532 :             // Otherwise install endian aware methods.
; 1533 :             //
; 1534 :             if  (inputBigEndian == ANTLR3_TRUE) 

  00091	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  00096	83 f8 01	 cmp	 eax, 1
  00099	75 15		 jne	 SHORT $LN5@antlr3UTF3

; 1535 :             {
; 1536 :                 // Input is machine compatible
; 1537 :                 //
; 1538 :                 input->istream->_LA         =  antlr3UTF32LA;		    // Return the UTF32 character at offset n (1 based)    

  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LA
  000aa	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1539 :             }

  000ae	eb 13		 jmp	 SHORT $LN6@antlr3UTF3
$LN5@antlr3UTF3:

; 1540 :             else
; 1541 :             {
; 1542 :                 // Need to use methods that know that the input is little endian
; 1543 :                 //
; 1544 :                 input->istream->_LA         =  antlr3UTF32LALE;		    // Return the UTF32 character at offset n (1 based) 

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LALE
  000bf	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN6@antlr3UTF3:

; 1545 :             }
; 1546 :             break;

  000c3	eb 31		 jmp	 SHORT $LN2@antlr3UTF3
$LN7@antlr3UTF3:

; 1547 : 
; 1548 :         case    ANTLR3_FALSE:
; 1549 : 
; 1550 :             // Machine is Little Endian, if the input is also then install the 
; 1551 :             // methods that do not access input by bytes and reverse them.
; 1552 :             // Otherwise install endian aware methods.
; 1553 :             //
; 1554 :             if  (inputBigEndian == ANTLR3_FALSE) 

  000c5	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  000ca	85 c0		 test	 eax, eax
  000cc	75 15		 jne	 SHORT $LN8@antlr3UTF3

; 1555 :             {
; 1556 :                 // Input is machine compatible
; 1557 :                 //
; 1558 :                 input->istream->_LA         =  antlr3UTF32LA;		    // Return the UTF32 character at offset n (1 based)    

  000ce	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000d3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LA
  000dd	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 1559 :             }

  000e1	eb 13		 jmp	 SHORT $LN9@antlr3UTF3
$LN8@antlr3UTF3:

; 1560 :             else
; 1561 :             {
; 1562 :                 // Need to use methods that know that the input is Big Endian
; 1563 :                 //
; 1564 :                 input->istream->_LA         =  antlr3UTF32LABE;		    // Return the UTF32 character at offset n (1 based) 

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF32LABE
  000f2	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN9@antlr3UTF3:
$LN2@antlr3UTF3:

; 1565 :             }
; 1566 :             break;
; 1567 :     }
; 1568 : 
; 1569 :     input->charByteSize		    = 4;			    // Size in bytes of characters in this stream.

  000f6	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fb	c6 80 d4 00 00
	00 04		 mov	 BYTE PTR [rax+212], 4

; 1570 : }

  00102	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00106	5f		 pop	 rdi
  00107	c3		 ret	 0
antlr3UTF32SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr3UTF16SetupStream
_TEXT	SEGMENT
tv74 = 32
input$ = 64
machineBigEndian$ = 72
inputBigEndian$ = 80
antlr3UTF16SetupStream PROC				; COMDAT

; 710  : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 711  :     // Build a string factory for this stream. This is a UTF16 string factory which is a standard
; 712  :     // part of the ANTLR3 string. The string factory is then passed through the whole chain 
; 713  :     // of lexer->parser->tree->treeparser and so on.
; 714  :     //
; 715  :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00018	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  0001e	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR input$[rsp]
  00028	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 716  : 
; 717  :     // Generic API that does not care about endianess.
; 718  :     //
; 719  :     input->istream->index	    =  antlr3UTF16Index;            // Calculate current index in input stream, UTF16 based

  0002c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00031	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Index
  0003b	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 720  :     input->substr		    =  antlr3UTF16Substr;	    // Return a string from the input stream

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Substr
  0004b	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 721  :     input->istream->seek	    =  antlr3UTF16Seek;		    // How to seek to a specific point in the stream

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00057	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Seek
  00061	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 722  : 
; 723  :     // We must install different UTF16 routines according to whether the input
; 724  :     // is the same endianess as the machine we are executing upon or not. If it is not
; 725  :     // then we must install methods that can convert the endianess on the fly as they go
; 726  :     //
; 727  : 
; 728  :     switch (machineBigEndian)

  00065	0f b6 44 24 48	 movzx	 eax, BYTE PTR machineBigEndian$[rsp]
  0006a	88 44 24 20	 mov	 BYTE PTR tv74[rsp], al
  0006e	80 7c 24 20 00	 cmp	 BYTE PTR tv74[rsp], 0
  00073	74 66		 je	 SHORT $LN7@antlr3UTF1
  00075	80 7c 24 20 01	 cmp	 BYTE PTR tv74[rsp], 1
  0007a	74 05		 je	 SHORT $LN4@antlr3UTF1
  0007c	e9 b1 00 00 00	 jmp	 $LN2@antlr3UTF1
$LN4@antlr3UTF1:

; 729  :     {
; 730  :         case    ANTLR3_TRUE:
; 731  : 
; 732  :             // Machine is Big Endian, if the input is also then install the 
; 733  :             // methods that do not access input by bytes and reverse them.
; 734  :             // Otherwise install endian aware methods.
; 735  :             //
; 736  :             if  (inputBigEndian == ANTLR3_TRUE) 

  00081	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  00086	83 f8 01	 cmp	 eax, 1
  00089	75 28		 jne	 SHORT $LN5@antlr3UTF1

; 737  :             {
; 738  :                 // Input is machine compatible
; 739  :                 //
; 740  :                 input->istream->consume	    =  antlr3UTF16Consume;	    // Consume the next UTF16 character in the buffer

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00090	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Consume
  0009a	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 741  :                 input->istream->_LA         =  antlr3UTF16LA;		    // Return the UTF32 character at offset n (1 based)    

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LA
  000ad	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 742  :             }

  000b1	eb 26		 jmp	 SHORT $LN6@antlr3UTF1
$LN5@antlr3UTF1:

; 743  :             else
; 744  :             {
; 745  :                 // Need to use methods that know that the input is little endian
; 746  :                 //
; 747  :                 input->istream->consume	    =  antlr3UTF16ConsumeLE;	    // Consume the next UTF16 character in the buffer

  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16ConsumeLE
  000c2	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 748  :                 input->istream->_LA         =  antlr3UTF16LALE;		    // Return the UTF32 character at offset n (1 based) 

  000c6	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LALE
  000d5	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN6@antlr3UTF1:

; 749  :             }
; 750  :             break;

  000d9	eb 57		 jmp	 SHORT $LN2@antlr3UTF1
$LN7@antlr3UTF1:

; 751  : 
; 752  :         case    ANTLR3_FALSE:
; 753  : 
; 754  :             // Machine is Little Endian, if the input is also then install the 
; 755  :             // methods that do not access input by bytes and reverse them.
; 756  :             // Otherwise install endian aware methods.
; 757  :             //
; 758  :             if  (inputBigEndian == ANTLR3_FALSE) 

  000db	0f b6 44 24 50	 movzx	 eax, BYTE PTR inputBigEndian$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	75 28		 jne	 SHORT $LN8@antlr3UTF1

; 759  :             {
; 760  :                 // Input is machine compatible
; 761  :                 //
; 762  :                 input->istream->consume	    =  antlr3UTF16Consume;	    // Consume the next UTF16 character in the buffer

  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16Consume
  000f3	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 763  :                 input->istream->_LA         =  antlr3UTF16LA;		    // Return the UTF32 character at offset n (1 based)    

  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  000fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LA
  00106	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 764  :             }

  0010a	eb 26		 jmp	 SHORT $LN9@antlr3UTF1
$LN8@antlr3UTF1:

; 765  :             else
; 766  :             {
; 767  :                 // Need to use methods that know that the input is Big Endian
; 768  :                 //
; 769  :                 input->istream->consume	    =  antlr3UTF16ConsumeBE;	    // Consume the next UTF16 character in the buffer

  0010c	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00111	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16ConsumeBE
  0011b	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 770  :                 input->istream->_LA         =  antlr3UTF16LABE;		    // Return the UTF32 character at offset n (1 based) 

  0011f	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00124	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:antlr3UTF16LABE
  0012e	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx
$LN9@antlr3UTF1:
$LN2@antlr3UTF1:

; 771  :             }
; 772  :             break;
; 773  :     }
; 774  : 
; 775  :         
; 776  :     input->charByteSize		    = 2;			    // Size in bytes of characters in this stream.

  00132	48 8b 44 24 40	 mov	 rax, QWORD PTR input$[rsp]
  00137	c6 80 d4 00 00
	00 02		 mov	 BYTE PTR [rax+212], 2

; 777  : 
; 778  : }

  0013e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00142	5f		 pop	 rdi
  00143	c3		 ret	 0
antlr3UTF16SetupStream ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3inputstream.c
;	COMDAT antlr38BitSetupStream
_TEXT	SEGMENT
input$ = 48
antlr38BitSetupStream PROC				; COMDAT

; 126  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 127  :     // Build a string factory for this stream
; 128  :     //
; 129  :     input->strFactory	= antlr3StringFactoryNew(input->encoding);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR input$[rsp]
  0000f	8b 88 d8 00 00
	00		 mov	 ecx, DWORD PTR [rax+216]
  00015	e8 00 00 00 00	 call	 antlr3StringFactoryNew
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR input$[rsp]
  0001f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 130  : 
; 131  :     // Default stream API set up is for 8Bit, so we are done
; 132  :     //
; 133  : }

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5f		 pop	 rdi
  00028	c3		 ret	 0
antlr38BitSetupStream ENDP
_TEXT	ENDS
END
