; Listing generated by Microsoft (R) Optimizing Compiler Version 19.37.32822.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	antlr3StringFactoryNew
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isprint:PROC
EXTRN	memmove:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	ConvertUTF16toUTF8:PROC
EXTRN	antlr3VectorNew:PROC
EXTRN	_RTC_CheckStackVars:PROC
EXTRN	_RTC_InitBase:PROC
EXTRN	_RTC_Shutdown:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$__local_stdio_printf_options DD imagerel $LN3
	DD	imagerel $LN3+11
	DD	imagerel $unwind$__local_stdio_printf_options
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+120
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+122
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$antlr3StringFactoryNew DD imagerel $LN19
	DD	imagerel $LN19+585
	DD	imagerel $unwind$antlr3StringFactoryNew
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newRaw8 DD imagerel newRaw8
	DD	imagerel newRaw8+153
	DD	imagerel $unwind$newRaw8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newRawUTF16 DD imagerel newRawUTF16
	DD	imagerel newRawUTF16+153
	DD	imagerel $unwind$newRawUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newSize8 DD imagerel newSize8
	DD	imagerel newSize8+121
	DD	imagerel $unwind$newSize8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newSizeUTF16 DD imagerel newSizeUTF16
	DD	imagerel newSizeUTF16+125
	DD	imagerel $unwind$newSizeUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPtr8 DD imagerel newPtr8
	DD	imagerel newPtr8+142
	DD	imagerel $unwind$newPtr8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPtrUTF16_8 DD imagerel newPtrUTF16_8
	DD	imagerel newPtrUTF16_8+245
	DD	imagerel $unwind$newPtrUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newPtrUTF16_UTF16 DD imagerel newPtrUTF16_UTF16
	DD	imagerel newPtrUTF16_UTF16+147
	DD	imagerel $unwind$newPtrUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newStr8 DD imagerel newStr8
	DD	imagerel newStr8+52
	DD	imagerel $unwind$newStr8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newStrUTF16_8 DD imagerel newStrUTF16_8
	DD	imagerel newStrUTF16_8+52
	DD	imagerel $unwind$newStrUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newStrUTF16_UTF16 DD imagerel newStrUTF16_UTF16
	DD	imagerel newStrUTF16_UTF16+132
	DD	imagerel $unwind$newStrUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$destroy DD imagerel destroy
	DD	imagerel destroy+157
	DD	imagerel $unwind$destroy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printable8 DD imagerel printable8
	DD	imagerel printable8+375
	DD	imagerel $unwind$printable8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printableUTF16 DD imagerel printableUTF16
	DD	imagerel printableUTF16+441
	DD	imagerel $unwind$printableUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closeFactory DD imagerel closeFactory
	DD	imagerel closeFactory+49
	DD	imagerel $unwind$closeFactory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$set8 DD	imagerel set8
	DD	imagerel set8+172
	DD	imagerel $unwind$set8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setUTF16_8 DD imagerel setUTF16_8
	DD	imagerel setUTF16_8+246
	DD	imagerel $unwind$setUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setUTF16_UTF16 DD imagerel setUTF16_UTF16
	DD	imagerel setUTF16_UTF16+256
	DD	imagerel $unwind$setUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$append8 DD imagerel append8
	DD	imagerel append8+218
	DD	imagerel $unwind$append8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$appendUTF16_8 DD imagerel appendUTF16_8
	DD	imagerel appendUTF16_8+292
	DD	imagerel $unwind$appendUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$appendUTF16_UTF16 DD imagerel appendUTF16_UTF16
	DD	imagerel appendUTF16_UTF16+306
	DD	imagerel $unwind$appendUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insert8 DD imagerel insert8
	DD	imagerel insert8+357
	DD	imagerel $unwind$insert8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertUTF16_8 DD imagerel insertUTF16_8
	DD	imagerel insertUTF16_8+421
	DD	imagerel $unwind$insertUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertUTF16_UTF16 DD imagerel insertUTF16_UTF16
	DD	imagerel insertUTF16_UTF16+453
	DD	imagerel $unwind$insertUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setS DD	imagerel setS
	DD	imagerel setS+43
	DD	imagerel $unwind$setS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$appendS DD imagerel appendS
	DD	imagerel appendS+98
	DD	imagerel $unwind$appendS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertS DD imagerel insertS
	DD	imagerel insertS+51
	DD	imagerel $unwind$insertS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addc8 DD	imagerel addc8
	DD	imagerel addc8+195
	DD	imagerel $unwind$addc8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addcUTF16 DD imagerel addcUTF16
	DD	imagerel addcUTF16+209
	DD	imagerel $unwind$addcUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addi8 DD	imagerel addi8
	DD	imagerel addi8+143
	DD	imagerel $unwind$addi8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addiUTF16 DD imagerel addiUTF16
	DD	imagerel addiUTF16+143
	DD	imagerel $unwind$addiUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inserti8 DD imagerel inserti8
	DD	imagerel inserti8+155
	DD	imagerel $unwind$inserti8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$insertiUTF16 DD imagerel insertiUTF16
	DD	imagerel insertiUTF16+155
	DD	imagerel $unwind$insertiUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compare8 DD imagerel compare8
	DD	imagerel compare8+40
	DD	imagerel $unwind$compare8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compareUTF16_8 DD imagerel compareUTF16_8
	DD	imagerel compareUTF16_8+135
	DD	imagerel $unwind$compareUTF16_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compareUTF16_UTF16 DD imagerel compareUTF16_UTF16
	DD	imagerel compareUTF16_UTF16+146
	DD	imagerel $unwind$compareUTF16_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$compareS DD imagerel compareS
	DD	imagerel compareS+46
	DD	imagerel $unwind$compareS
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charAt8 DD imagerel charAt8
	DD	imagerel charAt8+49
	DD	imagerel $unwind$charAt8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$charAtUTF16 DD imagerel charAtUTF16
	DD	imagerel charAtUTF16+49
	DD	imagerel $unwind$charAtUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$subString8 DD imagerel subString8
	DD	imagerel subString8+123
	DD	imagerel $unwind$subString8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$subStringUTF16 DD imagerel subStringUTF16
	DD	imagerel subStringUTF16+127
	DD	imagerel $unwind$subStringUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toInt32_8 DD imagerel toInt32_8
	DD	imagerel toInt32_8+31
	DD	imagerel $unwind$toInt32_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toInt32_UTF16 DD imagerel toInt32_UTF16
	DD	imagerel toInt32_UTF16+214
	DD	imagerel $unwind$toInt32_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$to8_8 DD	imagerel to8_8
	DD	imagerel to8_8+13
	DD	imagerel $unwind$to8_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$to8_UTF16 DD imagerel to8_UTF16
	DD	imagerel to8_UTF16+260
	DD	imagerel $unwind$to8_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toUTF8_8 DD imagerel toUTF8_8
	DD	imagerel toUTF8_8+53
	DD	imagerel $unwind$toUTF8_8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$toUTF8_UTF16 DD imagerel toUTF8_UTF16
	DD	imagerel toUTF8_UTF16+348
	DD	imagerel $unwind$toUTF8_UTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringInit8 DD imagerel stringInit8
	DD	imagerel stringInit8+398
	DD	imagerel $unwind$stringInit8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringInitUTF16 DD imagerel stringInitUTF16
	DD	imagerel stringInitUTF16+398
	DD	imagerel $unwind$stringInitUTF16
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$stringFree DD imagerel stringFree
	DD	imagerel stringFree+54
	DD	imagerel $unwind$stringFree
pdata	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
_RTC_Shutdown.rtc$TMZ DQ FLAT:_RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
_RTC_InitBase.rtc$IMZ DQ FLAT:_RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringFree DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringInitUTF16 DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$stringInit8 DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toUTF8_UTF16 DD 022601H
	DD	07006f20dH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
toUTF8_UTF16$rtcName$0 DB 06fH
	DB	075H
	DB	074H
	DB	070H
	DB	075H
	DB	074H
	DB	045H
	DB	06eH
	DB	064H
	DB	00H
	ORG $+6
toUTF8_UTF16$rtcName$1 DB 069H
	DB	06eH
	DB	070H
	DB	075H
	DB	074H
	DB	045H
	DB	06eH
	DB	064H
	DB	00H
	ORG $+7
toUTF8_UTF16$rtcVarDesc DD 058H
	DD	08H
	DQ	FLAT:toUTF8_UTF16$rtcName$1
	DD	038H
	DD	08H
	DQ	FLAT:toUTF8_UTF16$rtcName$0
	ORG $+96
toUTF8_UTF16$rtcFrameData DD 02H
	DD	00H
	DQ	FLAT:toUTF8_UTF16$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toUTF8_8 DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to8_UTF16 DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$to8_8 DD 010601H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toInt32_UTF16 DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$toInt32_8 DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subStringUTF16 DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$subString8 DD 021301H
	DD	0700f5213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charAtUTF16 DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$charAt8 DD 010a01H
	DD	0700aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compareS DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compareUTF16_UTF16 DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compareUTF16_8 DD 020f01H
	DD	0700b120fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compare8 DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	088H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertiUTF16 DD 023b19H
	DD	0700fd213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
insertiUTF16$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
insertiUTF16$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:insertiUTF16$rtcName$0
	ORG $+48
insertiUTF16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:insertiUTF16$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
	DB	088H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inserti8 DD 023b19H
	DD	0700fd213H
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
inserti8$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
inserti8$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:inserti8$rtcName$0
	ORG $+48
inserti8$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:inserti8$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	031H
	DB	07cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addiUTF16 DD 023619H
	DD	0700ad20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
addiUTF16$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
addiUTF16$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:addiUTF16$rtcName$0
	ORG $+48
addiUTF16$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:addiUTF16$rtcVarDesc
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	031H
	DB	07cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addi8 DD 023619H
	DD	0700ad20eH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
addi8$rtcName$0 DB 06eH
	DB	065H
	DB	077H
	DB	062H
	DB	069H
	DB	074H
	DB	00H
	ORG $+9
addi8$rtcVarDesc DD 028H
	DD	020H
	DQ	FLAT:addi8$rtcName$0
	ORG $+48
addi8$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:addi8$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addcUTF16 DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addc8 DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertS DD 021301H
	DD	0700f3213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$appendS DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setS DD	020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertUTF16_UTF16 DD 021301H
	DD	0700f9213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insertUTF16_8 DD 021301H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$insert8 DD 021301H
	DD	0700f7213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$appendUTF16_UTF16 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$appendUTF16_8 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$append8 DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setUTF16_UTF16 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setUTF16_8 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$set8 DD	020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closeFactory DD 020a01H
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printableUTF16 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printable8 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$destroy DD 020f01H
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newStrUTF16_UTF16 DD 020f01H
	DD	0700b720fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newStrUTF16_8 DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newStr8 DD 020f01H
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPtrUTF16_UTF16 DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPtrUTF16_8 DD 021401H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newPtr8 DD 021401H
	DD	070105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newSizeUTF16 DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newSize8 DD 020e01H
	DD	0700a520eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newRawUTF16 DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newRaw8 DD 020a01H
	DD	07006720aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$antlr3StringFactoryNew DD 020901H
	DD	070055209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 022f01H
	DD	070159219H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
sprintf$rtcName$0 DB 05fH
	DB	041H
	DB	072H
	DB	067H
	DB	04cH
	DB	069H
	DB	073H
	DB	074H
	DB	00H
	ORG $+7
sprintf$rtcVarDesc DD 038H
	DD	08H
	DQ	FLAT:sprintf$rtcName$0
	ORG $+48
sprintf$rtcFrameData DD 01H
	DD	00H
	DQ	FLAT:sprintf$rtcVarDesc
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 021901H
	DD	070155219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 021901H
	DD	070157219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$__local_stdio_printf_options DD 010201H
	DD	07002H
xdata	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT stringFree
_TEXT	SEGMENT
string$ = 48
stringFree PROC						; COMDAT

; 240  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 241  :     /* First free the string itself if there was anything in it
; 242  :      */
; 243  :     if	(string->chars)

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0000f	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00014	74 0f		 je	 SHORT $LN2@stringFree

; 244  :     {
; 245  : 	ANTLR3_FREE(string->chars);

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0001b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@stringFree:

; 246  :     }
; 247  : 
; 248  :     /* Now free the space for this string
; 249  :      */
; 250  :     ANTLR3_FREE(string);

  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 251  : 
; 252  :     return;
; 253  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
stringFree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT stringInitUTF16
_TEXT	SEGMENT
string$ = 16
stringInitUTF16 PROC					; COMDAT

; 298  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 299  :     string->len		= 0;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 300  :     string->size	= 0;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00017	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 301  :     string->chars	= NULL;

  0001e	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 302  :     string->encoding	= ANTLR3_ENC_8BIT;

  0002b	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00030	c6 40 1c 04	 mov	 BYTE PTR [rax+28], 4

; 303  : 
; 304  :     /* API for UTF16 strings */
; 305  : 
; 306  :     string->set		= setUTF16_UTF16;

  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setUTF16_UTF16
  00040	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 307  :     string->set8	= setUTF16_8;

  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setUTF16_8
  00050	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 308  :     string->append	= appendUTF16_UTF16;

  00054	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendUTF16_UTF16
  00060	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 309  :     string->append8	= appendUTF16_8;

  00064	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendUTF16_8
  00070	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 310  :     string->insert	= insertUTF16_UTF16;

  00074	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertUTF16_UTF16
  00080	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 311  :     string->insert8	= insertUTF16_8;

  00084	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertUTF16_8
  00090	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 312  :     string->addi	= addiUTF16;

  00094	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addiUTF16
  000a0	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 313  :     string->inserti	= insertiUTF16;

  000a4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertiUTF16
  000b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 314  :     string->addc	= addcUTF16;

  000b4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addcUTF16
  000c0	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 315  :     string->charAt	= charAtUTF16;

  000c4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:charAtUTF16
  000d0	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 316  :     string->compare	= compareUTF16_UTF16;

  000d7	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareUTF16_UTF16
  000e3	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 317  :     string->compare8	= compareUTF16_8;

  000ea	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareUTF16_8
  000f6	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 318  :     string->subString	= subStringUTF16;

  000fd	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:subStringUTF16
  00109	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 319  :     string->toInt32	= toInt32_UTF16;

  00110	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toInt32_UTF16
  0011c	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 320  :     string->to8		= to8_UTF16;

  00123	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:to8_UTF16
  0012f	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 321  :     string->toUTF8	= toUTF8_UTF16;

  00136	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toUTF8_UTF16
  00142	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 322  : 
; 323  :     string->compareS	= compareS;

  00149	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareS
  00155	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 324  :     string->setS	= setS;

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setS
  00168	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 325  :     string->appendS	= appendS;

  0016c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendS
  00178	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 326  :     string->insertS	= insertS;

  0017c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertS
  00188	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 327  : }

  0018c	5f		 pop	 rdi
  0018d	c3		 ret	 0
stringInitUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT stringInit8
_TEXT	SEGMENT
string$ = 16
stringInit8 PROC					; COMDAT

; 261  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 262  :     string->len			= 0;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000b	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 263  :     string->size		= 0;

  00012	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00017	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [rax+20], 0

; 264  :     string->chars		= NULL;

  0001e	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00023	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 265  :     string->encoding	= ANTLR3_ENC_8BIT ;

  0002b	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00030	c6 40 1c 04	 mov	 BYTE PTR [rax+28], 4

; 266  : 
; 267  :     /* API for 8 bit strings*/
; 268  : 
; 269  :     string->set		= set8;

  00034	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:set8
  00040	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 270  :     string->set8	= set8;

  00044	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:set8
  00050	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 271  :     string->append	= append8;

  00054	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:append8
  00060	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 272  :     string->append8	= append8;

  00064	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:append8
  00070	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 273  :     string->insert	= insert8;

  00074	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insert8
  00080	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 274  :     string->insert8	= insert8;

  00084	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insert8
  00090	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 275  :     string->addi	= addi8;

  00094	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00099	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addi8
  000a0	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 276  :     string->inserti	= inserti8;

  000a4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:inserti8
  000b0	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 277  :     string->addc	= addc8;

  000b4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:addc8
  000c0	48 89 48 70	 mov	 QWORD PTR [rax+112], rcx

; 278  :     string->charAt	= charAt8;

  000c4	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:charAt8
  000d0	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 279  :     string->compare	= compare8;

  000d7	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compare8
  000e3	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 280  :     string->compare8	= compare8;

  000ea	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compare8
  000f6	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 281  :     string->subString	= subString8;

  000fd	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:subString8
  00109	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 282  :     string->toInt32	= toInt32_8;

  00110	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toInt32_8
  0011c	48 89 88 a8 00
	00 00		 mov	 QWORD PTR [rax+168], rcx

; 283  :     string->to8		= to8_8;

  00123	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:to8_8
  0012f	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 284  :     string->toUTF8	= toUTF8_8;

  00136	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:toUTF8_8
  00142	48 89 88 b8 00
	00 00		 mov	 QWORD PTR [rax+184], rcx

; 285  :     string->compareS	= compareS;

  00149	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:compareS
  00155	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 286  :     string->setS	= setS;

  0015c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:setS
  00168	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 287  :     string->appendS	= appendS;

  0016c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:appendS
  00178	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 288  :     string->insertS	= insertS;

  0017c	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:insertS
  00188	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 289  : 
; 290  : }

  0018c	5f		 pop	 rdi
  0018d	c3		 ret	 0
stringInit8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT toUTF8_UTF16
_TEXT	SEGMENT
outputEnd$ = 56
inputEnd$ = 88
utf8String$ = 104
cResult$ = 112
string$ = 144
toUTF8_UTF16 PROC					; COMDAT

; 361  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000d	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  00012	b9 14 00 00 00	 mov	 ecx, 20
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR [rsp+144]

; 362  : 
; 363  :     UTF8	      * outputEnd;	
; 364  :     UTF16	      * inputEnd;
; 365  :     pANTLR3_STRING	utf8String;
; 366  : 
; 367  :     ConversionResult	cResult;
; 368  : 
; 369  :     // Allocate the output buffer, which needs to accommodate potentially
; 370  :     // 3X (in bytes) the input size (in chars).
; 371  :     //
; 372  :     utf8String	= string->factory->newStr8(string->factory, (pANTLR3_UINT8)"");

  00026	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  0002e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00031	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
  00038	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  00040	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00043	ff 50 38	 call	 QWORD PTR [rax+56]
  00046	48 89 44 24 68	 mov	 QWORD PTR utf8String$[rsp], rax

; 373  : 
; 374  :     if	(utf8String != NULL)

  0004b	48 83 7c 24 68
	00		 cmp	 QWORD PTR utf8String$[rsp], 0
  00051	0f 84 e2 00 00
	00		 je	 $LN2@toUTF8_UTF

; 375  :     {
; 376  :         // Free existing allocation
; 377  :         //
; 378  :         ANTLR3_FREE(utf8String->chars);

  00057	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  0005c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 379  : 
; 380  :         // Reallocate according to maximum expected size
; 381  :         //
; 382  :         utf8String->size	= string->len *3;

  00066	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  0006e	6b 40 10 03	 imul	 eax, DWORD PTR [rax+16], 3
  00072	48 8b 4c 24 68	 mov	 rcx, QWORD PTR utf8String$[rsp]
  00077	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 383  :         utf8String->chars	= (pANTLR3_UINT8)ANTLR3_MALLOC(utf8String->size +1);

  0007a	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  0007f	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  00082	ff c0		 inc	 eax
  00084	8b c0		 mov	 eax, eax
  00086	8b c8		 mov	 ecx, eax
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0008e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR utf8String$[rsp]
  00093	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 384  : 
; 385  :         if	(utf8String->chars != NULL)

  00097	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  0009c	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  000a1	0f 84 92 00 00
	00		 je	 $LN3@toUTF8_UTF

; 386  :         {
; 387  :             inputEnd  = (UTF16 *)	(string->chars);

  000a7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  000af	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000b3	48 89 44 24 58	 mov	 QWORD PTR inputEnd$[rsp], rax

; 388  :             outputEnd = (UTF8 *)	(utf8String->chars);

  000b8	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  000bd	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000c1	48 89 44 24 38	 mov	 QWORD PTR outputEnd$[rsp], rax

; 389  : 
; 390  :             // Call the Unicode converter
; 391  :             //
; 392  :             cResult =  ConvertUTF16toUTF8

  000c6	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  000cb	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  000ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR outputEnd$[rsp]
  000d3	48 8d 44 01 ff	 lea	 rax, QWORD PTR [rcx+rax-1]
  000d8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  000e0	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000e3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR string$[rsp]
  000eb	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000ef	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  000f3	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000fb	4c 8b c8	 mov	 r9, rax
  000fe	4c 8d 44 24 38	 lea	 r8, QWORD PTR outputEnd$[rsp]
  00103	48 8b d1	 mov	 rdx, rcx
  00106	48 8d 4c 24 58	 lea	 rcx, QWORD PTR inputEnd$[rsp]
  0010b	e8 00 00 00 00	 call	 ConvertUTF16toUTF8
  00110	89 44 24 70	 mov	 DWORD PTR cResult$[rsp], eax

; 393  :                 (
; 394  :                 (const UTF16**)&inputEnd, 
; 395  :                 ((const UTF16 *)(string->chars)) + string->len, 
; 396  :                 &outputEnd, 
; 397  :                 outputEnd + utf8String->size - 1,
; 398  :                 lenientConversion
; 399  :                 );
; 400  : 
; 401  :             // We don't really care if things failed or not here, we just converted
; 402  :             // everything that was vaguely possible and stopped when it wasn't. It is
; 403  :             // up to the grammar programmer to verify that the input is sensible.
; 404  :             //
; 405  :             utf8String->len = ANTLR3_UINT32_CAST(((pANTLR3_UINT8)outputEnd) - utf8String->chars);

  00114	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]
  00119	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0011d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR outputEnd$[rsp]
  00122	48 2b c8	 sub	 rcx, rax
  00125	48 8b c1	 mov	 rax, rcx
  00128	48 8b 4c 24 68	 mov	 rcx, QWORD PTR utf8String$[rsp]
  0012d	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 406  : 
; 407  :             *(outputEnd+1) = '\0';		// Always null terminate

  00130	48 8b 44 24 38	 mov	 rax, QWORD PTR outputEnd$[rsp]
  00135	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
$LN3@toUTF8_UTF:
$LN2@toUTF8_UTF:

; 408  :         }
; 409  :     }
; 410  :     return utf8String;

  00139	48 8b 44 24 68	 mov	 rax, QWORD PTR utf8String$[rsp]

; 411  : }

  0013e	48 8b f8	 mov	 rdi, rax
  00141	48 8b cc	 mov	 rcx, rsp
  00144	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:toUTF8_UTF16$rtcFrameData
  0014b	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00150	48 8b c7	 mov	 rax, rdi
  00153	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0015a	5f		 pop	 rdi
  0015b	c3		 ret	 0
toUTF8_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT toUTF8_8
_TEXT	SEGMENT
string$ = 48
toUTF8_8 PROC						; COMDAT

; 350  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 351  : 	return string->factory->newPtr(string->factory, (pANTLR3_UINT8)(string->chars), string->len);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00017	44 8b 41 10	 mov	 r8d, DWORD PTR [rcx+16]
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00020	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00029	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002c	ff 50 20	 call	 QWORD PTR [rax+32]

; 352  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5f		 pop	 rdi
  00034	c3		 ret	 0
toUTF8_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT to8_UTF16
_TEXT	SEGMENT
newStr$ = 32
i$ = 40
c$1 = 44
tv128 = 48
string$ = 80
to8_UTF16 PROC						; COMDAT

; 1426 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1427 : 	pANTLR3_STRING  newStr;
; 1428 : 	ANTLR3_UINT32   i;
; 1429 : 
; 1430 : 	/* Create a new 8 bit string
; 1431 : 	*/
; 1432 : 	newStr  = newRaw8(string->factory);

  0000a	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0000f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00012	e8 00 00 00 00	 call	 newRaw8
  00017	48 89 44 24 20	 mov	 QWORD PTR newStr$[rsp], rax

; 1433 : 
; 1434 : 	if	(newStr == NULL)

  0001c	48 83 7c 24 20
	00		 cmp	 QWORD PTR newStr$[rsp], 0
  00022	75 07		 jne	 SHORT $LN5@to8_UTF16

; 1435 : 	{
; 1436 : 		return	NULL;

  00024	33 c0		 xor	 eax, eax
  00026	e9 d3 00 00 00	 jmp	 $LN1@to8_UTF16
$LN5@to8_UTF16:

; 1437 : 	}
; 1438 : 
; 1439 : 	/* Always add one more byte for a terminator
; 1440 : 	*/
; 1441 : 	newStr->chars   = (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(string->len + 1));

  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00030	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00033	ff c0		 inc	 eax
  00035	8b c0		 mov	 eax, eax
  00037	8b c8		 mov	 ecx, eax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  00044	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1442 : 	if (newStr->chars != NULL)

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
  0004d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00052	0f 84 a1 00 00
	00		 je	 $LN6@to8_UTF16

; 1443 : 	{
; 1444 : 		newStr->size    = string->len + 1;

  00058	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0005d	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00060	ff c0		 inc	 eax
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  00067	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 1445 : 		newStr->len	    = string->len;

  0006a	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00074	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00077	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1446 : 
; 1447 : 		/* Now copy each UTF16 charActer , making it an 8 bit character of 
; 1448 : 		* some sort.
; 1449 : 		*/
; 1450 : 		for	(i=0; i<string->len; i++)

  0007a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00082	eb 0a		 jmp	 SHORT $LN4@to8_UTF16
$LN2@to8_UTF16:
  00084	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
$LN4@to8_UTF16:
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00093	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00096	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  0009a	73 48		 jae	 SHORT $LN3@to8_UTF16

; 1451 : 		{
; 1452 : 			ANTLR3_UCHAR	c;
; 1453 : 
; 1454 : 			c = *(((pANTLR3_UINT16)(string->chars)) + i);

  0009c	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000a5	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000a9	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000ad	89 44 24 2c	 mov	 DWORD PTR c$1[rsp], eax

; 1455 : 
; 1456 : 			*(newStr->chars + i) = (ANTLR3_UINT8)(c > 255 ? '_' : c);

  000b1	81 7c 24 2c ff
	00 00 00	 cmp	 DWORD PTR c$1[rsp], 255	; 000000ffH
  000b9	76 0a		 jbe	 SHORT $LN8@to8_UTF16
  000bb	c7 44 24 30 5f
	00 00 00	 mov	 DWORD PTR tv128[rsp], 95 ; 0000005fH
  000c3	eb 08		 jmp	 SHORT $LN9@to8_UTF16
$LN8@to8_UTF16:
  000c5	8b 44 24 2c	 mov	 eax, DWORD PTR c$1[rsp]
  000c9	89 44 24 30	 mov	 DWORD PTR tv128[rsp], eax
$LN9@to8_UTF16:
  000cd	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  000d1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  000d6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000da	0f b6 54 24 30	 movzx	 edx, BYTE PTR tv128[rsp]
  000df	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 1457 : 		}

  000e2	eb a0		 jmp	 SHORT $LN2@to8_UTF16
$LN3@to8_UTF16:

; 1458 : 
; 1459 : 		/* Terminate
; 1460 : 		*/
; 1461 : 		*(newStr->chars + newStr->len) = '\0';

  000e4	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
  000e9	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newStr$[rsp]
  000f1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN6@to8_UTF16:

; 1462 : 	}
; 1463 : 
; 1464 : 	return newStr;

  000f9	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]
$LN1@to8_UTF16:

; 1465 : }

  000fe	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00102	5f		 pop	 rdi
  00103	c3		 ret	 0
to8_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT to8_8
_TEXT	SEGMENT
string$ = 16
to8_8	PROC						; COMDAT

; 1416 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi

; 1417 :     return  string;

  00006	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]

; 1418 : }

  0000b	5f		 pop	 rdi
  0000c	c3		 ret	 0
to8_8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT toInt32_UTF16
_TEXT	SEGMENT
input$ = 32
value$ = 40
negate$ = 44
tv85 = 48
string$ = 80
toInt32_UTF16 PROC					; COMDAT

; 1382 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1383 :     pANTLR3_UINT16  input;
; 1384 :     ANTLR3_INT32   value;
; 1385 :     ANTLR3_BOOLEAN  negate;
; 1386 : 
; 1387 :     value   = 0;

  0000a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR value$[rsp], 0

; 1388 :     input   = (pANTLR3_UINT16)(string->chars);

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00017	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001b	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1389 :     negate  = ANTLR3_FALSE;

  00020	c6 44 24 2c 00	 mov	 BYTE PTR negate$[rsp], 0

; 1390 : 
; 1391 :     if	(*input == (ANTLR3_UCHAR)'-')

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0002a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0002d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00030	75 15		 jne	 SHORT $LN4@toInt32_UT

; 1392 :     {
; 1393 : 		negate = ANTLR3_TRUE;

  00032	c6 44 24 2c 01	 mov	 BYTE PTR negate$[rsp], 1

; 1394 : 		input++;

  00037	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0003c	48 83 c0 02	 add	 rax, 2
  00040	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1395 :     }

  00045	eb 1b		 jmp	 SHORT $LN5@toInt32_UT
$LN4@toInt32_UT:

; 1396 :     else if (*input == (ANTLR3_UCHAR)'+')

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  0004c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0004f	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  00052	75 0e		 jne	 SHORT $LN6@toInt32_UT

; 1397 :     {
; 1398 : 		input++;

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00059	48 83 c0 02	 add	 rax, 2
  0005d	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax
$LN6@toInt32_UT:
$LN5@toInt32_UT:
$LN2@toInt32_UT:

; 1399 :     }
; 1400 : 
; 1401 :     while   (*input != '\0' && isdigit(*input))

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00067	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0006a	85 c0		 test	 eax, eax
  0006c	74 41		 je	 SHORT $LN3@toInt32_UT
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00073	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00076	8b c8		 mov	 ecx, eax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  0007e	85 c0		 test	 eax, eax
  00080	74 2d		 je	 SHORT $LN3@toInt32_UT

; 1402 :     {
; 1403 : 		value	 = value * 10;

  00082	6b 44 24 28 0a	 imul	 eax, DWORD PTR value$[rsp], 10
  00087	89 44 24 28	 mov	 DWORD PTR value$[rsp], eax

; 1404 : 		value	+= ((ANTLR3_UINT32)(*input) - (ANTLR3_UINT32)'0');

  0008b	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  00090	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00093	8b 4c 24 28	 mov	 ecx, DWORD PTR value$[rsp]
  00097	8d 44 01 d0	 lea	 eax, DWORD PTR [rcx+rax-48]
  0009b	89 44 24 28	 mov	 DWORD PTR value$[rsp], eax

; 1405 : 		input++;

  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR input$[rsp]
  000a4	48 83 c0 02	 add	 rax, 2
  000a8	48 89 44 24 20	 mov	 QWORD PTR input$[rsp], rax

; 1406 :     }

  000ad	eb b3		 jmp	 SHORT $LN2@toInt32_UT
$LN3@toInt32_UT:

; 1407 : 
; 1408 :     return negate ? -value : value;

  000af	0f b6 44 24 2c	 movzx	 eax, BYTE PTR negate$[rsp]
  000b4	85 c0		 test	 eax, eax
  000b6	74 0c		 je	 SHORT $LN8@toInt32_UT
  000b8	8b 44 24 28	 mov	 eax, DWORD PTR value$[rsp]
  000bc	f7 d8		 neg	 eax
  000be	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
  000c2	eb 08		 jmp	 SHORT $LN9@toInt32_UT
$LN8@toInt32_UT:
  000c4	8b 44 24 28	 mov	 eax, DWORD PTR value$[rsp]
  000c8	89 44 24 30	 mov	 DWORD PTR tv85[rsp], eax
$LN9@toInt32_UT:
  000cc	8b 44 24 30	 mov	 eax, DWORD PTR tv85[rsp]

; 1409 : }

  000d0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000d4	5f		 pop	 rdi
  000d5	c3		 ret	 0
toInt32_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT toInt32_8
_TEXT	SEGMENT
string$ = 48
toInt32_8 PROC						; COMDAT

; 1374 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1375 :     return  atoi((const char *)(string->chars));

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0000f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi

; 1376 : }

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5f		 pop	 rdi
  0001e	c3		 ret	 0
toInt32_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT subStringUTF16
_TEXT	SEGMENT
newStr$ = 32
tv80 = 40
string$ = 64
startIndex$ = 72
endIndex$ = 80
subStringUTF16 PROC					; COMDAT

; 1358 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1359 :     pANTLR3_STRING newStr;
; 1360 : 
; 1361 :     if	(endIndex > string->len)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00018	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0001b	39 44 24 50	 cmp	 DWORD PTR endIndex$[rsp], eax
  0001f	76 0e		 jbe	 SHORT $LN2@subStringU

; 1362 :     {
; 1363 : 		endIndex = string->len + 1;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00026	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 50	 mov	 DWORD PTR endIndex$[rsp], eax
$LN2@subStringU:

; 1364 :     }
; 1365 :     newStr  = string->factory->newPtr(string->factory, (pANTLR3_UINT8)((pANTLR3_UINT16)(string->chars) + startIndex), endIndex - startIndex);

  0002f	8b 44 24 48	 mov	 eax, DWORD PTR startIndex$[rsp]
  00033	8b 4c 24 50	 mov	 ecx, DWORD PTR endIndex$[rsp]
  00037	2b c8		 sub	 ecx, eax
  00039	8b c1		 mov	 eax, ecx
  0003b	8b 4c 24 48	 mov	 ecx, DWORD PTR startIndex$[rsp]
  0003f	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00044	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00048	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  0004c	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00051	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00054	48 89 54 24 28	 mov	 QWORD PTR tv80[rsp], rdx
  00059	44 8b c0	 mov	 r8d, eax
  0005c	48 8b d1	 mov	 rdx, rcx
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00064	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00067	48 8b 44 24 28	 mov	 rax, QWORD PTR tv80[rsp]
  0006c	ff 50 20	 call	 QWORD PTR [rax+32]
  0006f	48 89 44 24 20	 mov	 QWORD PTR newStr$[rsp], rax

; 1366 : 
; 1367 :     return newStr;

  00074	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]

; 1368 : }

  00079	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
subStringUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT subString8
_TEXT	SEGMENT
newStr$ = 32
tv79 = 40
string$ = 64
startIndex$ = 72
endIndex$ = 80
subString8 PROC						; COMDAT

; 1341 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1342 :     pANTLR3_STRING newStr;
; 1343 : 
; 1344 :     if	(endIndex > string->len)

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00018	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0001b	39 44 24 50	 cmp	 DWORD PTR endIndex$[rsp], eax
  0001f	76 0e		 jbe	 SHORT $LN2@subString8

; 1345 :     {
; 1346 : 		endIndex = string->len + 1;

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00026	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 50	 mov	 DWORD PTR endIndex$[rsp], eax
$LN2@subString8:

; 1347 :     }
; 1348 :     newStr  = string->factory->newPtr(string->factory, string->chars + startIndex, endIndex - startIndex);

  0002f	8b 44 24 48	 mov	 eax, DWORD PTR startIndex$[rsp]
  00033	8b 4c 24 50	 mov	 ecx, DWORD PTR endIndex$[rsp]
  00037	2b c8		 sub	 ecx, eax
  00039	8b c1		 mov	 eax, ecx
  0003b	8b 4c 24 48	 mov	 ecx, DWORD PTR startIndex$[rsp]
  0003f	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  00044	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  00048	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  0004d	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00050	48 89 54 24 28	 mov	 QWORD PTR tv79[rsp], rdx
  00055	44 8b c0	 mov	 r8d, eax
  00058	48 8b d1	 mov	 rdx, rcx
  0005b	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00060	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR tv79[rsp]
  00068	ff 50 20	 call	 QWORD PTR [rax+32]
  0006b	48 89 44 24 20	 mov	 QWORD PTR newStr$[rsp], rax

; 1349 : 
; 1350 :     return newStr;

  00070	48 8b 44 24 20	 mov	 rax, QWORD PTR newStr$[rsp]

; 1351 : }

  00075	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00079	5f		 pop	 rdi
  0007a	c3		 ret	 0
subString8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT charAtUTF16
_TEXT	SEGMENT
string$ = 16
offset$ = 24
charAtUTF16 PROC					; COMDAT

; 1325 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 1326 :     if	(offset > string->len)

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00012	39 44 24 18	 cmp	 DWORD PTR offset$[rsp], eax
  00016	76 06		 jbe	 SHORT $LN2@charAtUTF1

; 1327 :     {
; 1328 : 		return (ANTLR3_UCHAR)'\0';

  00018	33 c0		 xor	 eax, eax
  0001a	eb 13		 jmp	 SHORT $LN1@charAtUTF1

; 1329 :     }

  0001c	eb 11		 jmp	 SHORT $LN3@charAtUTF1
$LN2@charAtUTF1:

; 1330 :     else
; 1331 :     {
; 1332 : 		return  (ANTLR3_UCHAR)(*((pANTLR3_UINT16)(string->chars) + offset));

  0001e	8b 44 24 18	 mov	 eax, DWORD PTR offset$[rsp]
  00022	48 8b 4c 24 10	 mov	 rcx, QWORD PTR string$[rsp]
  00027	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002b	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
$LN3@charAtUTF1:
$LN1@charAtUTF1:

; 1333 :     }
; 1334 : }

  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
charAtUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT charAt8
_TEXT	SEGMENT
string$ = 16
offset$ = 24
charAt8	PROC						; COMDAT

; 1309 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi

; 1310 :     if	(offset > string->len)

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR string$[rsp]
  0000f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00012	39 44 24 18	 cmp	 DWORD PTR offset$[rsp], eax
  00016	76 06		 jbe	 SHORT $LN2@charAt8

; 1311 :     {
; 1312 : 		return (ANTLR3_UCHAR)'\0';

  00018	33 c0		 xor	 eax, eax
  0001a	eb 13		 jmp	 SHORT $LN1@charAt8

; 1313 :     }

  0001c	eb 11		 jmp	 SHORT $LN3@charAt8
$LN2@charAt8:

; 1314 :     else
; 1315 :     {
; 1316 : 		return  (ANTLR3_UCHAR)(*(string->chars + offset));

  0001e	8b 44 24 18	 mov	 eax, DWORD PTR offset$[rsp]
  00022	48 8b 4c 24 10	 mov	 rcx, QWORD PTR string$[rsp]
  00027	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0002b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
$LN3@charAt8:
$LN1@charAt8:

; 1317 :     }
; 1318 : }

  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
charAt8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT compareS
_TEXT	SEGMENT
string$ = 48
compStr$ = 56
compareS PROC						; COMDAT

; 1299 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1300 :     return  string->compare(string, (const char *)compStr->chars);

  0000f	48 8b 44 24 38	 mov	 rax, QWORD PTR compStr$[rsp]
  00014	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00022	ff 90 88 00 00
	00		 call	 QWORD PTR [rax+136]

; 1301 : }

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
compareS ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT compareUTF16_UTF16
_TEXT	SEGMENT
ourString$ = 0
compStr$ = 8
charDiff$ = 16
string$ = 48
compStr8$ = 56
compareUTF16_UTF16 PROC					; COMDAT

; 1269 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1270 :     pANTLR3_UINT16  ourString;
; 1271 :     pANTLR3_UINT16  compStr;
; 1272 :     ANTLR3_UINT32   charDiff;
; 1273 : 
; 1274 :     ourString	= (pANTLR3_UINT16)(string->chars);

  0000f	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00014	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00018	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax

; 1275 :     compStr	= (pANTLR3_UINT16)(compStr8);

  0001c	48 8b 44 24 38	 mov	 rax, QWORD PTR compStr8$[rsp]
  00021	48 89 44 24 08	 mov	 QWORD PTR compStr$[rsp], rax
$LN2@compareUTF:

; 1276 : 
; 1277 :     while   (((ANTLR3_UCHAR)(*ourString) != '\0') && ((ANTLR3_UCHAR)(*((pANTLR3_UINT16)compStr)) != '\0'))

  00026	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  0002a	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0002d	85 c0		 test	 eax, eax
  0002f	74 4a		 je	 SHORT $LN3@compareUTF
  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR compStr$[rsp]
  00036	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00039	85 c0		 test	 eax, eax
  0003b	74 3e		 je	 SHORT $LN3@compareUTF

; 1278 :     {
; 1279 : 		charDiff = *ourString - *compStr;

  0003d	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00041	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00044	48 8b 4c 24 08	 mov	 rcx, QWORD PTR compStr$[rsp]
  00049	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0004c	2b c1		 sub	 eax, ecx
  0004e	89 44 24 10	 mov	 DWORD PTR charDiff$[rsp], eax

; 1280 : 		if  (charDiff != 0)

  00052	83 7c 24 10 00	 cmp	 DWORD PTR charDiff$[rsp], 0
  00057	74 06		 je	 SHORT $LN4@compareUTF

; 1281 : 		{
; 1282 : 			return charDiff;

  00059	8b 44 24 10	 mov	 eax, DWORD PTR charDiff$[rsp]
  0005d	eb 2d		 jmp	 SHORT $LN1@compareUTF
$LN4@compareUTF:

; 1283 : 		}
; 1284 : 		ourString++;

  0005f	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00063	48 83 c0 02	 add	 rax, 2
  00067	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax

; 1285 : 		compStr++;

  0006b	48 8b 44 24 08	 mov	 rax, QWORD PTR compStr$[rsp]
  00070	48 83 c0 02	 add	 rax, 2
  00074	48 89 44 24 08	 mov	 QWORD PTR compStr$[rsp], rax

; 1286 :     }

  00079	eb ab		 jmp	 SHORT $LN2@compareUTF
$LN3@compareUTF:

; 1287 : 
; 1288 :     /* At this point, one of the strings was terminated
; 1289 :      */
; 1290 :     return (ANTLR3_UINT32)((ANTLR3_UCHAR)(*ourString) - (ANTLR3_UCHAR)(*compStr));

  0007b	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  0007f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00082	48 8b 4c 24 08	 mov	 rcx, QWORD PTR compStr$[rsp]
  00087	0f b7 09	 movzx	 ecx, WORD PTR [rcx]
  0008a	2b c1		 sub	 eax, ecx
$LN1@compareUTF:

; 1291 : }

  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
compareUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT compareUTF16_8
_TEXT	SEGMENT
ourString$ = 0
charDiff$ = 8
string$ = 32
compStr$ = 40
compareUTF16_8 PROC					; COMDAT

; 1240 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 1241 :     pANTLR3_UINT16  ourString;
; 1242 :     ANTLR3_UINT32   charDiff;
; 1243 : 
; 1244 :     ourString	= (pANTLR3_UINT16)(string->chars);

  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00014	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00018	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax
$LN2@compareUTF:

; 1245 : 
; 1246 :     while   (((ANTLR3_UCHAR)(*ourString) != '\0') && ((ANTLR3_UCHAR)(*compStr) != '\0'))

  0001c	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00020	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00023	85 c0		 test	 eax, eax
  00025	74 49		 je	 SHORT $LN3@compareUTF
  00027	48 8b 44 24 28	 mov	 rax, QWORD PTR compStr$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	85 c0		 test	 eax, eax
  00031	74 3d		 je	 SHORT $LN3@compareUTF

; 1247 :     {
; 1248 : 		charDiff = *ourString - *compStr;

  00033	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00037	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0003a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR compStr$[rsp]
  0003f	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  00042	2b c1		 sub	 eax, ecx
  00044	89 44 24 08	 mov	 DWORD PTR charDiff$[rsp], eax

; 1249 : 		if  (charDiff != 0)

  00048	83 7c 24 08 00	 cmp	 DWORD PTR charDiff$[rsp], 0
  0004d	74 06		 je	 SHORT $LN4@compareUTF

; 1250 : 		{
; 1251 : 			return charDiff;

  0004f	8b 44 24 08	 mov	 eax, DWORD PTR charDiff$[rsp]
  00053	eb 2c		 jmp	 SHORT $LN1@compareUTF
$LN4@compareUTF:

; 1252 : 		}
; 1253 : 		ourString++;

  00055	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00059	48 83 c0 02	 add	 rax, 2
  0005d	48 89 04 24	 mov	 QWORD PTR ourString$[rsp], rax

; 1254 : 		compStr++;

  00061	48 8b 44 24 28	 mov	 rax, QWORD PTR compStr$[rsp]
  00066	48 ff c0	 inc	 rax
  00069	48 89 44 24 28	 mov	 QWORD PTR compStr$[rsp], rax

; 1255 :     }

  0006e	eb ac		 jmp	 SHORT $LN2@compareUTF
$LN3@compareUTF:

; 1256 : 
; 1257 :     /* At this point, one of the strings was terminated
; 1258 :      */
; 1259 :     return (ANTLR3_UINT32)((ANTLR3_UCHAR)(*ourString) - (ANTLR3_UCHAR)(*compStr));

  00070	48 8b 04 24	 mov	 rax, QWORD PTR ourString$[rsp]
  00074	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR compStr$[rsp]
  0007c	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  0007f	2b c1		 sub	 eax, ecx
$LN1@compareUTF:

; 1260 : 
; 1261 : }

  00081	48 83 c4 10	 add	 rsp, 16
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
compareUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT compare8
_TEXT	SEGMENT
string$ = 48
compStr$ = 56
compare8 PROC						; COMDAT

; 1230 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1231 :     return  strcmp((const char *)(string->chars), compStr);

  0000f	48 8b 54 24 38	 mov	 rdx, QWORD PTR compStr$[rsp]
  00014	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00019	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0001d	e8 00 00 00 00	 call	 strcmp

; 1232 : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5f		 pop	 rdi
  00027	c3		 ret	 0
compare8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT insertiUTF16
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
point$ = 136
i$ = 144
insertiUTF16 PROC					; COMDAT

; 1057 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 14 00 00 00	 mov	 ecx, 20
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c4	 xor	 rax, rsp
  00036	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1058 :     ANTLR3_UINT8	    newbit[32];
; 1059 : 
; 1060 :     sprintf((char *)newbit, "%d", i);

  0003b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
  0004a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  0004f	e8 00 00 00 00	 call	 sprintf

; 1061 :     return  string->insert8(string, point, (const char *)newbit);

  00054	4c 8d 44 24 28	 lea	 r8, QWORD PTR newbit$[rsp]
  00059	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR point$[rsp]
  00060	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  00068	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00070	ff 50 48	 call	 QWORD PTR [rax+72]

; 1062 : }

  00073	48 8b f8	 mov	 rdi, rax
  00076	48 8b cc	 mov	 rcx, rsp
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:insertiUTF16$rtcFrameData
  00080	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00085	48 8b c7	 mov	 rax, rdi
  00088	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008d	48 33 cc	 xor	 rcx, rsp
  00090	e8 00 00 00 00	 call	 __security_check_cookie
  00095	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
insertiUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT inserti8
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
point$ = 136
i$ = 144
inserti8 PROC						; COMDAT

; 1049 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00013	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00018	b9 14 00 00 00	 mov	 ecx, 20
  0001d	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00022	f3 ab		 rep stosd
  00024	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00033	48 33 c4	 xor	 rax, rsp
  00036	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1050 :     ANTLR3_UINT8	    newbit[32];
; 1051 : 
; 1052 :     sprintf((char *)newbit, "%d", i);

  0003b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
  0004a	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  0004f	e8 00 00 00 00	 call	 sprintf

; 1053 :     return  string->insert8(string, point, (const char *)newbit);

  00054	4c 8d 44 24 28	 lea	 r8, QWORD PTR newbit$[rsp]
  00059	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR point$[rsp]
  00060	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  00068	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00070	ff 50 48	 call	 QWORD PTR [rax+72]

; 1054 : }

  00073	48 8b f8	 mov	 rdi, rax
  00076	48 8b cc	 mov	 rcx, rsp
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:inserti8$rtcFrameData
  00080	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00085	48 8b c7	 mov	 rax, rdi
  00088	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0008d	48 33 cc	 xor	 rcx, rsp
  00090	e8 00 00 00 00	 call	 __security_check_cookie
  00095	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
inserti8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT addiUTF16
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
i$ = 136
addiUTF16 PROC						; COMDAT

; 1039 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00013	b9 14 00 00 00	 mov	 ecx, 20
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002e	48 33 c4	 xor	 rax, rsp
  00031	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1040 :     ANTLR3_UINT8	    newbit[32];
; 1041 : 
; 1042 :     sprintf((char *)newbit, "%d", i);

  00036	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
  00045	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  0004a	e8 00 00 00 00	 call	 sprintf

; 1043 : 
; 1044 :     return  string->append8(string, (const char *)newbit);

  0004f	48 8d 54 24 28	 lea	 rdx, QWORD PTR newbit$[rsp]
  00054	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  0005c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00064	ff 50 38	 call	 QWORD PTR [rax+56]

; 1045 : }

  00067	48 8b f8	 mov	 rdi, rax
  0006a	48 8b cc	 mov	 rcx, rsp
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:addiUTF16$rtcFrameData
  00074	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00079	48 8b c7	 mov	 rax, rdi
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00081	48 33 cc	 xor	 rcx, rsp
  00084	e8 00 00 00 00	 call	 __security_check_cookie
  00089	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
addiUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT addi8
_TEXT	SEGMENT
newbit$ = 40
__$ArrayPad$ = 96
string$ = 128
i$ = 136
addi8	PROC						; COMDAT

; 1030 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000e	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  00013	b9 14 00 00 00	 mov	 ecx, 20
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR [rsp+128]
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002e	48 33 c4	 xor	 rax, rsp
  00031	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1031 :     ANTLR3_UINT8	    newbit[32];
; 1032 : 
; 1033 :     sprintf((char *)newbit, "%d", i);

  00036	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DPKJAMEF@?$CFd@
  00045	48 8d 4c 24 28	 lea	 rcx, QWORD PTR newbit$[rsp]
  0004a	e8 00 00 00 00	 call	 sprintf

; 1034 : 
; 1035 :     return  string->append8(string, (const char *)newbit);

  0004f	48 8d 54 24 28	 lea	 rdx, QWORD PTR newbit$[rsp]
  00054	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR string$[rsp]
  0005c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR string$[rsp]
  00064	ff 50 38	 call	 QWORD PTR [rax+56]

; 1036 : }

  00067	48 8b f8	 mov	 rdi, rax
  0006a	48 8b cc	 mov	 rcx, rsp
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:addi8$rtcFrameData
  00074	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00079	48 8b c7	 mov	 rax, rdi
  0007c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00081	48 33 cc	 xor	 rcx, rsp
  00084	e8 00 00 00 00	 call	 __security_check_cookie
  00089	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0008d	5f		 pop	 rdi
  0008e	c3		 ret	 0
addi8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT addcUTF16
_TEXT	SEGMENT
ptr$ = 32
newAlloc$1 = 40
string$ = 64
c$ = 72
addcUTF16 PROC						; COMDAT

; 1006 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1007 :     pANTLR3_UINT16  ptr;
; 1008 : 
; 1009 :     if	(string->size < string->len + 2)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00013	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00016	83 c0 02	 add	 eax, 2
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0001e	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00021	73 55		 jae	 SHORT $LN2@addcUTF16

; 1010 :     {
; 1011 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16) * (string->len + 2)));

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00028	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002b	83 c0 02	 add	 eax, 2
  0002e	8b c0		 mov	 eax, eax
  00030	48 d1 e0	 shl	 rax, 1
  00033	8b c0		 mov	 eax, eax
  00035	8b d0		 mov	 edx, eax
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0003c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00046	48 89 44 24 28	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 1012 : 		if (newAlloc == NULL)

  0004b	48 83 7c 24 28
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  00051	75 04		 jne	 SHORT $LN3@addcUTF16

; 1013 : 		{
; 1014 : 			return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	eb 74		 jmp	 SHORT $LN1@addcUTF16
$LN3@addcUTF16:

; 1015 : 		}
; 1016 : 		string->chars	= newAlloc;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  00061	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1017 : 		string->size	= string->len + 2;

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0006a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006d	83 c0 02	 add	 eax, 2
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00075	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@addcUTF16:

; 1018 :     }
; 1019 :     ptr	= (pANTLR3_UINT16)(string->chars);

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0007d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00081	48 89 44 24 20	 mov	 QWORD PTR ptr$[rsp], rax

; 1020 : 
; 1021 :     *(ptr + string->len)	= (ANTLR3_UINT16)c;

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0008b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0008e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ptr$[rsp]
  00093	0f b7 54 24 48	 movzx	 edx, WORD PTR c$[rsp]
  00098	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1022 :     *(ptr + string->len + 1)	= '\0';

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000a1	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a4	33 c9		 xor	 ecx, ecx
  000a6	48 8b 54 24 20	 mov	 rdx, QWORD PTR ptr$[rsp]
  000ab	66 89 4c 42 02	 mov	 WORD PTR [rdx+rax*2+2], cx

; 1023 :     string->len++;

  000b0	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000b5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000b8	ff c0		 inc	 eax
  000ba	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000bf	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1024 : 
; 1025 :     return  string->chars;

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000c7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@addcUTF16:

; 1026 : }

  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	5f		 pop	 rdi
  000d0	c3		 ret	 0
addcUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT addc8
_TEXT	SEGMENT
newAlloc$1 = 32
string$ = 64
c$ = 72
addc8	PROC						; COMDAT

; 986  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 987  :     if	(string->size < string->len + 2)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00013	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00016	83 c0 02	 add	 eax, 2
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0001e	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00021	73 50		 jae	 SHORT $LN2@addc8

; 988  :     {
; 989  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + 2));

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00028	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002b	83 c0 02	 add	 eax, 2
  0002e	8b c0		 mov	 eax, eax
  00030	8b d0		 mov	 edx, eax
  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00037	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00041	48 89 44 24 20	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 990  : 		if (newAlloc == NULL)

  00046	48 83 7c 24 20
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  0004c	75 04		 jne	 SHORT $LN3@addc8

; 991  : 		{
; 992  : 			return NULL;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 6b		 jmp	 SHORT $LN1@addc8
$LN3@addc8:

; 993  : 		}
; 994  : 		string->chars	= newAlloc;

  00052	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00057	48 8b 4c 24 20	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  0005c	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 995  : 		string->size	= string->len + 2;

  00060	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00065	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00068	83 c0 02	 add	 eax, 2
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00070	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@addc8:

; 996  :     }
; 997  :     *(string->chars + string->len)	= (ANTLR3_UINT8)c;

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00078	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00080	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00084	0f b6 54 24 48	 movzx	 edx, BYTE PTR c$[rsp]
  00089	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 998  :     *(string->chars + string->len + 1)	= '\0';

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00091	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00094	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00099	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0009d	c6 44 01 01 00	 mov	 BYTE PTR [rcx+rax+1], 0

; 999  :     string->len++;

  000a2	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000a7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000aa	ff c0		 inc	 eax
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000b1	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1000 : 
; 1001 :     return  string->chars;

  000b4	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000b9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@addc8:

; 1002 : }

  000bd	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
addc8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT insertS
_TEXT	SEGMENT
string$ = 48
point$ = 56
newbit$ = 64
insertS	PROC						; COMDAT

; 1221 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1222 :     return  string->insert(string, point, (const char *)(newbit->chars));

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR newbit$[rsp]
  00018	4c 8b 40 08	 mov	 r8, QWORD PTR [rax+8]
  0001c	8b 54 24 38	 mov	 edx, DWORD PTR point$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00025	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0002a	ff 50 40	 call	 QWORD PTR [rax+64]

; 1223 : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5f		 pop	 rdi
  00032	c3		 ret	 0
insertS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT appendS
_TEXT	SEGMENT
string$ = 48
newbit$ = 56
appendS	PROC						; COMDAT

; 1207 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1208 :     /* We may be passed an empty string, in which case we just return the current pointer
; 1209 :      */
; 1210 :     if	(newbit == NULL || newbit->len == 0 || newbit->size == 0 || newbit->chars == NULL)

  0000f	48 83 7c 24 38
	00		 cmp	 QWORD PTR newbit$[rsp], 0
  00015	74 22		 je	 SHORT $LN4@appendS
  00017	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  0001c	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00020	74 17		 je	 SHORT $LN4@appendS
  00022	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  00027	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0002b	74 0c		 je	 SHORT $LN4@appendS
  0002d	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  00032	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00037	75 0d		 jne	 SHORT $LN2@appendS
$LN4@appendS:

; 1211 :     {
; 1212 : 		return	string->chars;

  00039	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  0003e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00042	eb 18		 jmp	 SHORT $LN1@appendS

; 1213 :     }

  00044	eb 16		 jmp	 SHORT $LN3@appendS
$LN2@appendS:

; 1214 :     else
; 1215 :     {
; 1216 : 		return  string->append(string, (const char *)(newbit->chars));

  00046	48 8b 44 24 38	 mov	 rax, QWORD PTR newbit$[rsp]
  0004b	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0004f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00059	ff 50 30	 call	 QWORD PTR [rax+48]
$LN3@appendS:
$LN1@appendS:

; 1217 :     }
; 1218 : }

  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi
  00061	c3		 ret	 0
appendS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT setS
_TEXT	SEGMENT
string$ = 48
chars$ = 56
setS	PROC						; COMDAT

; 1202 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1203 :     return  string->set(string, (const char *)(chars->chars));

  0000f	48 8b 44 24 38	 mov	 rax, QWORD PTR chars$[rsp]
  00014	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00022	ff 50 20	 call	 QWORD PTR [rax+32]

; 1204 : }

  00025	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00029	5f		 pop	 rdi
  0002a	c3		 ret	 0
setS	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT insertUTF16_UTF16
_TEXT	SEGMENT
len$ = 32
in$ = 40
newAlloc$1 = 48
tv73 = 56
tv74 = 60
tv156 = 64
string$ = 96
point$ = 104
newbit$ = 112
insertUTF16_UTF16 PROC					; COMDAT

; 1152 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1153 :     ANTLR3_UINT32	len;
; 1154 :     pANTLR3_UINT16	in;
; 1155 : 
; 1156 :     if	(point >= string->len)

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  00018	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0001b	39 44 24 68	 cmp	 DWORD PTR point$[rsp], eax
  0001f	72 17		 jb	 SHORT $LN4@insertUTF1

; 1157 :     {
; 1158 : 		return	string->append(string, newbit);

  00021	48 8b 54 24 70	 mov	 rdx, QWORD PTR newbit$[rsp]
  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR string$[rsp]
  0002b	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  00030	ff 50 30	 call	 QWORD PTR [rax+48]
  00033	e9 87 01 00 00	 jmp	 $LN1@insertUTF1
$LN4@insertUTF1:

; 1159 :     }
; 1160 :  
; 1161 :     /** First, determine the length of the input string
; 1162 :      */
; 1163 :     in	    = (pANTLR3_UINT16)newbit;

  00038	48 8b 44 24 70	 mov	 rax, QWORD PTR newbit$[rsp]
  0003d	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 1164 :     len	    = 0;

  00042	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@insertUTF1:

; 1165 : 
; 1166 :     while   (*in++ != '\0')

  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0004f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00052	89 44 24 38	 mov	 DWORD PTR tv73[rsp], eax
  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  0005b	48 83 c0 02	 add	 rax, 2
  0005f	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
  00064	83 7c 24 38 00	 cmp	 DWORD PTR tv73[rsp], 0
  00069	74 0a		 je	 SHORT $LN9@insertUTF1
  0006b	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00073	eb 08		 jmp	 SHORT $LN10@insertUTF1
$LN9@insertUTF1:
  00075	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN10@insertUTF1:
  0007d	83 7c 24 3c 00	 cmp	 DWORD PTR tv74[rsp], 0
  00082	74 0c		 je	 SHORT $LN3@insertUTF1

; 1167 :     {
; 1168 : 		len++;

  00084	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1169 :     }

  0008e	eb ba		 jmp	 SHORT $LN2@insertUTF1
$LN3@insertUTF1:

; 1170 : 
; 1171 :     if	(len == 0)

  00090	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00095	75 0e		 jne	 SHORT $LN5@insertUTF1

; 1172 :     {
; 1173 : 		return	string->chars;

  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  0009c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a0	e9 1a 01 00 00	 jmp	 $LN1@insertUTF1
$LN5@insertUTF1:

; 1174 :     }
; 1175 : 
; 1176 :     if	(string->size < (string->len + len + 1))

  000a5	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  000aa	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000ad	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000b1	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR string$[rsp]
  000ba	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  000bd	73 62		 jae	 SHORT $LN6@insertUTF1

; 1177 :     {
; 1178 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));

  000bf	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  000c4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c7	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000cb	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000cf	8b c0		 mov	 eax, eax
  000d1	48 d1 e0	 shl	 rax, 1
  000d4	8b c0		 mov	 eax, eax
  000d6	8b d0		 mov	 edx, eax
  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  000dd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000e7	48 89 44 24 30	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 1179 : 		if (newAlloc == NULL)

  000ec	48 83 7c 24 30
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  000f2	75 07		 jne	 SHORT $LN7@insertUTF1

; 1180 : 		{
; 1181 : 			return NULL;

  000f4	33 c0		 xor	 eax, eax
  000f6	e9 c4 00 00 00	 jmp	 $LN1@insertUTF1
$LN7@insertUTF1:

; 1182 : 		}
; 1183 : 		string->chars	= newAlloc;

  000fb	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  00100	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  00105	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1184 : 		string->size	= string->len + len + 1;

  00109	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  0010e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00111	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00115	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00119	48 8b 4c 24 60	 mov	 rcx, QWORD PTR string$[rsp]
  0011e	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN6@insertUTF1:

; 1185 :     }
; 1186 : 
; 1187 :     /* Move the characters we are inserting before, including the delimiter
; 1188 :      */
; 1189 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point + len), (void *)(((pANTLR3_UINT16)string->chars) + point), (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len - point + 1)));

  00121	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  00126	8b 4c 24 68	 mov	 ecx, DWORD PTR point$[rsp]
  0012a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0012d	2b c1		 sub	 eax, ecx
  0012f	ff c0		 inc	 eax
  00131	8b c0		 mov	 eax, eax
  00133	48 d1 e0	 shl	 rax, 1
  00136	8b c0		 mov	 eax, eax
  00138	8b 4c 24 68	 mov	 ecx, DWORD PTR point$[rsp]
  0013c	48 8b 54 24 60	 mov	 rdx, QWORD PTR string$[rsp]
  00141	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00145	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00149	8b 54 24 68	 mov	 edx, DWORD PTR point$[rsp]
  0014d	4c 8b 44 24 60	 mov	 r8, QWORD PTR string$[rsp]
  00152	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  00156	49 8d 14 50	 lea	 rdx, QWORD PTR [r8+rdx*2]
  0015a	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  0015f	4a 8d 14 42	 lea	 rdx, QWORD PTR [rdx+r8*2]
  00163	48 89 54 24 40	 mov	 QWORD PTR tv156[rsp], rdx
  00168	44 8b c0	 mov	 r8d, eax
  0016b	48 8b d1	 mov	 rdx, rcx
  0016e	48 8b 44 24 40	 mov	 rax, QWORD PTR tv156[rsp]
  00173	48 8b c8	 mov	 rcx, rax
  00176	e8 00 00 00 00	 call	 memmove

; 1190 : 
; 1191 : 
; 1192 :     /* Note we copy the exact number of characters
; 1193 :      */
; 1194 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point), newbit, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len)));

  0017b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0017f	48 d1 e0	 shl	 rax, 1
  00182	8b c0		 mov	 eax, eax
  00184	8b 4c 24 68	 mov	 ecx, DWORD PTR point$[rsp]
  00188	48 8b 54 24 60	 mov	 rdx, QWORD PTR string$[rsp]
  0018d	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  00191	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00195	44 8b c0	 mov	 r8d, eax
  00198	48 8b 54 24 70	 mov	 rdx, QWORD PTR newbit$[rsp]
  0019d	e8 00 00 00 00	 call	 memmove

; 1195 :     
; 1196 :     string->len += len;

  001a2	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  001a7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  001aa	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  001ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR string$[rsp]
  001b3	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1197 : 
; 1198 :     return  string->chars;

  001b6	48 8b 44 24 60	 mov	 rax, QWORD PTR string$[rsp]
  001bb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@insertUTF1:

; 1199 : }

  001bf	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001c3	5f		 pop	 rdi
  001c4	c3		 ret	 0
insertUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT insertUTF16_8
_TEXT	SEGMENT
len$ = 32
count$ = 36
inPoint$ = 40
newAlloc$1 = 48
tv152 = 56
string$ = 80
point$ = 88
newbit$ = 96
insertUTF16_8 PROC					; COMDAT

; 1107 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1108 :     ANTLR3_UINT32	len;
; 1109 :     ANTLR3_UINT32	count;
; 1110 :     pANTLR3_UINT16	inPoint;
; 1111 : 
; 1112 :     if	(point >= string->len)

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0001b	39 44 24 58	 cmp	 DWORD PTR point$[rsp], eax
  0001f	72 17		 jb	 SHORT $LN5@insertUTF1

; 1113 :     {
; 1114 : 		return	string->append8(string, newbit);

  00021	48 8b 54 24 60	 mov	 rdx, QWORD PTR newbit$[rsp]
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00030	ff 50 38	 call	 QWORD PTR [rax+56]
  00033	e9 67 01 00 00	 jmp	 $LN1@insertUTF1
$LN5@insertUTF1:

; 1115 :     }
; 1116 :  
; 1117 :     len	= (ANTLR3_UINT32)strlen(newbit);

  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newbit$[rsp]
  0003d	e8 00 00 00 00	 call	 strlen
  00042	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1118 : 
; 1119 :     if	(len == 0)

  00046	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0004b	75 0e		 jne	 SHORT $LN6@insertUTF1

; 1120 :     {
; 1121 : 		return	string->chars;

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00052	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00056	e9 44 01 00 00	 jmp	 $LN1@insertUTF1
$LN6@insertUTF1:

; 1122 :     }
; 1123 : 
; 1124 :     if	(string->size < (string->len + len + 1))

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00060	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00063	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00067	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00070	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00073	73 62		 jae	 SHORT $LN7@insertUTF1

; 1125 :     {
; 1126 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0007a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007d	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00081	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00085	8b c0		 mov	 eax, eax
  00087	48 d1 e0	 shl	 rax, 1
  0008a	8b c0		 mov	 eax, eax
  0008c	8b d0		 mov	 edx, eax
  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00093	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0009d	48 89 44 24 30	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 1127 : 		if (newAlloc == NULL)

  000a2	48 83 7c 24 30
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  000a8	75 07		 jne	 SHORT $LN8@insertUTF1

; 1128 : 		{
; 1129 : 			return NULL;

  000aa	33 c0		 xor	 eax, eax
  000ac	e9 ee 00 00 00	 jmp	 $LN1@insertUTF1
$LN8@insertUTF1:

; 1130 : 		}
; 1131 : 		string->chars	= newAlloc;

  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  000bb	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1132 : 		string->size	= string->len + len + 1;

  000bf	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000c4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c7	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000cb	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000d4	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN7@insertUTF1:

; 1133 :     }
; 1134 : 
; 1135 :     /* Move the characters we are inserting before, including the delimiter
; 1136 :      */
; 1137 :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + point + len), (void *)(((pANTLR3_UINT16)string->chars) + point), (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len - point + 1)));

  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000dc	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  000e0	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000e3	2b c1		 sub	 eax, ecx
  000e5	ff c0		 inc	 eax
  000e7	8b c0		 mov	 eax, eax
  000e9	48 d1 e0	 shl	 rax, 1
  000ec	8b c0		 mov	 eax, eax
  000ee	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  000f2	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  000f7	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000fb	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  000ff	8b 54 24 58	 mov	 edx, DWORD PTR point$[rsp]
  00103	4c 8b 44 24 50	 mov	 r8, QWORD PTR string$[rsp]
  00108	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  0010c	49 8d 14 50	 lea	 rdx, QWORD PTR [r8+rdx*2]
  00110	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00115	4a 8d 14 42	 lea	 rdx, QWORD PTR [rdx+r8*2]
  00119	48 89 54 24 38	 mov	 QWORD PTR tv152[rsp], rdx
  0011e	44 8b c0	 mov	 r8d, eax
  00121	48 8b d1	 mov	 rdx, rcx
  00124	48 8b 44 24 38	 mov	 rax, QWORD PTR tv152[rsp]
  00129	48 8b c8	 mov	 rcx, rax
  0012c	e8 00 00 00 00	 call	 memmove

; 1138 : 
; 1139 :     string->len += len;

  00131	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00136	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00139	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  0013d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00142	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1140 :     
; 1141 :     inPoint = ((pANTLR3_UINT16)(string->chars))+point;

  00145	8b 44 24 58	 mov	 eax, DWORD PTR point$[rsp]
  00149	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0014e	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00152	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  00156	48 89 44 24 28	 mov	 QWORD PTR inPoint$[rsp], rax

; 1142 :     for	(count = 0; count<len; count++)

  0015b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  00163	eb 0a		 jmp	 SHORT $LN4@insertUTF1
$LN2@insertUTF1:
  00165	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  00169	ff c0		 inc	 eax
  0016b	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
$LN4@insertUTF1:
  0016f	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00173	39 44 24 24	 cmp	 DWORD PTR count$[rsp], eax
  00177	73 1d		 jae	 SHORT $LN3@insertUTF1

; 1143 :     {
; 1144 : 		*(inPoint + count) = (ANTLR3_UINT16)(*(newbit+count));

  00179	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  0017d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newbit$[rsp]
  00182	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  00187	8b 4c 24 24	 mov	 ecx, DWORD PTR count$[rsp]
  0018b	48 8b 54 24 28	 mov	 rdx, QWORD PTR inPoint$[rsp]
  00190	66 89 04 4a	 mov	 WORD PTR [rdx+rcx*2], ax

; 1145 :     }

  00194	eb cf		 jmp	 SHORT $LN2@insertUTF1
$LN3@insertUTF1:

; 1146 : 
; 1147 :     return  string->chars;

  00196	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0019b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@insertUTF1:

; 1148 : }

  0019f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001a3	5f		 pop	 rdi
  001a4	c3		 ret	 0
insertUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT insert8
_TEXT	SEGMENT
len$ = 32
newAlloc$1 = 40
tv143 = 48
string$ = 80
point$ = 88
newbit$ = 96
insert8	PROC						; COMDAT

; 1066 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1067 :     ANTLR3_UINT32	len;
; 1068 : 
; 1069 :     if	(point >= string->len)

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00018	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0001b	39 44 24 58	 cmp	 DWORD PTR point$[rsp], eax
  0001f	72 17		 jb	 SHORT $LN2@insert8

; 1070 :     {
; 1071 : 		return	string->append(string, newbit);

  00021	48 8b 54 24 60	 mov	 rdx, QWORD PTR newbit$[rsp]
  00026	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00030	ff 50 30	 call	 QWORD PTR [rax+48]
  00033	e9 27 01 00 00	 jmp	 $LN1@insert8
$LN2@insert8:

; 1072 :     }
; 1073 :  
; 1074 :     len	= (ANTLR3_UINT32)strlen(newbit);

  00038	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newbit$[rsp]
  0003d	e8 00 00 00 00	 call	 strlen
  00042	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 1075 : 
; 1076 :     if	(len == 0)

  00046	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0004b	75 0e		 jne	 SHORT $LN3@insert8

; 1077 :     {
; 1078 : 		return	string->chars;

  0004d	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00052	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00056	e9 04 01 00 00	 jmp	 $LN1@insert8
$LN3@insert8:

; 1079 :     }
; 1080 : 
; 1081 :     if	(string->size < (string->len + len + 1))

  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00060	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00063	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00067	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0006b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00070	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00073	73 5d		 jae	 SHORT $LN4@insert8

; 1082 :     {
; 1083 : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));

  00075	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0007a	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0007d	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00081	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00085	8b c0		 mov	 eax, eax
  00087	8b d0		 mov	 edx, eax
  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0008e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00098	48 89 44 24 28	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 1084 : 		if (newAlloc == NULL)

  0009d	48 83 7c 24 28
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  000a3	75 07		 jne	 SHORT $LN5@insert8

; 1085 : 		{
; 1086 : 			return NULL;

  000a5	33 c0		 xor	 eax, eax
  000a7	e9 b3 00 00 00	 jmp	 $LN1@insert8
$LN5@insert8:

; 1087 : 		}
; 1088 : 		string->chars	= newAlloc;

  000ac	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  000b6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1089 : 		string->size	= string->len + len + 1;

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000bf	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000c2	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000c6	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000cf	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN4@insert8:

; 1090 :     }
; 1091 : 
; 1092 :     /* Move the characters we are inserting before, including the delimiter
; 1093 :      */
; 1094 :     ANTLR3_MEMMOVE((void *)(string->chars + point + len), (void *)(string->chars + point), (ANTLR3_UINT32)(string->len - point + 1));

  000d2	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000d7	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  000db	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000de	2b c1		 sub	 eax, ecx
  000e0	ff c0		 inc	 eax
  000e2	8b c0		 mov	 eax, eax
  000e4	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  000e8	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  000ed	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  000f1	8b 54 24 58	 mov	 edx, DWORD PTR point$[rsp]
  000f5	4c 8b 44 24 50	 mov	 r8, QWORD PTR string$[rsp]
  000fa	4d 8b 40 08	 mov	 r8, QWORD PTR [r8+8]
  000fe	4c 03 c2	 add	 r8, rdx
  00101	49 8b d0	 mov	 rdx, r8
  00104	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00109	49 03 d0	 add	 rdx, r8
  0010c	48 89 54 24 30	 mov	 QWORD PTR tv143[rsp], rdx
  00111	44 8b c0	 mov	 r8d, eax
  00114	48 8b d1	 mov	 rdx, rcx
  00117	48 8b 44 24 30	 mov	 rax, QWORD PTR tv143[rsp]
  0011c	48 8b c8	 mov	 rcx, rax
  0011f	e8 00 00 00 00	 call	 memmove

; 1095 : 
; 1096 :     /* Note we copy the exact number of bytes
; 1097 :      */
; 1098 :     ANTLR3_MEMMOVE((void *)(string->chars + point), newbit, (ANTLR3_UINT32)(len));

  00124	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00128	8b 4c 24 58	 mov	 ecx, DWORD PTR point$[rsp]
  0012c	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  00131	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  00135	44 8b c0	 mov	 r8d, eax
  00138	48 8b 54 24 60	 mov	 rdx, QWORD PTR newbit$[rsp]
  0013d	e8 00 00 00 00	 call	 memmove

; 1099 :     
; 1100 :     string->len += len;

  00142	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00147	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0014a	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  0014e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00153	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 1101 : 
; 1102 :     return  string->chars;

  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0015b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@insert8:

; 1103 : }

  0015f	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00163	5f		 pop	 rdi
  00164	c3		 ret	 0
insert8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT appendUTF16_UTF16
_TEXT	SEGMENT
len$ = 32
in$ = 40
newAlloc$1 = 48
tv67 = 56
tv68 = 60
string$ = 80
newbit$ = 88
appendUTF16_UTF16 PROC					; COMDAT

; 859  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 860  :     ANTLR3_UINT32 len;
; 861  :     pANTLR3_UINT16  in;
; 862  : 
; 863  :     /** First, determine the length of the input string
; 864  :      */
; 865  :     in	    = (pANTLR3_UINT16)newbit;

  0000f	48 8b 44 24 58	 mov	 rax, QWORD PTR newbit$[rsp]
  00014	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 866  :     len   = 0;

  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@appendUTF1:

; 867  : 
; 868  :     while   (*in++ != '\0')

  00021	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00026	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00029	89 44 24 38	 mov	 DWORD PTR tv67[rsp], eax
  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00032	48 83 c0 02	 add	 rax, 2
  00036	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
  0003b	83 7c 24 38 00	 cmp	 DWORD PTR tv67[rsp], 0
  00040	74 0a		 je	 SHORT $LN7@appendUTF1
  00042	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0004a	eb 08		 jmp	 SHORT $LN8@appendUTF1
$LN7@appendUTF1:
  0004c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN8@appendUTF1:
  00054	83 7c 24 3c 00	 cmp	 DWORD PTR tv68[rsp], 0
  00059	74 0c		 je	 SHORT $LN3@appendUTF1

; 869  :     {
; 870  : 		len++;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 871  :     }

  00065	eb ba		 jmp	 SHORT $LN2@appendUTF1
$LN3@appendUTF1:

; 872  : 
; 873  :     if	(string->size < (string->len + len + 1))

  00067	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0006c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006f	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00073	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  0007c	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  0007f	73 5f		 jae	 SHORT $LN4@appendUTF1

; 874  :     {
; 875  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)( sizeof(ANTLR3_UINT16) *(string->len + len + 1) ));

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00086	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00089	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0008d	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00091	8b c0		 mov	 eax, eax
  00093	48 d1 e0	 shl	 rax, 1
  00096	8b c0		 mov	 eax, eax
  00098	8b d0		 mov	 edx, eax
  0009a	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0009f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000a9	48 89 44 24 30	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 876  : 		if (newAlloc == NULL)

  000ae	48 83 7c 24 30
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  000b4	75 04		 jne	 SHORT $LN5@appendUTF1

; 877  : 		{
; 878  : 			return NULL;

  000b6	33 c0		 xor	 eax, eax
  000b8	eb 72		 jmp	 SHORT $LN1@appendUTF1
$LN5@appendUTF1:

; 879  : 		}
; 880  : 		string->chars	= newAlloc;

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000bf	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  000c4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 881  : 		string->size	= string->len + len + 1;

  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000cd	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000d0	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000d4	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  000d8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000dd	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN4@appendUTF1:

; 882  :     }
; 883  : 
; 884  :     /* Note we copy one more byte than the strlen in order to get the trailing delimiter
; 885  :      */
; 886  :     ANTLR3_MEMMOVE((void *)(((pANTLR3_UINT16)string->chars) + string->len), newbit, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len+1)));

  000e0	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	8b c0		 mov	 eax, eax
  000e8	48 d1 e0	 shl	 rax, 1
  000eb	8b c0		 mov	 eax, eax
  000ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000f2	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000f5	48 8b 54 24 50	 mov	 rdx, QWORD PTR string$[rsp]
  000fa	48 8b 52 08	 mov	 rdx, QWORD PTR [rdx+8]
  000fe	48 8d 0c 4a	 lea	 rcx, QWORD PTR [rdx+rcx*2]
  00102	44 8b c0	 mov	 r8d, eax
  00105	48 8b 54 24 58	 mov	 rdx, QWORD PTR newbit$[rsp]
  0010a	e8 00 00 00 00	 call	 memmove

; 887  :     string->len	+= len;

  0010f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00114	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00117	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00120	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 888  : 
; 889  :     return string->chars;

  00123	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00128	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@appendUTF1:

; 890  : }

  0012c	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00130	5f		 pop	 rdi
  00131	c3		 ret	 0
appendUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT appendUTF16_8
_TEXT	SEGMENT
len$ = 32
apPoint$ = 40
count$ = 48
newAlloc$1 = 56
string$ = 80
newbit$ = 88
appendUTF16_8 PROC					; COMDAT

; 827  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 828  :     ANTLR3_UINT32   len;
; 829  :     pANTLR3_UINT16  apPoint;
; 830  :     ANTLR3_UINT32   count;
; 831  : 
; 832  :     len	= (ANTLR3_UINT32)strlen(newbit);

  0000f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR newbit$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 833  : 
; 834  :     if	(string->size < (string->len + len + 1))

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00022	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00025	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00029	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00032	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00035	73 62		 jae	 SHORT $LN5@appendUTF1

; 835  :     {
; 836  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)((sizeof(ANTLR3_UINT16)*(string->len + len + 1))));

  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0003c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003f	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00043	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00047	8b c0		 mov	 eax, eax
  00049	48 d1 e0	 shl	 rax, 1
  0004c	8b c0		 mov	 eax, eax
  0004e	8b d0		 mov	 edx, eax
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00055	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005f	48 89 44 24 38	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 837  : 		if (newAlloc == NULL)

  00064	48 83 7c 24 38
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  0006a	75 07		 jne	 SHORT $LN6@appendUTF1

; 838  : 		{
; 839  : 			return NULL;

  0006c	33 c0		 xor	 eax, eax
  0006e	e9 ab 00 00 00	 jmp	 $LN1@appendUTF1
$LN6@appendUTF1:

; 840  : 		}
; 841  : 		string->chars	= newAlloc;

  00073	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00078	48 8b 4c 24 38	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  0007d	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 842  : 		string->size	= string->len + len + 1;

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00086	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00089	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0008d	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00096	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN5@appendUTF1:

; 843  :     }
; 844  : 
; 845  :     apPoint = ((pANTLR3_UINT16)string->chars) + string->len;

  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0009e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000a1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000a6	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000aa	48 8d 04 41	 lea	 rax, QWORD PTR [rcx+rax*2]
  000ae	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 846  :     string->len	+= len;

  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000b8	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000bb	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000c4	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 847  : 
; 848  :     for	(count = 0; count < len; count++)

  000c7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  000cf	eb 0a		 jmp	 SHORT $LN4@appendUTF1
$LN2@appendUTF1:
  000d1	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000d5	ff c0		 inc	 eax
  000d7	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax
$LN4@appendUTF1:
  000db	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000df	39 44 24 30	 cmp	 DWORD PTR count$[rsp], eax
  000e3	73 26		 jae	 SHORT $LN3@appendUTF1

; 849  :     {
; 850  : 		*apPoint++   = *(newbit + count);

  000e5	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR newbit$[rsp]
  000ee	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  000f3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  000f8	66 89 01	 mov	 WORD PTR [rcx], ax
  000fb	48 8b 44 24 28	 mov	 rax, QWORD PTR apPoint$[rsp]
  00100	48 83 c0 02	 add	 rax, 2
  00104	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 851  :     }

  00109	eb c6		 jmp	 SHORT $LN2@appendUTF1
$LN3@appendUTF1:

; 852  :     *apPoint = '\0';

  0010b	33 c0		 xor	 eax, eax
  0010d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  00112	66 89 01	 mov	 WORD PTR [rcx], ax

; 853  : 
; 854  :     return string->chars;

  00115	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0011a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@appendUTF1:

; 855  : }

  0011e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00122	5f		 pop	 rdi
  00123	c3		 ret	 0
appendUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT append8
_TEXT	SEGMENT
len$ = 32
newAlloc$1 = 40
string$ = 64
newbit$ = 72
append8	PROC						; COMDAT

; 801  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 802  :     ANTLR3_UINT32 len;
; 803  : 
; 804  :     len	= (ANTLR3_UINT32)strlen(newbit);

  0000f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR newbit$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 805  : 
; 806  :     if	(string->size < (string->len + len + 1))

  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00022	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00025	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00029	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  0002d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00032	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00035	73 5a		 jae	 SHORT $LN2@append8

; 807  :     {
; 808  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0003c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0003f	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00043	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00047	8b c0		 mov	 eax, eax
  00049	8b d0		 mov	 edx, eax
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00050	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0005a	48 89 44 24 28	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 809  : 		if (newAlloc == NULL)

  0005f	48 83 7c 24 28
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  00065	75 04		 jne	 SHORT $LN3@append8

; 810  : 		{
; 811  : 			return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	eb 69		 jmp	 SHORT $LN1@append8
$LN3@append8:

; 812  : 		}
; 813  : 		string->chars	= newAlloc;

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  00075	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 814  : 		string->size	= string->len + len + 1;

  00079	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0007e	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00085	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00089	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0008e	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@append8:

; 815  :     }
; 816  : 
; 817  :     /* Note we copy one more byte than the strlen in order to get the trailing
; 818  :      */
; 819  :     ANTLR3_MEMMOVE((void *)(string->chars + string->len), newbit, (ANTLR3_UINT32)(len+1));

  00091	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00095	ff c0		 inc	 eax
  00097	8b c0		 mov	 eax, eax
  00099	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  0009e	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000a1	48 8b 54 24 40	 mov	 rdx, QWORD PTR string$[rsp]
  000a6	48 03 4a 08	 add	 rcx, QWORD PTR [rdx+8]
  000aa	44 8b c0	 mov	 r8d, eax
  000ad	48 8b 54 24 48	 mov	 rdx, QWORD PTR newbit$[rsp]
  000b2	e8 00 00 00 00	 call	 memmove

; 820  :     string->len	+= len;

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000bc	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000bf	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000c3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  000c8	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 821  : 
; 822  :     return string->chars;

  000cb	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000d0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@append8:

; 823  : }

  000d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d8	5f		 pop	 rdi
  000d9	c3		 ret	 0
append8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT setUTF16_UTF16
_TEXT	SEGMENT
len$ = 32
in$ = 40
newAlloc$1 = 48
tv67 = 56
tv68 = 60
string$ = 80
chars$ = 88
setUTF16_UTF16 PROC					; COMDAT

; 950  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 951  :     ANTLR3_UINT32   len;
; 952  :     pANTLR3_UINT16  in;
; 953  : 
; 954  :     /** First, determine the length of the input string
; 955  :      */
; 956  :     in	    = (pANTLR3_UINT16)chars;

  0000f	48 8b 44 24 58	 mov	 rax, QWORD PTR chars$[rsp]
  00014	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax

; 957  :     len   = 0;

  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN2@setUTF16_U:

; 958  : 
; 959  :     while   (*in++ != '\0')

  00021	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00026	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00029	89 44 24 38	 mov	 DWORD PTR tv67[rsp], eax
  0002d	48 8b 44 24 28	 mov	 rax, QWORD PTR in$[rsp]
  00032	48 83 c0 02	 add	 rax, 2
  00036	48 89 44 24 28	 mov	 QWORD PTR in$[rsp], rax
  0003b	83 7c 24 38 00	 cmp	 DWORD PTR tv67[rsp], 0
  00040	74 0a		 je	 SHORT $LN7@setUTF16_U
  00042	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0004a	eb 08		 jmp	 SHORT $LN8@setUTF16_U
$LN7@setUTF16_U:
  0004c	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN8@setUTF16_U:
  00054	83 7c 24 3c 00	 cmp	 DWORD PTR tv68[rsp], 0
  00059	74 0c		 je	 SHORT $LN3@setUTF16_U

; 960  :     {
; 961  : 		len++;

  0005b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 962  :     }

  00065	eb ba		 jmp	 SHORT $LN2@setUTF16_U
$LN3@setUTF16_U:

; 963  : 
; 964  :     if	(string->size < len + 1)

  00067	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0006b	ff c0		 inc	 eax
  0006d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00072	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  00075	73 4b		 jae	 SHORT $LN4@setUTF16_U

; 965  :     {
; 966  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));

  00077	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0007b	ff c0		 inc	 eax
  0007d	8b c0		 mov	 eax, eax
  0007f	48 d1 e0	 shl	 rax, 1
  00082	8b c0		 mov	 eax, eax
  00084	8b d0		 mov	 edx, eax
  00086	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0008b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00095	48 89 44 24 30	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 967  : 		if (newAlloc == NULL)

  0009a	48 83 7c 24 30
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  000a0	75 04		 jne	 SHORT $LN5@setUTF16_U

; 968  : 		{
; 969  : 			return NULL;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 54		 jmp	 SHORT $LN1@setUTF16_U
$LN5@setUTF16_U:

; 970  : 		}
; 971  : 		string->chars	= newAlloc;

  000a6	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000ab	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  000b0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 972  : 		string->size	= len + 1;

  000b4	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000b8	ff c0		 inc	 eax
  000ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  000bf	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN4@setUTF16_U:

; 973  :     }
; 974  : 
; 975  :     /* Note we copy one more byte than the strlen in order to get the trailing '\0'
; 976  :      */
; 977  :     ANTLR3_MEMMOVE((void *)(string->chars), chars, (ANTLR3_UINT32)((len+1) * sizeof(ANTLR3_UINT16)));

  000c2	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	8b c0		 mov	 eax, eax
  000ca	48 d1 e0	 shl	 rax, 1
  000cd	8b c0		 mov	 eax, eax
  000cf	44 8b c0	 mov	 r8d, eax
  000d2	48 8b 54 24 58	 mov	 rdx, QWORD PTR chars$[rsp]
  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000dc	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  000e0	e8 00 00 00 00	 call	 memmove

; 978  :     string->len	    = len;

  000e5	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000ea	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000ee	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 979  : 
; 980  :     return  string->chars;

  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000f6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@setUTF16_U:

; 981  : 
; 982  : }

  000fa	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
setUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT setUTF16_8
_TEXT	SEGMENT
len$ = 32
count$ = 36
apPoint$ = 40
newAlloc$1 = 48
string$ = 80
chars$ = 88
setUTF16_8 PROC						; COMDAT

; 920  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 921  :     ANTLR3_UINT32	len;
; 922  :     ANTLR3_UINT32	count;
; 923  :     pANTLR3_UINT16	apPoint;
; 924  : 
; 925  :     len = (ANTLR3_UINT32)strlen(chars);

  0000f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chars$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 926  :     if	(string->size < len + 1)

  0001d	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00021	ff c0		 inc	 eax
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00028	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  0002b	73 4e		 jae	 SHORT $LN5@setUTF16_8

; 927  : 	{
; 928  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));

  0002d	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00031	ff c0		 inc	 eax
  00033	8b c0		 mov	 eax, eax
  00035	48 d1 e0	 shl	 rax, 1
  00038	8b c0		 mov	 eax, eax
  0003a	8b d0		 mov	 edx, eax
  0003c	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00041	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0004b	48 89 44 24 30	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 929  : 		if (newAlloc == NULL)

  00050	48 83 7c 24 30
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  00056	75 07		 jne	 SHORT $LN6@setUTF16_8

; 930  : 		{
; 931  : 			return NULL;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 91 00 00 00	 jmp	 $LN1@setUTF16_8
$LN6@setUTF16_8:

; 932  : 		}
; 933  : 		string->chars	= newAlloc;

  0005f	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00064	48 8b 4c 24 30	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  00069	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 934  : 		string->size	= len + 1;

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00071	ff c0		 inc	 eax
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR string$[rsp]
  00078	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN5@setUTF16_8:

; 935  :     }
; 936  :     apPoint = ((pANTLR3_UINT16)string->chars);

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  00080	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00084	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 937  :     string->len	= len;

  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  0008e	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00092	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 938  : 
; 939  :     for	(count = 0; count < string->len; count++)

  00095	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
  0009d	eb 0a		 jmp	 SHORT $LN4@setUTF16_8
$LN2@setUTF16_8:
  0009f	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  000a3	ff c0		 inc	 eax
  000a5	89 44 24 24	 mov	 DWORD PTR count$[rsp], eax
$LN4@setUTF16_8:
  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000ae	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  000b1	39 44 24 24	 cmp	 DWORD PTR count$[rsp], eax
  000b5	73 26		 jae	 SHORT $LN3@setUTF16_8

; 940  :     {
; 941  : 		*apPoint++   = *(chars + count);

  000b7	8b 44 24 24	 mov	 eax, DWORD PTR count$[rsp]
  000bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR chars$[rsp]
  000c0	66 0f be 04 01	 movsx	 ax, BYTE PTR [rcx+rax]
  000c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  000ca	66 89 01	 mov	 WORD PTR [rcx], ax
  000cd	48 8b 44 24 28	 mov	 rax, QWORD PTR apPoint$[rsp]
  000d2	48 83 c0 02	 add	 rax, 2
  000d6	48 89 44 24 28	 mov	 QWORD PTR apPoint$[rsp], rax

; 942  :     }

  000db	eb c2		 jmp	 SHORT $LN2@setUTF16_8
$LN3@setUTF16_8:

; 943  :     *apPoint = '\0';

  000dd	33 c0		 xor	 eax, eax
  000df	48 8b 4c 24 28	 mov	 rcx, QWORD PTR apPoint$[rsp]
  000e4	66 89 01	 mov	 WORD PTR [rcx], ax

; 944  : 
; 945  :     return  string->chars;

  000e7	48 8b 44 24 50	 mov	 rax, QWORD PTR string$[rsp]
  000ec	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@setUTF16_8:

; 946  : }

  000f0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f4	5f		 pop	 rdi
  000f5	c3		 ret	 0
setUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT set8
_TEXT	SEGMENT
len$ = 32
newAlloc$1 = 40
string$ = 64
chars$ = 72
set8	PROC						; COMDAT

; 894  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 895  :     ANTLR3_UINT32	len;
; 896  : 
; 897  :     len = (ANTLR3_UINT32)strlen(chars);

  0000f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR chars$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 898  :     if	(string->size < len + 1)

  0001d	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00021	ff c0		 inc	 eax
  00023	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00028	39 41 14	 cmp	 DWORD PTR [rcx+20], eax
  0002b	73 46		 jae	 SHORT $LN2@set8

; 899  :     {
; 900  : 		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(len + 1));

  0002d	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00031	ff c0		 inc	 eax
  00033	8b c0		 mov	 eax, eax
  00035	8b d0		 mov	 edx, eax
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0003c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00046	48 89 44 24 28	 mov	 QWORD PTR newAlloc$1[rsp], rax

; 901  : 		if (newAlloc == NULL)

  0004b	48 83 7c 24 28
	00		 cmp	 QWORD PTR newAlloc$1[rsp], 0
  00051	75 04		 jne	 SHORT $LN3@set8

; 902  : 		{
; 903  : 			return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	eb 4f		 jmp	 SHORT $LN1@set8
$LN3@set8:

; 904  : 		}
; 905  : 		string->chars	= newAlloc;

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR newAlloc$1[rsp]
  00061	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 906  : 		string->size	= len + 1;

  00065	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00069	ff c0		 inc	 eax
  0006b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR string$[rsp]
  00070	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN2@set8:

; 907  :     }
; 908  : 
; 909  :     /* Note we copy one more byte than the strlen in order to get the trailing '\0'
; 910  :      */
; 911  :     ANTLR3_MEMMOVE((void *)(string->chars), chars, (ANTLR3_UINT32)(len+1));

  00073	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00077	ff c0		 inc	 eax
  00079	8b c0		 mov	 eax, eax
  0007b	44 8b c0	 mov	 r8d, eax
  0007e	48 8b 54 24 48	 mov	 rdx, QWORD PTR chars$[rsp]
  00083	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00088	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0008c	e8 00 00 00 00	 call	 memmove

; 912  :     string->len	    = len;

  00091	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  00096	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0009a	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 913  : 
; 914  :     return  string->chars;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR string$[rsp]
  000a2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
$LN1@set8:

; 915  : 
; 916  : }

  000a6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000aa	5f		 pop	 rdi
  000ab	c3		 ret	 0
set8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT closeFactory
_TEXT	SEGMENT
factory$ = 48
closeFactory PROC					; COMDAT

; 788  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 789  :     /* Delete the vector we were tracking the strings with, this will
; 790  :      * causes all the allocated strings to be deallocated too
; 791  :      */
; 792  :     factory->strings->free(factory->strings);

  0000a	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0000f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	ff 90 18 01 00
	00		 call	 QWORD PTR [rax+280]

; 793  : 
; 794  :     /* Delete the space for the factory itself
; 795  :      */
; 796  :     ANTLR3_FREE((void *)factory);

  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 797  : }

  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5f		 pop	 rdi
  00030	c3		 ret	 0
closeFactory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT printableUTF16
_TEXT	SEGMENT
string$ = 32
scannedText$ = 40
inText$ = 48
i$ = 56
outLen$ = 60
factory$ = 80
instr$ = 88
printableUTF16 PROC					; COMDAT

; 730  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 731  :     pANTLR3_STRING  string;
; 732  :     
; 733  :     /* We don't need to be too efficient here, this is mostly for error messages and so on.
; 734  :      */
; 735  :     pANTLR3_UINT16  scannedText;
; 736  :     pANTLR3_UINT16  inText;
; 737  :     ANTLR3_UINT32   i;
; 738  :     ANTLR3_UINT32   outLen;
; 739  : 
; 740  :     /* Assume we need as much as twice as much space to parse out the control characters
; 741  :      */
; 742  :     string  = factory->newSize(factory, instr->len *2 + 1);

  0000f	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00014	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00017	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0001b	8b d0		 mov	 edx, eax
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00027	ff 50 18	 call	 QWORD PTR [rax+24]
  0002a	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 743  : 
; 744  :     /* Scan through and replace unprintable (in terms of this routine)
; 745  :      * characters
; 746  :      */
; 747  :     scannedText = (pANTLR3_UINT16)(string->chars);

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 748  :     inText	= (pANTLR3_UINT16)(instr->chars);

  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00042	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00046	48 89 44 24 30	 mov	 QWORD PTR inText$[rsp], rax

; 749  :     outLen	= 0;

  0004b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR outLen$[rsp], 0

; 750  : 
; 751  :     for	(i = 0; i < instr->len; i++)

  00053	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0005b	eb 0a		 jmp	 SHORT $LN4@printableU
$LN2@printableU:
  0005d	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  00061	ff c0		 inc	 eax
  00063	89 44 24 38	 mov	 DWORD PTR i$[rsp], eax
$LN4@printableU:
  00067	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  0006c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0006f	39 44 24 38	 cmp	 DWORD PTR i$[rsp], eax
  00073	0f 83 1f 01 00
	00		 jae	 $LN3@printableU

; 752  :     {
; 753  : 		if (*(inText + i) == '\n')

  00079	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0007d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inText$[rsp]
  00082	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00086	83 f8 0a	 cmp	 eax, 10
  00089	75 46		 jne	 SHORT $LN5@printableU

; 754  : 		{
; 755  : 			*scannedText++   = '\\';

  0008b	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  00095	66 89 01	 mov	 WORD PTR [rcx], ax
  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0009d	48 83 c0 02	 add	 rax, 2
  000a1	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 756  : 			*scannedText++   = 'n';

  000a6	b8 6e 00 00 00	 mov	 eax, 110		; 0000006eH
  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  000b0	66 89 01	 mov	 WORD PTR [rcx], ax
  000b3	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000b8	48 83 c0 02	 add	 rax, 2
  000bc	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 757  : 			outLen	    += 2;

  000c1	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  000c5	83 c0 02	 add	 eax, 2
  000c8	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax

; 758  : 		}

  000cc	e9 c2 00 00 00	 jmp	 $LN6@printableU
$LN5@printableU:

; 759  : 		else if (*(inText + i) == '\r')

  000d1	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  000d5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inText$[rsp]
  000da	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  000de	83 f8 0d	 cmp	 eax, 13
  000e1	75 43		 jne	 SHORT $LN7@printableU

; 760  : 		{
; 761  : 			*scannedText++   = '\\';

  000e3	b8 5c 00 00 00	 mov	 eax, 92			; 0000005cH
  000e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  000ed	66 89 01	 mov	 WORD PTR [rcx], ax
  000f0	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000f5	48 83 c0 02	 add	 rax, 2
  000f9	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 762  : 			*scannedText++   = 'r';

  000fe	b8 72 00 00 00	 mov	 eax, 114		; 00000072H
  00103	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  00108	66 89 01	 mov	 WORD PTR [rcx], ax
  0010b	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00110	48 83 c0 02	 add	 rax, 2
  00114	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 763  : 			outLen	    += 2;

  00119	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  0011d	83 c0 02	 add	 eax, 2
  00120	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax

; 764  : 		}

  00124	eb 6d		 jmp	 SHORT $LN8@printableU
$LN7@printableU:

; 765  : 		else if	(!isprint(*(inText +i)))

  00126	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0012a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR inText$[rsp]
  0012f	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00133	8b c8		 mov	 ecx, eax
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  0013b	85 c0		 test	 eax, eax
  0013d	75 27		 jne	 SHORT $LN9@printableU

; 766  : 		{
; 767  : 			*scannedText++ = '?';

  0013f	b8 3f 00 00 00	 mov	 eax, 63			; 0000003fH
  00144	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  00149	66 89 01	 mov	 WORD PTR [rcx], ax
  0014c	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00151	48 83 c0 02	 add	 rax, 2
  00155	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 768  : 			outLen++;

  0015a	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  0015e	ff c0		 inc	 eax
  00160	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax

; 769  : 		}

  00164	eb 2d		 jmp	 SHORT $LN10@printableU
$LN9@printableU:

; 770  : 		else
; 771  : 		{
; 772  : 			*scannedText++ = *(inText + i);

  00166	8b 44 24 38	 mov	 eax, DWORD PTR i$[rsp]
  0016a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  0016f	48 8b 54 24 30	 mov	 rdx, QWORD PTR inText$[rsp]
  00174	0f b7 04 42	 movzx	 eax, WORD PTR [rdx+rax*2]
  00178	66 89 01	 mov	 WORD PTR [rcx], ax
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00180	48 83 c0 02	 add	 rax, 2
  00184	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 773  : 			outLen++;

  00189	8b 44 24 3c	 mov	 eax, DWORD PTR outLen$[rsp]
  0018d	ff c0		 inc	 eax
  0018f	89 44 24 3c	 mov	 DWORD PTR outLen$[rsp], eax
$LN10@printableU:
$LN8@printableU:
$LN6@printableU:

; 774  : 		}
; 775  :     }

  00193	e9 c5 fe ff ff	 jmp	 $LN2@printableU
$LN3@printableU:

; 776  :     *scannedText  = '\0';

  00198	33 c0		 xor	 eax, eax
  0019a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  0019f	66 89 01	 mov	 WORD PTR [rcx], ax

; 777  : 
; 778  :     string->len	= outLen;

  001a2	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  001a7	8b 4c 24 3c	 mov	 ecx, DWORD PTR outLen$[rsp]
  001ab	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 779  :     
; 780  :     return  string;

  001ae	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]

; 781  : }

  001b3	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001b7	5f		 pop	 rdi
  001b8	c3		 ret	 0
printableUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT printable8
_TEXT	SEGMENT
string$ = 32
scannedText$ = 40
i$ = 48
factory$ = 80
instr$ = 88
printable8 PROC						; COMDAT

; 683  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 684  :     pANTLR3_STRING  string;
; 685  :     
; 686  :     /* We don't need to be too efficient here, this is mostly for error messages and so on.
; 687  :      */
; 688  :     pANTLR3_UINT8   scannedText;
; 689  :     ANTLR3_UINT32   i;
; 690  : 
; 691  :     /* Assume we need as much as twice as much space to parse out the control characters
; 692  :      */
; 693  :     string  = factory->newSize(factory, instr->len *2 + 1);

  0000f	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00014	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00017	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0001b	8b d0		 mov	 edx, eax
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00027	ff 50 18	 call	 QWORD PTR [rax+24]
  0002a	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 694  : 
; 695  :     /* Scan through and replace unprintable (in terms of this routine)
; 696  :      * characters
; 697  :      */
; 698  :     scannedText = string->chars;

  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 699  : 
; 700  :     for	(i = 0; i < instr->len; i++)

  0003d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00045	eb 0a		 jmp	 SHORT $LN4@printable8
$LN2@printable8:
  00047	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@printable8:
  00051	48 8b 44 24 58	 mov	 rax, QWORD PTR instr$[rsp]
  00056	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00059	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0005d	0f 83 e5 00 00
	00		 jae	 $LN3@printable8

; 701  :     {
; 702  : 		if (*(instr->chars + i) == '\n')

  00063	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  0006c	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00070	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00074	83 f8 0a	 cmp	 eax, 10
  00077	75 2f		 jne	 SHORT $LN5@printable8

; 703  : 		{
; 704  : 			*scannedText++ = '\\';

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0007e	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  00081	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00086	48 ff c0	 inc	 rax
  00089	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 705  : 			*scannedText++ = 'n';

  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00093	c6 00 6e	 mov	 BYTE PTR [rax], 110	; 0000006eH
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0009b	48 ff c0	 inc	 rax
  0009e	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 706  : 		}

  000a3	e9 9b 00 00 00	 jmp	 $LN6@printable8
$LN5@printable8:

; 707  : 		else if (*(instr->chars + i) == '\r')

  000a8	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000ac	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  000b1	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000b5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b9	83 f8 0d	 cmp	 eax, 13
  000bc	75 2c		 jne	 SHORT $LN7@printable8

; 708  : 		{
; 709  : 			*scannedText++ = '\\';

  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000c3	c6 00 5c	 mov	 BYTE PTR [rax], 92	; 0000005cH
  000c6	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000cb	48 ff c0	 inc	 rax
  000ce	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 710  : 			*scannedText++ = 'r';

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000d8	c6 00 72	 mov	 BYTE PTR [rax], 114	; 00000072H
  000db	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  000e0	48 ff c0	 inc	 rax
  000e3	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 711  : 		}

  000e8	eb 59		 jmp	 SHORT $LN8@printable8
$LN7@printable8:

; 712  : 		else if	(!isprint(*(instr->chars +i)))

  000ea	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  000f3	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000f7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000fb	8b c8		 mov	 ecx, eax
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00103	85 c0		 test	 eax, eax
  00105	75 17		 jne	 SHORT $LN9@printable8

; 713  : 		{
; 714  : 			*scannedText++ = '?';

  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0010c	c6 00 3f	 mov	 BYTE PTR [rax], 63	; 0000003fH
  0010f	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  00114	48 ff c0	 inc	 rax
  00117	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax

; 715  : 		}

  0011c	eb 25		 jmp	 SHORT $LN10@printable8
$LN9@printable8:

; 716  : 		else
; 717  : 		{
; 718  : 			*scannedText++ = *(instr->chars + i);

  0011e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00122	48 8b 4c 24 58	 mov	 rcx, QWORD PTR instr$[rsp]
  00127	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0012b	48 8b 54 24 28	 mov	 rdx, QWORD PTR scannedText$[rsp]
  00130	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00134	88 02		 mov	 BYTE PTR [rdx], al
  00136	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0013b	48 ff c0	 inc	 rax
  0013e	48 89 44 24 28	 mov	 QWORD PTR scannedText$[rsp], rax
$LN10@printable8:
$LN8@printable8:
$LN6@printable8:

; 719  : 		}
; 720  :     }

  00143	e9 ff fe ff ff	 jmp	 $LN2@printable8
$LN3@printable8:

; 721  :     *scannedText  = '\0';

  00148	48 8b 44 24 28	 mov	 rax, QWORD PTR scannedText$[rsp]
  0014d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 722  : 
; 723  :     string->len	= (ANTLR3_UINT32)(scannedText - string->chars);

  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00155	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00159	48 8b 4c 24 28	 mov	 rcx, QWORD PTR scannedText$[rsp]
  0015e	48 2b c8	 sub	 rcx, rax
  00161	48 8b c1	 mov	 rax, rcx
  00164	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00169	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 724  :     
; 725  :     return  string;

  0016c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]

; 726  : }

  00171	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00175	5f		 pop	 rdi
  00176	c3		 ret	 0
printable8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT destroy
_TEXT	SEGMENT
strIndex$ = 32
i$1 = 36
factory$ = 64
string$ = 72
destroy	PROC						; COMDAT

; 638  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 639  :     // Record which string we are deleting
; 640  :     //
; 641  :     ANTLR3_UINT32 strIndex = string->index;

  0000f	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  00014	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00017	89 44 24 20	 mov	 DWORD PTR strIndex$[rsp], eax

; 642  :     
; 643  :     // Ensure that the string was not factory made, or we would try
; 644  :     // to delete memory that wasn't allocated outside the factory
; 645  :     // block.
; 646  :     // Remove the specific indexed string from the vector
; 647  :     //
; 648  :     factory->strings->del(factory->strings, strIndex);

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00020	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00023	8b 54 24 20	 mov	 edx, DWORD PTR strIndex$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0002c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0002f	ff 90 20 01 00
	00		 call	 QWORD PTR [rax+288]

; 649  : 
; 650  :     // One less string in the vector, so decrement the factory index
; 651  :     // so that the next string allocated is indexed correctly with
; 652  :     // respect to the vector.
; 653  :     //
; 654  :     factory->index--;

  00035	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0003a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0003d	ff c8		 dec	 eax
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00044	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 655  : 
; 656  :     // Now we have to reindex the strings in the vector that followed
; 657  :     // the one we just deleted. We only do this if the one we just deleted
; 658  :     // was not the last one.
; 659  :     //
; 660  :     if  (strIndex< factory->index)

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0004c	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0004f	39 44 24 20	 cmp	 DWORD PTR strIndex$[rsp], eax
  00053	73 42		 jae	 SHORT $LN5@destroy

; 661  :     {
; 662  :         // We must reindex the strings after the one we just deleted.
; 663  :         // The one that follows the one we just deleted is also out
; 664  :         // of whack, so we start there.
; 665  :         //
; 666  :         ANTLR3_UINT32 i;
; 667  : 
; 668  :         for (i = strIndex; i < factory->index; i++)

  00055	8b 44 24 20	 mov	 eax, DWORD PTR strIndex$[rsp]
  00059	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
  0005d	eb 0a		 jmp	 SHORT $LN4@destroy
$LN2@destroy:
  0005f	8b 44 24 24	 mov	 eax, DWORD PTR i$1[rsp]
  00063	ff c0		 inc	 eax
  00065	89 44 24 24	 mov	 DWORD PTR i$1[rsp], eax
$LN4@destroy:
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0006e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00071	39 44 24 24	 cmp	 DWORD PTR i$1[rsp], eax
  00075	73 20		 jae	 SHORT $LN3@destroy

; 669  :         {
; 670  :             // Renumber the entry
; 671  :             //
; 672  :             ((pANTLR3_STRING)(factory->strings->elements[i].element))->index = i;

  00077	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	8b 4c 24 24	 mov	 ecx, DWORD PTR i$1[rsp]
  00083	48 6b c9 10	 imul	 rcx, rcx, 16
  00087	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008a	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0008e	8b 4c 24 24	 mov	 ecx, DWORD PTR i$1[rsp]
  00092	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 673  :         }

  00095	eb c8		 jmp	 SHORT $LN2@destroy
$LN3@destroy:
$LN5@destroy:

; 674  :     }
; 675  : 
; 676  :     // The string has been destroyed and the elements of the factory are reindexed.
; 677  :     //
; 678  : 
; 679  : }

  00097	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
destroy	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newStrUTF16_UTF16
_TEXT	SEGMENT
in$ = 32
count$ = 40
tv67 = 44
tv68 = 48
factory$ = 80
ptr$ = 88
newStrUTF16_UTF16 PROC					; COMDAT

; 620  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 621  :     pANTLR3_UINT16  in;
; 622  :     ANTLR3_UINT32   count;
; 623  : 
; 624  :     /** First, determine the length of the input string
; 625  :      */
; 626  :     in	    = (pANTLR3_UINT16)ptr;

  0000f	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00014	48 89 44 24 20	 mov	 QWORD PTR in$[rsp], rax

; 627  :     count   = 0;

  00019	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@newStrUTF1:

; 628  : 
; 629  :     while   (*in++ != '\0')

  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  00026	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00029	89 44 24 2c	 mov	 DWORD PTR tv67[rsp], eax
  0002d	48 8b 44 24 20	 mov	 rax, QWORD PTR in$[rsp]
  00032	48 83 c0 02	 add	 rax, 2
  00036	48 89 44 24 20	 mov	 QWORD PTR in$[rsp], rax
  0003b	83 7c 24 2c 00	 cmp	 DWORD PTR tv67[rsp], 0
  00040	74 0a		 je	 SHORT $LN5@newStrUTF1
  00042	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0004a	eb 08		 jmp	 SHORT $LN6@newStrUTF1
$LN5@newStrUTF1:
  0004c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN6@newStrUTF1:
  00054	83 7c 24 30 00	 cmp	 DWORD PTR tv68[rsp], 0
  00059	74 0c		 je	 SHORT $LN3@newStrUTF1

; 630  :     {
; 631  : 		count++;

  0005b	8b 44 24 28	 mov	 eax, DWORD PTR count$[rsp]
  0005f	ff c0		 inc	 eax
  00061	89 44 24 28	 mov	 DWORD PTR count$[rsp], eax

; 632  :     }

  00065	eb ba		 jmp	 SHORT $LN2@newStrUTF1
$LN3@newStrUTF1:

; 633  :     return factory->newPtr(factory, ptr, count);

  00067	44 8b 44 24 28	 mov	 r8d, DWORD PTR count$[rsp]
  0006c	48 8b 54 24 58	 mov	 rdx, QWORD PTR ptr$[rsp]
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  0007b	ff 50 20	 call	 QWORD PTR [rax+32]

; 634  : }

  0007e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
newStrUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newStrUTF16_8
_TEXT	SEGMENT
factory$ = 48
ptr$ = 56
newStrUTF16_8 PROC					; COMDAT

; 609  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 610  :     return factory->newPtr8(factory, ptr, (ANTLR3_UINT32)strlen((const char *)ptr));

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	44 8b c0	 mov	 r8d, eax
  0001c	48 8b 54 24 38	 mov	 rdx, QWORD PTR ptr$[rsp]
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0002b	ff 50 28	 call	 QWORD PTR [rax+40]

; 611  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
newStrUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newStr8
_TEXT	SEGMENT
factory$ = 48
ptr$ = 56
newStr8	PROC						; COMDAT

; 598  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 599  :     return factory->newPtr8(factory, ptr, (ANTLR3_UINT32)strlen((const char *)ptr));

  0000f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$[rsp]
  00014	e8 00 00 00 00	 call	 strlen
  00019	44 8b c0	 mov	 r8d, eax
  0001c	48 8b 54 24 38	 mov	 rdx, QWORD PTR ptr$[rsp]
  00021	48 8b 4c 24 30	 mov	 rcx, QWORD PTR factory$[rsp]
  00026	48 8b 44 24 30	 mov	 rax, QWORD PTR factory$[rsp]
  0002b	ff 50 28	 call	 QWORD PTR [rax+40]

; 600  : }

  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
newStr8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newPtrUTF16_UTF16
_TEXT	SEGMENT
string$ = 32
factory$ = 64
ptr$ = 72
size$ = 80
newPtrUTF16_UTF16 PROC					; COMDAT

; 563  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 564  : 	pANTLR3_STRING  string;
; 565  : 
; 566  : 	string  = factory->newSize(factory, size);

  00014	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00022	ff 50 18	 call	 QWORD PTR [rax+24]
  00025	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 567  : 
; 568  : 	if	(string == NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00030	75 04		 jne	 SHORT $LN2@newPtrUTF1

; 569  : 	{
; 570  : 		return	NULL;

  00032	33 c0		 xor	 eax, eax
  00034	eb 57		 jmp	 SHORT $LN1@newPtrUTF1
$LN2@newPtrUTF1:

; 571  : 	}
; 572  : 
; 573  : 	if	(size <= 0)

  00036	83 7c 24 50 00	 cmp	 DWORD PTR size$[rsp], 0
  0003b	77 07		 ja	 SHORT $LN3@newPtrUTF1

; 574  : 	{
; 575  : 		return	string;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00042	eb 49		 jmp	 SHORT $LN1@newPtrUTF1
$LN3@newPtrUTF1:

; 576  : 	}
; 577  : 
; 578  : 	if	(ptr != NULL)

  00044	48 83 7c 24 48
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0004a	74 3c		 je	 SHORT $LN4@newPtrUTF1

; 579  : 	{
; 580  : 		ANTLR3_MEMMOVE(string->chars, (const void *)ptr, (size * sizeof(ANTLR3_UINT16)));

  0004c	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00050	48 d1 e0	 shl	 rax, 1
  00053	4c 8b c0	 mov	 r8, rax
  00056	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00060	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00064	e8 00 00 00 00	 call	 memmove

; 581  : 
; 582  : 		/* Terminate, these strings are usually used for Token streams and printing etc.	
; 583  : 		*/
; 584  : 		*(((pANTLR3_UINT16)(string->chars)) + size) = '\0';	    

  00069	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00072	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00076	33 d2		 xor	 edx, edx
  00078	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 585  : 		string->len = size;

  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00081	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  00085	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN4@newPtrUTF1:

; 586  : 	}
; 587  : 
; 588  : 	return  string;

  00088	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newPtrUTF1:

; 589  : }

  0008d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00091	5f		 pop	 rdi
  00092	c3		 ret	 0
newPtrUTF16_UTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newPtrUTF16_8
_TEXT	SEGMENT
string$ = 32
out$1 = 40
inSize$2 = 48
tv74 = 52
tv75 = 56
factory$ = 80
ptr$ = 88
size$ = 96
newPtrUTF16_8 PROC					; COMDAT

; 515  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 516  : 	pANTLR3_STRING  string;
; 517  : 
; 518  : 	/* newSize accepts size in characters, not bytes
; 519  : 	*/
; 520  : 	string  = factory->newSize(factory, size);

  00014	8b 54 24 60	 mov	 edx, DWORD PTR size$[rsp]
  00018	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00022	ff 50 18	 call	 QWORD PTR [rax+24]
  00025	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 521  : 
; 522  : 	if	(string == NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00030	75 07		 jne	 SHORT $LN4@newPtrUTF1

; 523  : 	{
; 524  : 		return	NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 b6 00 00 00	 jmp	 $LN1@newPtrUTF1
$LN4@newPtrUTF1:

; 525  : 	}
; 526  : 
; 527  : 	if	(size <= 0)

  00039	83 7c 24 60 00	 cmp	 DWORD PTR size$[rsp], 0
  0003e	77 0a		 ja	 SHORT $LN5@newPtrUTF1

; 528  : 	{
; 529  : 		return	string;

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00045	e9 a5 00 00 00	 jmp	 $LN1@newPtrUTF1
$LN5@newPtrUTF1:

; 530  : 	}
; 531  : 
; 532  : 	if	(ptr != NULL)

  0004a	48 83 7c 24 58
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  00050	0f 84 94 00 00
	00		 je	 $LN6@newPtrUTF1

; 533  : 	{
; 534  : 		pANTLR3_UINT16	out;
; 535  : 		ANTLR3_INT32    inSize;
; 536  : 
; 537  : 		out = (pANTLR3_UINT16)(string->chars);

  00056	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0005b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005f	48 89 44 24 28	 mov	 QWORD PTR out$1[rsp], rax

; 538  : 		inSize	= size;

  00064	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  00068	89 44 24 30	 mov	 DWORD PTR inSize$2[rsp], eax
$LN2@newPtrUTF1:

; 539  : 
; 540  : 		while	(inSize-- > 0)

  0006c	8b 44 24 30	 mov	 eax, DWORD PTR inSize$2[rsp]
  00070	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
  00074	8b 44 24 30	 mov	 eax, DWORD PTR inSize$2[rsp]
  00078	ff c8		 dec	 eax
  0007a	89 44 24 30	 mov	 DWORD PTR inSize$2[rsp], eax
  0007e	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00083	7e 0a		 jle	 SHORT $LN8@newPtrUTF1
  00085	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN9@newPtrUTF1
$LN8@newPtrUTF1:
  0008f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN9@newPtrUTF1:
  00097	83 7c 24 38 00	 cmp	 DWORD PTR tv75[rsp], 0
  0009c	74 2d		 je	 SHORT $LN3@newPtrUTF1

; 541  : 		{
; 542  : 			*out++ = (ANTLR3_UINT16)(*ptr++);

  0009e	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  000a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR out$1[rsp]
  000ab	66 89 01	 mov	 WORD PTR [rcx], ax
  000ae	48 8b 44 24 28	 mov	 rax, QWORD PTR out$1[rsp]
  000b3	48 83 c0 02	 add	 rax, 2
  000b7	48 89 44 24 28	 mov	 QWORD PTR out$1[rsp], rax
  000bc	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  000c1	48 ff c0	 inc	 rax
  000c4	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 543  : 		}

  000c9	eb a1		 jmp	 SHORT $LN2@newPtrUTF1
$LN3@newPtrUTF1:

; 544  : 
; 545  : 		/* Terminate, these strings are usually used for Token streams and printing etc.	
; 546  : 		*/
; 547  : 		*(((pANTLR3_UINT16)(string->chars)) + size) = '\0';

  000cb	8b 44 24 60	 mov	 eax, DWORD PTR size$[rsp]
  000cf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  000d4	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  000d8	33 d2		 xor	 edx, edx
  000da	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 548  : 
; 549  : 		string->len = size;

  000de	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  000e3	8b 4c 24 60	 mov	 ecx, DWORD PTR size$[rsp]
  000e7	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN6@newPtrUTF1:

; 550  : 	}
; 551  : 
; 552  : 	return  string;

  000ea	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newPtrUTF1:

; 553  : }

  000ef	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000f3	5f		 pop	 rdi
  000f4	c3		 ret	 0
newPtrUTF16_8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newPtr8
_TEXT	SEGMENT
string$ = 32
factory$ = 64
ptr$ = 72
size$ = 80
newPtr8	PROC						; COMDAT

; 482  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 483  : 	pANTLR3_STRING  string;
; 484  : 
; 485  : 	string  = factory->newSize(factory, size);

  00014	8b 54 24 50	 mov	 edx, DWORD PTR size$[rsp]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00022	ff 50 18	 call	 QWORD PTR [rax+24]
  00025	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 486  : 
; 487  : 	if	(string == NULL)

  0002a	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00030	75 04		 jne	 SHORT $LN2@newPtr8

; 488  : 	{
; 489  : 		return	NULL;

  00032	33 c0		 xor	 eax, eax
  00034	eb 52		 jmp	 SHORT $LN1@newPtr8
$LN2@newPtr8:

; 490  : 	}
; 491  : 
; 492  : 	if	(size <= 0)

  00036	83 7c 24 50 00	 cmp	 DWORD PTR size$[rsp], 0
  0003b	77 07		 ja	 SHORT $LN3@newPtr8

; 493  : 	{
; 494  : 		return	string;

  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00042	eb 44		 jmp	 SHORT $LN1@newPtr8
$LN3@newPtr8:

; 495  : 	}
; 496  : 
; 497  : 	if	(ptr != NULL)

  00044	48 83 7c 24 48
	00		 cmp	 QWORD PTR ptr$[rsp], 0
  0004a	74 37		 je	 SHORT $LN4@newPtr8

; 498  : 	{
; 499  : 		ANTLR3_MEMMOVE(string->chars, (const void *)ptr, size);

  0004c	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00050	44 8b c0	 mov	 r8d, eax
  00053	48 8b 54 24 48	 mov	 rdx, QWORD PTR ptr$[rsp]
  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0005d	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00061	e8 00 00 00 00	 call	 memmove

; 500  : 		*(string->chars + size) = '\0';	    /* Terminate, these strings are usually used for Token streams and printing etc.	*/

  00066	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0006f	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00073	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 501  : 		string->len = size;

  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0007c	8b 4c 24 50	 mov	 ecx, DWORD PTR size$[rsp]
  00080	89 48 10	 mov	 DWORD PTR [rax+16], ecx
$LN4@newPtr8:

; 502  : 	}
; 503  : 
; 504  : 	return  string;

  00083	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newPtr8:

; 505  : }

  00088	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0008c	5f		 pop	 rdi
  0008d	c3		 ret	 0
newPtr8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newSizeUTF16
_TEXT	SEGMENT
string$ = 32
factory$ = 64
size$ = 72
newSizeUTF16 PROC					; COMDAT

; 452  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 453  :     pANTLR3_STRING  string;
; 454  : 
; 455  :     string  = factory->newRaw(factory);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00018	ff 50 10	 call	 QWORD PTR [rax+16]
  0001b	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 456  : 
; 457  :     if	(string == NULL)

  00020	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00026	75 07		 jne	 SHORT $LN2@newSizeUTF

; 458  :     {
; 459  :         return	string;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0002d	eb 48		 jmp	 SHORT $LN1@newSizeUTF
$LN2@newSizeUTF:

; 460  :     }
; 461  : 
; 462  :     /* Always add one more byte for a terminator ;-)
; 463  :     */	
; 464  :     string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT16) * (size+1)));

  0002f	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00033	ff c0		 inc	 eax
  00035	8b c0		 mov	 eax, eax
  00037	48 d1 e0	 shl	 rax, 1
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00043	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00048	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 465  :     if (string->chars != NULL)

  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00051	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00056	74 1a		 je	 SHORT $LN3@newSizeUTF

; 466  : 	{
; 467  : 		*(string->chars)	= '\0';

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0005d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00061	c6 00 00	 mov	 BYTE PTR [rax], 0

; 468  : 		string->size	= size+1;	/* Size is always in characters, as is len */

  00064	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00068	ff c0		 inc	 eax
  0006a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0006f	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN3@newSizeUTF:

; 469  : 	}
; 470  : 
; 471  :     return string;

  00072	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newSizeUTF:

; 472  : }

  00077	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
newSizeUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newSize8
_TEXT	SEGMENT
string$ = 32
factory$ = 64
size$ = 72
newSize8 PROC						; COMDAT

; 422  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 423  :     pANTLR3_STRING  string;
; 424  : 
; 425  :     string  = factory->newRaw(factory);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR factory$[rsp]
  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR factory$[rsp]
  00018	ff 50 10	 call	 QWORD PTR [rax+16]
  0001b	48 89 44 24 20	 mov	 QWORD PTR string$[rsp], rax

; 426  : 
; 427  :     if	(string == NULL)

  00020	48 83 7c 24 20
	00		 cmp	 QWORD PTR string$[rsp], 0
  00026	75 07		 jne	 SHORT $LN2@newSize8

; 428  :     {
; 429  :         return	string;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0002d	eb 44		 jmp	 SHORT $LN1@newSize8
$LN2@newSize8:

; 430  :     }
; 431  : 
; 432  :     /* Always add one more byte for a terminator ;-)
; 433  :     */
; 434  :     string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT8) * (size+1)));

  0002f	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00033	ff c0		 inc	 eax
  00035	8b c0		 mov	 eax, eax
  00037	8b c8		 mov	 ecx, eax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  00044	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 435  : 	if (string->chars != NULL)

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  0004d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00052	74 1a		 je	 SHORT $LN3@newSize8

; 436  :     {
; 437  : 		*(string->chars)	= '\0';

  00054	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
  00059	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 438  : 		string->size	= size + 1;

  00060	8b 44 24 48	 mov	 eax, DWORD PTR size$[rsp]
  00064	ff c0		 inc	 eax
  00066	48 8b 4c 24 20	 mov	 rcx, QWORD PTR string$[rsp]
  0006b	89 41 14	 mov	 DWORD PTR [rcx+20], eax
$LN3@newSize8:

; 439  : 	}
; 440  : 
; 441  :     return string;

  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newSize8:

; 442  : }

  00073	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
newSize8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newRawUTF16
_TEXT	SEGMENT
string$ = 48
factory$ = 80
newRawUTF16 PROC					; COMDAT

; 216  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 217  :     pANTLR3_STRING  string;
; 218  : 
; 219  :     string  = (pANTLR3_STRING) ANTLR3_MALLOC(sizeof(ANTLR3_STRING));

  0000a	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 30	 mov	 QWORD PTR string$[rsp], rax

; 220  : 
; 221  :     if	(string == NULL)

  0001a	48 83 7c 24 30
	00		 cmp	 QWORD PTR string$[rsp], 0
  00020	75 04		 jne	 SHORT $LN2@newRawUTF1

; 222  :     {
; 223  : 		return	NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 6d		 jmp	 SHORT $LN1@newRawUTF1
$LN2@newRawUTF1:

; 224  :     }
; 225  : 
; 226  :     /* Structure is allocated, now fill in the API etc.
; 227  :      */
; 228  :     stringInitUTF16(string);

  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0002b	e8 00 00 00 00	 call	 stringInitUTF16

; 229  :     string->factory = factory;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00035	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0003a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 230  : 
; 231  :     /* Add the string into the allocated list
; 232  :      */
; 233  :     factory->strings->set(factory->strings, factory->index, (void *) string, (void (ANTLR3_CDECL *)(void *))(stringFree), ANTLR3_TRUE);

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:stringFree
  00051	4c 8b 44 24 30	 mov	 r8, QWORD PTR string$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0005b	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00063	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00066	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 234  :     string->index   = factory->index++;

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00076	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00079	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00081	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00084	ff c0		 inc	 eax
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0008b	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 235  : 
; 236  :     return string;

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newRawUTF1:

; 237  : }

  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
newRawUTF16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT newRaw8
_TEXT	SEGMENT
string$ = 48
factory$ = 80
newRaw8	PROC						; COMDAT

; 187  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 188  :     pANTLR3_STRING  string;
; 189  : 
; 190  :     string  = (pANTLR3_STRING) ANTLR3_MALLOC(sizeof(ANTLR3_STRING));

  0000a	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00015	48 89 44 24 30	 mov	 QWORD PTR string$[rsp], rax

; 191  : 
; 192  :     if	(string == NULL)

  0001a	48 83 7c 24 30
	00		 cmp	 QWORD PTR string$[rsp], 0
  00020	75 04		 jne	 SHORT $LN2@newRaw8

; 193  :     {
; 194  : 		return	NULL;

  00022	33 c0		 xor	 eax, eax
  00024	eb 6d		 jmp	 SHORT $LN1@newRaw8
$LN2@newRaw8:

; 195  :     }
; 196  : 
; 197  :     /* Structure is allocated, now fill in the API etc.
; 198  :      */
; 199  :     stringInit8(string);

  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR string$[rsp]
  0002b	e8 00 00 00 00	 call	 stringInit8

; 200  :     string->factory = factory;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00035	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0003a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 201  : 
; 202  :     /* Add the string into the allocated list
; 203  :      */
; 204  :     factory->strings->set(factory->strings, factory->index, (void *) string, (void (ANTLR3_CDECL *)(void *))(stringFree), ANTLR3_TRUE);

  0003d	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00042	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00045	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:stringFree
  00051	4c 8b 44 24 30	 mov	 r8, QWORD PTR string$[rsp]
  00056	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0005b	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  0005e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00063	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00066	ff 90 50 01 00
	00		 call	 QWORD PTR [rax+336]

; 205  :     string->index   = factory->index++;

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  00076	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00079	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR factory$[rsp]
  00081	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00084	ff c0		 inc	 eax
  00086	48 8b 4c 24 50	 mov	 rcx, QWORD PTR factory$[rsp]
  0008b	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 206  : 
; 207  :     return string;

  0008e	48 8b 44 24 30	 mov	 rax, QWORD PTR string$[rsp]
$LN1@newRaw8:

; 208  : }

  00093	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00097	5f		 pop	 rdi
  00098	c3		 ret	 0
newRaw8	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File A:\Projects\studying\SSLab\lib\antlr3-3.5.3\runtime\C\src\antlr3string.c
;	COMDAT antlr3StringFactoryNew
_TEXT	SEGMENT
factory$ = 32
tv78 = 40
encoding$ = 64
antlr3StringFactoryNew PROC				; COMDAT

; 99   : {

$LN19:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	57		 push	 rdi
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 100  : 	pANTLR3_STRING_FACTORY  factory;
; 101  : 
; 102  : 	/* Allocate memory
; 103  : 	*/
; 104  : 	factory	= (pANTLR3_STRING_FACTORY) ANTLR3_CALLOC(1, sizeof(ANTLR3_STRING_FACTORY));

  00009	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00019	48 89 44 24 20	 mov	 QWORD PTR factory$[rsp], rax

; 105  : 
; 106  : 	if	(factory == NULL)

  0001e	48 83 7c 24 20
	00		 cmp	 QWORD PTR factory$[rsp], 0
  00024	75 07		 jne	 SHORT $LN4@antlr3Stri

; 107  : 	{
; 108  : 		return	NULL;

  00026	33 c0		 xor	 eax, eax
  00028	e9 ae 01 00 00	 jmp	 $LN1@antlr3Stri
$LN4@antlr3Stri:

; 109  : 	}
; 110  : 
; 111  : 	/* Now we make a new list to track the strings.
; 112  : 	*/
; 113  : 	factory->strings	= antlr3VectorNew(0);

  0002d	33 c9		 xor	 ecx, ecx
  0002f	e8 00 00 00 00	 call	 antlr3VectorNew
  00034	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00039	48 89 01	 mov	 QWORD PTR [rcx], rax

; 114  : 	factory->index	= 0;

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00041	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 115  : 
; 116  : 	if	(factory->strings == NULL)

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0004d	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00051	75 12		 jne	 SHORT $LN5@antlr3Stri

; 117  : 	{
; 118  : 		ANTLR3_FREE(factory);

  00053	48 8b 4c 24 20	 mov	 rcx, QWORD PTR factory$[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 119  : 		return	NULL;

  0005e	33 c0		 xor	 eax, eax
  00060	e9 76 01 00 00	 jmp	 $LN1@antlr3Stri
$LN5@antlr3Stri:

; 120  : 	}
; 121  : 
; 122  :     // Install the API
; 123  :     //
; 124  :     // TODO: These encodings need equivalent functions to
; 125  :     // UTF16 and 8Bit if I am going to support those encodings in the STRING stuff.
; 126  : 	// The STRING stuff was intended as a quick and dirty hack for people that did not
; 127  : 	// want to worry about memory and performance very much, but nobody ever reads the 
; 128  : 	// notes or comments or uses the email list search. I want to discourage using these
; 129  : 	// interfaces as it is much more efficient to use the pointers within the tokens
; 130  : 	// directly, so I am not implementing the string stuff for the newer encodings.
; 131  :     // We install the standard 8 and 16 bit functions for the UTF 8 and 16 but they
; 132  : 	// will not be useful beyond returning the text.
; 133  : 	// 
; 134  :     switch(encoding)

  00065	8b 44 24 40	 mov	 eax, DWORD PTR encoding$[rsp]
  00069	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  0006d	8b 44 24 28	 mov	 eax, DWORD PTR tv78[rsp]
  00071	83 e8 04	 sub	 eax, 4
  00074	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  00078	83 7c 24 28 3c	 cmp	 DWORD PTR tv78[rsp], 60	; 0000003cH
  0007d	0f 87 c3 00 00
	00		 ja	 $LN15@antlr3Stri
  00083	8b 44 24 28	 mov	 eax, DWORD PTR tv78[rsp]
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0008e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN17@antlr3Stri[rcx+rax]
  00096	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN18@antlr3Stri[rcx+rax*4]
  0009d	48 03 c1	 add	 rax, rcx
  000a0	ff e0		 jmp	 rax
$LN6@antlr3Stri:

; 135  :     {
; 136  : 		case    ANTLR3_ENC_UTF32:
; 137  : 			break;

  000a2	e9 2f 01 00 00	 jmp	 $LN2@antlr3Stri
$LN7@antlr3Stri:

; 138  : 
; 139  : 		case    ANTLR3_ENC_UTF32BE:
; 140  : 			break;

  000a7	e9 2a 01 00 00	 jmp	 $LN2@antlr3Stri
$LN8@antlr3Stri:

; 141  : 
; 142  : 		case    ANTLR3_ENC_UTF32LE:
; 143  : 			break;

  000ac	e9 25 01 00 00	 jmp	 $LN2@antlr3Stri
$LN9@antlr3Stri:
$LN10@antlr3Stri:
$LN11@antlr3Stri:

; 144  : 
; 145  : 		case    ANTLR3_ENC_UTF16BE:
; 146  : 		case    ANTLR3_ENC_UTF16LE:
; 147  : 		case    ANTLR3_ENC_UTF16:
; 148  : 
; 149  : 			factory->newRaw	    =  newRawUTF16;

  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newRawUTF16
  000bd	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 150  : 			factory->newSize	=  newSizeUTF16;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newSizeUTF16
  000cd	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 151  : 			factory->newPtr	    =  newPtrUTF16_UTF16;

  000d1	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtrUTF16_UTF16
  000dd	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 152  : 			factory->newPtr8	=  newPtrUTF16_8;

  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtrUTF16_8
  000ed	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 153  : 			factory->newStr	    =  newStrUTF16_UTF16;

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStrUTF16_UTF16
  000fd	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 154  : 			factory->newStr8	=  newStrUTF16_8;

  00101	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStrUTF16_8
  0010d	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 155  : 			factory->printable	=  printableUTF16;

  00111	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:printableUTF16
  0011d	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 156  : 			factory->destroy	=  destroy;

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:destroy
  0012d	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 157  : 			factory->close	    =  closeFactory;

  00131	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:closeFactory
  0013d	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 158  : 			break;

  00141	e9 90 00 00 00	 jmp	 $LN2@antlr3Stri
$LN12@antlr3Stri:
$LN13@antlr3Stri:
$LN14@antlr3Stri:
$LN15@antlr3Stri:

; 159  : 	 
; 160  : 		case    ANTLR3_ENC_UTF8:
; 161  : 		case    ANTLR3_ENC_EBCDIC:
; 162  : 		case    ANTLR3_ENC_8BIT:
; 163  : 		default:
; 164  : 
; 165  : 			factory->newRaw	    =  newRaw8;

  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newRaw8
  00152	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 166  : 			factory->newSize	=  newSize8;

  00156	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newSize8
  00162	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 167  : 			factory->newPtr	    =  newPtr8;

  00166	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtr8
  00172	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 168  : 			factory->newPtr8	=  newPtr8;

  00176	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newPtr8
  00182	48 89 48 28	 mov	 QWORD PTR [rax+40], rcx

; 169  : 			factory->newStr	    =  newStr8;

  00186	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStr8
  00192	48 89 48 30	 mov	 QWORD PTR [rax+48], rcx

; 170  : 			factory->newStr8	=  newStr8;

  00196	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:newStr8
  001a2	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx

; 171  : 			factory->printable	=  printable8;

  001a6	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:printable8
  001b2	48 89 48 48	 mov	 QWORD PTR [rax+72], rcx

; 172  : 			factory->destroy	=  destroy;

  001b6	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:destroy
  001c2	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 173  : 			factory->close	    =  closeFactory;

  001c6	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:closeFactory
  001d2	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx
$LN2@antlr3Stri:

; 174  : 			break;
; 175  :     }
; 176  : 	return  factory;

  001d6	48 8b 44 24 20	 mov	 rax, QWORD PTR factory$[rsp]
$LN1@antlr3Stri:

; 177  : }

  001db	48 83 c4 30	 add	 rsp, 48			; 00000030H
  001df	5f		 pop	 rdi
  001e0	c3		 ret	 0
  001e1	0f 1f 00	 npad	 3
$LN18@antlr3Stri:
  001e4	00 00 00 00	 DD	 $LN14@antlr3Stri
  001e8	00 00 00 00	 DD	 $LN12@antlr3Stri
  001ec	00 00 00 00	 DD	 $LN11@antlr3Stri
  001f0	00 00 00 00	 DD	 $LN9@antlr3Stri
  001f4	00 00 00 00	 DD	 $LN10@antlr3Stri
  001f8	00 00 00 00	 DD	 $LN6@antlr3Stri
  001fc	00 00 00 00	 DD	 $LN7@antlr3Stri
  00200	00 00 00 00	 DD	 $LN8@antlr3Stri
  00204	00 00 00 00	 DD	 $LN13@antlr3Stri
  00208	00 00 00 00	 DD	 $LN15@antlr3Stri
$LN17@antlr3Stri:
  0020c	00		 DB	 0
  0020d	09		 DB	 9
  0020e	09		 DB	 9
  0020f	09		 DB	 9
  00210	01		 DB	 1
  00211	09		 DB	 9
  00212	09		 DB	 9
  00213	09		 DB	 9
  00214	09		 DB	 9
  00215	09		 DB	 9
  00216	09		 DB	 9
  00217	09		 DB	 9
  00218	02		 DB	 2
  00219	03		 DB	 3
  0021a	04		 DB	 4
  0021b	09		 DB	 9
  0021c	09		 DB	 9
  0021d	09		 DB	 9
  0021e	09		 DB	 9
  0021f	09		 DB	 9
  00220	09		 DB	 9
  00221	09		 DB	 9
  00222	09		 DB	 9
  00223	09		 DB	 9
  00224	09		 DB	 9
  00225	09		 DB	 9
  00226	09		 DB	 9
  00227	09		 DB	 9
  00228	05		 DB	 5
  00229	06		 DB	 6
  0022a	07		 DB	 7
  0022b	09		 DB	 9
  0022c	09		 DB	 9
  0022d	09		 DB	 9
  0022e	09		 DB	 9
  0022f	09		 DB	 9
  00230	09		 DB	 9
  00231	09		 DB	 9
  00232	09		 DB	 9
  00233	09		 DB	 9
  00234	09		 DB	 9
  00235	09		 DB	 9
  00236	09		 DB	 9
  00237	09		 DB	 9
  00238	09		 DB	 9
  00239	09		 DB	 9
  0023a	09		 DB	 9
  0023b	09		 DB	 9
  0023c	09		 DB	 9
  0023d	09		 DB	 9
  0023e	09		 DB	 9
  0023f	09		 DB	 9
  00240	09		 DB	 9
  00241	09		 DB	 9
  00242	09		 DB	 9
  00243	09		 DB	 9
  00244	09		 DB	 9
  00245	09		 DB	 9
  00246	09		 DB	 9
  00247	09		 DB	 9
  00248	08		 DB	 8
antlr3StringFactoryNew ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 56
_Buffer$ = 96
_Format$ = 104
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	57		 push	 rdi
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00019	48 8d 7c 24 20	 lea	 rdi, QWORD PTR [rsp+32]
  0001e	b9 0c 00 00 00	 mov	 ecx, 12
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR [rsp+96]

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  0002f	48 8d 44 24 70	 lea	 rax, QWORD PTR _Format$[rsp+8]
  00034	48 89 44 24 38	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00039	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0003e	45 33 c0	 xor	 r8d, r8d
  00041	48 8b 54 24 68	 mov	 rdx, QWORD PTR _Format$[rsp]
  00046	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0004b	e8 00 00 00 00	 call	 _vsprintf_l
  00050	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  00054	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  0005d	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  00061	8b f8		 mov	 edi, eax
  00063	48 8b cc	 mov	 rcx, rsp
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:sprintf$rtcFrameData
  0006d	e8 00 00 00 00	 call	 _RTC_CheckStackVars
  00072	8b c7		 mov	 eax, edi
  00074	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00019	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00023	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00028	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002d	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00039	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	5f		 pop	 rdi
  00043	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00019	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 83 c8 01	 or	 rax, 1
  00025	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  0002a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00034	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00039	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003e	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00043	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00048	48 8b c8	 mov	 rcx, rax
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00051	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00055	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0005a	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005c	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00064	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00066	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0006a	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006e	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00072	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 90   :     {

$LN3:
  00000	40 57		 push	 rdi

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00002	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00009	5f		 pop	 rdi
  0000a	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
